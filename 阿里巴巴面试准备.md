# 阿里巴巴Java开发工程师(资深/专家)面试准备


[TOC]



## 面试邀请邮件
强鹏阳，您好！
非常高兴的通知您，胡颖于2017-10-13推荐您应聘阿里巴巴职位：业务平台-JAVA研发工程师／专家-杭州。我们会在10个工作日内处理，请您耐心等待。
您应聘的职位详情如下：
职位名称：业务平台-JAVA研发工程师／专家-杭州
职位描述：业务平台事业部，是阿里巴巴电子商务操作系统的基石，是中台战略的主阵地，由会员、商品、交易、店铺、资金、拍卖、数据等多个核心业务平台组成，旨在提供简单可信赖的电商技术基础产品，高效高质量地支持阿里巴巴集团业务的全球化布局和创新性发展。 为承接集团的中台及全球化战略，业务平台事业部需要和更多有志之士携手，在平台的可靠、高效、易扩展方面进行探索，如果你对复杂的业务场景有经验，对技术的深度有追求，对商业的本质感兴趣，欢迎加入阿里巴巴业务平台事业部。 1.负责具体业务功能的开发（拍卖、会员、商品、交易、店铺、资金等），深入发掘业务需求，独当一面，包括需求分析、架构设计和代码实现； 2.持续优化系统架构，提高系统在高并发、大流量下的容灾容错能力，保证系统的高可用性（性能、安全、容量）； 3.通过梳理和抽象，沉淀通用性的平台或服务能力，发现和解决存在的技术问题，并在具体的业务场景中进行验证推广；
职位要求：1. 本科及以上学历，计算机软件或相关专业； 2. 3年及以上使用JAVA开发的经验，JAVA基础扎实，理解io、多线程、集合等基础框架，对JVM原理有一定的了解，对Spring,ibatis,struts等开源框架熟悉； 3. 熟悉分布式系统的设计和应用，熟悉分布式、缓存、消息等机制；能对分布式常用技术进行合理应用，解决问题； 4. 掌握多线程及高性能的设计与编码及性能调优；有高并发应用开发经验； 5. 掌握Linux 操作系统和大型数据库（Oracle、MySql）；对sql优化有丰富的经验； 6. 学习能力强，适应能力好，有强烈的责任心，具备耐心/细心的品质；

应聘体验反馈电话：0571-81595900
阿里巴巴集团
人力资源部


Hello 强鹏阳，
We are very happy to tell you that on 2017-10-13, 胡颖 recommended you for an Alibaba position：业务平台-JAVA研发工程师／专家-杭州.We will process your application within 10 working days, and thank you for your patience.
Your recruitment position details are as follows:
职位名称：业务平台-JAVA研发工程师／专家-杭州
职位描述：业务平台事业部，是阿里巴巴电子商务操作系统的基石，是中台战略的主阵地，由会员、商品、交易、店铺、资金、拍卖、数据等多个核心业务平台组成，旨在提供简单可信赖的电商技术基础产品，高效高质量地支持阿里巴巴集团业务的全球化布局和创新性发展。 为承接集团的中台及全球化战略，业务平台事业部需要和更多有志之士携手，在平台的可靠、高效、易扩展方面进行探索，如果你对复杂的业务场景有经验，对技术的深度有追求，对商业的本质感兴趣，欢迎加入阿里巴巴业务平台事业部。 1.负责具体业务功能的开发（拍卖、会员、商品、交易、店铺、资金等），深入发掘业务需求，独当一面，包括需求分析、架构设计和代码实现； 2.持续优化系统架构，提高系统在高并发、大流量下的容灾容错能力，保证系统的高可用性（性能、安全、容量）； 3.通过梳理和抽象，沉淀通用性的平台或服务能力，发现和解决存在的技术问题，并在具体的业务场景中进行验证推广；
职位要求：1. 本科及以上学历，计算机软件或相关专业； 2. 3年及以上使用JAVA开发的经验，JAVA基础扎实，理解io、多线程、集合等基础框架，对JVM原理有一定的了解，对Spring,ibatis,struts等开源框架熟悉； 3. 熟悉分布式系统的设计和应用，熟悉分布式、缓存、消息等机制；能对分布式常用技术进行合理应用，解决问题； 4. 掌握多线程及高性能的设计与编码及性能调优；有高并发应用开发经验； 5. 掌握Linux 操作系统和大型数据库（Oracle、MySql）；对sql优化有丰富的经验； 6. 学习能力强，适应能力好，有强烈的责任心，具备耐心/细心的品质；

Recruitment experience feedback number：0571-8159590
Alibaba Group
Human Resources Department

## 投递岗位详情
![cac3e187-4000-491f-b81a-e7e8d9356e8a.jpg](./cac3e187-4000-491f-b81a-e7e8d9356e8a.jpg)

## 岗位要求
1. 本科及以上学历，计算机软件或相关专业；
2. 3年及以上使用JAVA开发的经验，JAVA基础扎实，理解io、多线程、集合等基础框架，对JVM原理有一定的了解，对Spring,ibatis,struts等开源框架熟悉；
3. 熟悉分布式系统的设计和应用，熟悉分布式、缓存、消息等机制；能对分布式常用技术进行合理应用，解决问题；
4. 掌握多线程及高性能的设计与编码及性能调优；有高并发应用开发经验；
5. 掌握Linux 操作系统和大型数据库（Oracle、MySql）；对sql优化有丰富的经验；
6. 学习能力强，适应能力好，有强烈的责任心，具备耐心/细心的品质；

## 岗位要求详解
1. 本科及以上学历，计算机软件或相关专业；
2. 3年及以上使用JAVA开发的经验
3. JAVA基础扎实
4. 多线程
5. 集合
6. 开源框架
	- spring
	- ibatis
	- hibernate
	- strtus
7. 熟悉分布式系统的设计和应用
8. 熟悉分布式
9. 缓存
10. 消息等机制
11. 能对分布式常用技术进行合理应用，解决问题
12. 掌握多线程
13. 高性能的设计
14. 编码及性能调优
15. 有高并发应用开发经验
16. 掌握Linux 操作系统
17. 大型数据库（Oracle、MySql）
18. 对sql优化有丰富的经验
19. 学习能力强，适应能力好，有强烈的责任心，具备耐心/细心的品质；

## 面试准备
1. 自我介绍
2. Java基础相关内容
	- 计算机网络基础
		1. TCP/UDP区别以及TCP如何保证传输可靠性
			- TCP
				- TCP（Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“对话”才能建立起来，其中的过程非常复杂，我们这里只做简单、形象的介绍，你只要做到能够理解这个过程即可。我们来看看这三次对话的简单过程：主机A向主机B发出连接请求数据包：“我想给你发数据，可以吗？”，这是第一次对话；主机B向主机A发送同意连接和要求同步（同步就是两台主机一个在发送，一个在接收，协调工作）的数据包：“可以，你什么时候发？”，这是第二次对话；主机A再发出一个数据包确认主机B的要求同步：“我现在就发，你接着吧！”，这是第三次对话。三次“对话”的目的是使数据包的发送和接收同步，经过三次“对话”之后，主机A才向主机B正式发送数据。
			- UDP
				- UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境。大家可以看到，发送的数据包数量是4包，收到的也是4包（因为对方主机收到后会发回一个确认收到的数据包）。这充分说明了UDP协议是面向非连接的协议，没有建立连接的过程。正因为UDP协议没有连接的过程，所以它的通信效果高；但也正因为如此，它的可靠性不如TCP协议高。QQ就使用UDP发消息，因此有时会出现收不到消息的情况。
			- TCP协议和UDP协议的差别
				- tcp协议和udp协议的差别
					 ![2017-10-14 19-42-10屏幕截图.png](./2017-10-14 19-42-10屏幕截图.png)
			- TCP的可靠性如何保证
				- 在TCP的连接中，数据流必须以正确的顺序送达对方。TCP的可靠性是通过顺序编号和确认（ACK）来实现的。TCP在开始传送一个段时，为准备重传而首先将该段插入到发送队列之中，同时启动时钟。其后，如果收到了接受端对该段的ACK信息，就将该段从队列中删去。如果在时钟规定的时间内，ACK未返回，那么就从发送队列中再次送出这个段。TCP在协议中就对数据可靠传输做了保障，握手与断开都需要通讯双方确认，数据传输也需要双方确认成功，在协议中还规定了：分包、重组、重传等规则；而UDP主要是面向不可靠连接的，不能保证数据正确到达目的地。
			- TCP三次握手 四次挥手
				 ![cac3e187-4000-491f-b81a-e7e8d9356e8a.jpg](/home/discardpast/桌面/20150414204215804)
				 ![cac3e187-4000-491f-b81a-e7e8d9356e8a.jpg](/home/discardpast/桌面/20170610143353555)
		2. 常见的路由选择协议，以及它们的区别
			- 常见的路由选择协议有：RIP协议、OSPF协议。
			- RIP协议：底层是贝尔曼福特算法，它选择路由的度量标准（metric)是跳数，最大跳数是15跳，如果大于15跳，它就会丢弃数据包。
			- OSPF协议：底层是迪杰斯特拉算法，是链路状态路由选择协议，它选择路由的度量标准是带宽，延迟。
		3. OSI七层模型与TCP/IP五层模型
			- OSI七层模型
			 ![2017-10-14 19-46-30屏幕截图.png](./2017-10-14 19-46-30屏幕截图.png)
            - TCP/IP五层模型的协议
			 ![2017-10-14 19-47-03屏幕截图.png](./2017-10-14 19-47-03屏幕截图.png)
            - TCP/IP中，每一层对应的协议
            	- 网络层：IP协议、ICMP协议、ARP协议、RARP协议。
				- 传输层：UDP协议、TCP协议。
				- 应用层：FTP（文件传送协议）、Telenet（远程登录协议）、DNS（域名解析协议）、SMTP（邮件传送协议），POP3协议（邮局协议），HTTP协议。
			- 注意
				- 在OSI模型中ARP协议属于链路层；而在TCP/IP模型中，ARP协议属于网络层。
			- 除了层的数量之外，开放式系统互联（OSI）模型与TCP/IP协议有什么区别？
				- 开放式 系统互联模型是一个参考标准，解释协议相互之间应该如何相互作用。TCP/IP协议是美国国防部发明的，是让互联网成为了目前这个样子的标准之一。 开放式系统互联模型中没有清楚地描绘TCP/IP协议，但是在解释TCP/IP协议时很容易想到开放式系统互联模型。
			- 两者的主要区别如下
				- TCP/IP协议中的应用层处理开放式系统互联模型中的第五层、第六层和第七层的功能
				- TCP/IP协议中的传输层并不能总是保证在传 输层可靠地传输数据包，而开放式系统互联模型可以做到。
				- TCP/IP协议中的传输层并不能总是保证在传 输层可靠地传输数据包，而开放式系统互联模型可以做到。TCP/IP协议还提供一项名为UDP（用户数据报协议）的选择。UDP不能保证可靠的数据包传输。
		4. OSI七层模型详解及各层的硬件设备
			- 应用层
				- 很简单，就是应用程序。这一层负责确定通信对象，并确保由足够的资源用于通信，这些当然都是想要通信的应用程序干的事情。为操作系统或网络应用程序提供访问网络服务的接口。
				- 应用层协议的代表包括：Telnet、FTP、HTTP、SNMP等。
			- 表示层
				- 责数据的编码、转化，确保应用层的正常工作。这一层，是将我们看到的界面与二进制间互相转化的地方，就是我们的语言与机器语言间的转化。数据的压缩、解压，加密、解密都发生在这一层。这一层根据不同的应用目的将数据处理为不同的格式，表现出来就是我们看到的各种各样的文件扩展名。
			- 会话层
				- 负责建立、维护、控制会话，区分不同的会话，以及提供单工(Simplex)、半双工(Half duplex)、全双工(Full duplex)三种通信模式的服务。我们平时所知的NFS，RPC,X Windows等都工作在这一层。管理主机之间的会话进程，即负责建立、管理、终止进程之间的会话。会话层还利用在数据中插入校验点来实现数据的同步。
			- 传输层
				- 负责建立、维护、控制会话，区分不同的会话，以及提供单工(Simplex)、半双工(Half duplex)、全双工(Full duplex)三种通信模式的服务。我们平时所知的NFS，RPC,X Windows等都工作在这一层。管理主机之间的会话进程，即负责建立、管理、终止进程之间的会话。会话层还利用在数据中插入校验点来实现数据的同步。
				- 在这一层，数据的单位称为数据段（segment）。
				- 传输层协议的代表包括：TCP、UDP、SPX等
			- 网络层
				- 负责管理网络地址，定位设备，决定路由。我们所熟知的IP地址和路由器就是工作在这一层。上层的数据段在这一层被分割，封装后叫做包(Packet)，包有两种，一种叫做用户数据包(Data packets)，是上层传下来的用户数据；另一种叫路由更新包(Route update packets)，是直接由路由器发出来的，用来和其他路由器进行路由信息的交换。负责对子网间的数据包进行路由选择。网络层还可以实现拥塞控制、网际互连等功能。
				- 在这一层，数据的单位称为数据包（packet）。
				- 网络层协议的代表包括：IP、IPX、RIP、OSPF等
			- 数据链路层
				- 负责准备物理传输，CRC校验，错误通知，网络拓扑，流控等。我们所熟知的MAC地址和交换机都工作在这一层。上层传下来的包在这一层被分割封装后叫做帧(Frame)。在不可靠的物理介质上提供可靠的传输。该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。
				- 在这一层，数据的单位称为帧（frame）。
				- 数据链路层协议的代表包括：SDLC、HDLC、PPP、STP、帧中继等
			- 物理层
				- 就是实实在在的物理链路，负责将数据以比特流的方式发送、接收，就不多说了。
			- 各层的设备
				- 物理层
					- 中继器（Repeater，也叫放大器），集线器，网线。
				- 数据链路层
					- 网桥，交换机。
				- 网络层
					- 路由器。
				- 网关
					- 网络层以上的设备。
		5. IP地址的分类（尤其注意特殊I传输层协议的代表包括：TCP、UDP、SPX等P）
			1. A类
     			- 十进制中第一位在1~126之间
    			- 十进制中第一个数代表不同的网络
     			- 所以最大网络数为126(2^7-2)个
                 - 1.0.0.0代表网络本身,不能分配
                 - 1.255.255.255代表当前网络的广播地址,不能分配
                 - 所以最大主机数为2^24-2个
                 - 使用路由器跨网络通信
                 - 使用交换机同网络通信
                 - 广播地址是专门用于同时向网络中所有工作站进行发送的一个地址
                 - 私有IP不能直接访问公网IP,这样节约了有限的公网IP地址
			2. 127.0.0.0 代表当前计算机本身
			3. B类
                 - 十进制中第一位在128~191之间
                 - 十进制中的前两个数代表不同的网络
                 - 所以最大网络数为16384(2^14)
                 - 128.0.0.0代表网络本身,不能分配
                 - 191.255.255.255代表当前网络的广播地址,不能分配
                 - 所以最大主机数为2^16-2个
			4. C类
                 - 十进制中第一位在192~223之间
                 - 十进制中的前三个数代表不同网络
                 - 所以最大网络数为2^21个
                 - 192.0.0.0代表网络本身,不能分配
                 - 223.255.255.255代表当前网络的广播地址,不能分配
                 - 所以最大主机数为2^8-2个
		6. ARP协议的工作原理
			-  首先，每台主机都会在自己的ARP缓冲区中建立一个 ARP列表，以表示IP地址和MAC地址的对应关系。当源主机需要将一个数据包要发送到目的主机时，会首先检查自己 ARP列表中是否存在该 IP地址对应的MAC地址，如果有，就直接将数据包发送到这个MAC地址；如果没有，就向本地网段发起一个ARP请求的广播包，查询此目的主机对应的MAC地址。此ARP请求数据包里包括源主机的IP地址、硬件地址、以及目的主机的IP地址。网络中所有的主机收到这个ARP请求后，会检查数据包中的目的IP是否和自己的IP地址一致。如果不相同就忽略此数据包；如果相同，该主机首先将发送端的MAC地址和IP地址添加到自己的ARP列表中，如果ARP表中已经存在该IP的信息，则将其覆盖，然后给源主机发送一个 ARP响应数据包，告诉对方自己是它需要查找的MAC地址；源主机收到这个ARP响应数据包后，将得到的目的主机的IP地址和MAC地址添加到自己的ARP列表中，并利用此信息开始数据的传输。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。
		7. 在浏览器中输入网址后执行的全部过程
			1. 查找域名对应的IP地址。这一步会依次查找浏览器缓存，系统缓存，路由器缓存，ISPNDS缓存，根域名服务器。
            2. 向IP对应的服务器发送请求。
            3. 服务器响应请求，发回网页内容。
            4. 浏览器解析网页内容。
            5. 由于网页可能有重定向，或者嵌入了图片，AJAX，其它子网页等等，这4个步骤可能反复进行多次才能将最终页面展示给用户。
		8. TCP对应的协议和UDP对应的协议
			- TCP对应的协议
				1. FTP
					- 定义了文件传输协议，使用21端口。常说某某计算机开了FTP服务便是启动了文件传输服务。下载文件，上传主页，都要用到FTP服务。 
				2. Telnet
					- 它是一种用于远程登陆的端口，用户可以以自己的身份远程连接到计算机上，通过这种端口可以提供一种基于DOS模式下的通信服务。如以前的BBS是-纯字符界面的，支持BBS的服务器将23端口打开，对外提供服务。
				3. SMTP
					- 定义了简单邮件传送协议，现在很多邮件服务器都用的是这个协议，用于发送邮件。如常见的免费邮件服务中用的就是这个邮件服务端口，所以在电子邮件设置-中常看到有这么SMTP端口设置这个栏，服务器开放的是25号端口。
				4. POP3
					- 它是和SMTP对应，POP3用于接收邮件。通常情况下，POP3协议所用的是110端口。也是说，只要你有相应的使用POP3协议的程序（例如Fo-xmail或Outlook），就可以不以Web方式登陆进邮箱界面，直接用邮件程序就可以收到邮件（如是163邮箱就没有必要先进入网易网站，再进入自己的邮-箱来收信）。
				5. HTTP
					- 是从Web服务器传输超文本到本地浏览器的传送协议。
			- UDP对应的协议
				1. DNS
					- 用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。
				2. SNMP
					- 简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。
				3. TFTP
					- 简单文件传输协议，该协议在熟知端口69上使用UDP服务。
		9. 强调下上文的特殊IP地址
			1. 网络地址
				-  IP地址由网络号（包括子网号）和主机号组成，网络地址的主机号为全0，网络地址代表着整个网络。
			2. 广播地址
				- 广播地址通常称为直接广播地址，是为了区分受限广播地址。
				- 广播地址与网络地址的主机号正好相反，广播地址中，主机号为全1。当向某个网络的广播地址发送消息时，该网络内的所有主机都能收到该广播消息。
			3. 组播地址
				- D类地址就是组播地址。
				- 先回忆下A，B，C，D类地址吧
					- A类地址以00开头，第一个字节作为网络号，地址范围为：0.0.0.0~127.255.255.255；
					- B类地址以10开头，前两个字节作为网络号，地址范围是：128.0.0.0~191.255.255.255;
					- C类地址以110开头，前三个字节作为网络号，地址范围是：192.0.0.0~223.255.255.255。
					- D类地址以1110开头，地址范围是224.0.0.0~239.255.255.255，D类地址作为组播地址（一对多的通信）；
					- E类地址以1111开头，地址范围是240.0.0.0~255.255.255.255，E类地址为保留地址，供以后使用。
					- Notice：只有A,B,C有网络号和主机号之分，D类地址和E类地址没有划分网络号和主机号。
			4. 255.255.255.255
				-  该IP地址指的是受限的广播地址。受限广播地址与一般广播地址（直接广播地址）的区别在于，受限广播地址之只能用于本地网络，路由器不会转发以受限广播地址为目的地址的分组；一般广播地址既可在本地广播，也可跨网段广播。例如：主机192.168.1.1/30上的直接广播数据包后，另外一个网段192.168.1.5/30也能收到该数据报；若发送受限广播数据报，则不能收到。
				- Notice：一般的广播地址（直接广播地址）能够通过某些路由器（当然不是所有的路由器），而受限的广播地址不能通过路由器。
			5. 0.0.0.0
				- 常用于寻找自己的IP地址，例如在我们的RARP，BOOTP和DHCP协议中，若某个未知IP地址的无盘机想要知道自己的IP地址，它就以255.255.255.255为目的地址，向本地范围（具体而言是被各个路由器屏蔽的范围内）的服务器发送IP请求分组。
			6. 回环地址
				- 127.0.0.0/8被用作回环地址，回环地址表示本机的地址，常用于对本机的测试，用的最多的是127.0.0.1。
			7. A、B、C类私有地址
				- 私有地址(private address)也叫专用地址，它们不会在全球使用，只具有本地意义。
				- A类私有地址：10.0.0.0/8，范围是：10.0.0.0~10.255.255.255
				- B类私有地址：172.16.0.0/12，范围是：172.16.0.0~172.31.255.255
				- C类私有地址：192.168.0.0/16，范围是：192.168.0.0~192.168.255.255
		10. NAT协议、DHCP协议、DNS协议的作用
			- NAT协议
				- 网络地址转换(NAT,Network AddressTranslation)属接入广域网(WAN)技术，
				- 是一种将私有（保留）地址转化为合法IP地址的转换技术，它被广泛应用于各种类型Internet接入方式和各种类型的网络中。原因很简单，NAT不仅完美地解决了lP地址不足的问题，而且还能够有效地避免来自网络外部的攻击，隐藏并保护网络内部的计算机。
				- 借助于NAT，私有（保留）地址的"内部"网络通过路由器发送数据包时，私有地址被转换成合法的IP地址，一个局域网只需使用少量IP地址（甚至是1个）即可实现私有地址网络内所有计算机与Internet的通信需求。
			- DHCP协议
				- ：动态主机设置协议（Dynamic Host ConfigurationProtocol, DHCP）
				- 是一个局域网的网络协议，使用UDP协议工作，主要有两个用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。
			- DNS协议
				- DNS 是域名系统 (Domain Name System) 的缩写，是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。
		11. 子网掩码的作用
			- 子网掩码只有一个作用，就是将某个IP地址划分成网络地址和主机地址两部分。
			- 用于子网掩码的位数决定于可能的子网数目和每个子网的主机数目。
			- 计算方法示例
			![2017-10-14 20-19-24屏幕截图.png](./2017-10-14 20-19-24屏幕截图.png)
	- 数据结构
	- 算法
	- java语言基础
		1. 面向对象的特征有哪些方面?
			1. 抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。
			2. 继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段（如果不能理解请阅读阎宏博士的《Java与模式》或《设计模式精解》中关于桥梁模式的部分）。
			3. 封装：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口（可以想想普通洗衣机和全自动洗衣机的差别，明显全自动洗衣机封装更好因此操作起来更简单；我们现在使用的智能手机也是封装得足够好的，因为几个按键就搞定了所有的事情）。
			4. 多态性：多态性是指允许不同子类型的对象对同一消息作出不同的响应。简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。多态性分为编译时的多态性和运行时的多态性。如果将对象的方法视为对象向外界提供的服务，那么运行时的多态性可以解释为：当A系统访问B系统提供的服务时，B系统有多种提供服务的方式，但一切对A系统来说都是透明的（就像电动剃须刀是A系统，它的供电系统是B系统，B系统可以使用电池供电或者用交流电，甚至还有可能是太阳能，A系统只会通过B类对象调用供电的方法，但并不知道供电系统的底层实现是什么，究竟通过何种方式获得了动力）。方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：
				1. 方法重写（子类继承父类并重写父类中已有的或抽象的方法）；
				2. 对象造型（用父类型引用引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。
		2. 访问修饰符public,private,protected,以及不写（默认）时的区别？
			![2017-10-15 16-08-02屏幕截图.png](./2017-10-15 16-08-02屏幕截图.png)
			- 类的成员不写访问修饰时默认为default。默认对于同一个包中的其他类相当于公开（public），对于不是同一个包中的其他类相当于私有（private）。受保护（protected）对子类相当于公开，对不是同一包中的没有父子关系的类相当于私有。
		3. String 是最基本的数据类型吗?
			- 不是。Java中的基本数据类型只有8个：byte、short、int、long、float、double、char、boolean；除了基本类型（primitive type）和枚举类型（enumeration type），剩下的都是引用类型（reference type）。
		4. float f=3.4;是否正确?
			- 不正确。3.4是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换float f =(float)3.4; 或者写成float f =3.4F;。
		5. short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗?
			- 对于short s1 = 1; s1 = s1 + 1;由于1是int类型，因此s1+1运算结果也是int 型，需要强制转换类型才能赋值给short型。而short s1 = 1; s1 += 1;可以正确编译，因为s1+= 1;相当于s1 = (short)(s1 + 1);其中有隐含的强制类型转换。
		6. Java 有没有goto?
			- goto 是Java中的保留字，在目前版本的Java中没有使用。（根据James Gosling（Java之父）编写的《The Java Programming Language》一书的附录中给出了一个Java关键字列表，其中有goto和const，但是这两个是目前无法使用的关键字，因此有些地方将其称之为保留字，其实保留字这个词应该有更广泛的意义，因为熟悉C语言的程序员都知道，在系统类库中使用过的有特殊意义的单词或单词的组合都被视为保留字）
		7. int 和Integer 有什么区别?
			- Java是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入不是对象的基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java为每一个基本数据类型都引入了对应的包装类型（wrapper class），int的包装类就是Integer，从JDK 1.5开始引入了自动装箱/拆箱机制，使得二者可以相互转换。
			- Java 为每个原始类型提供了包装类型：
				- 原始类型: boolean，char，byte，short，int，long，float，double
				- 包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double
		8. &和&&的区别？
			- &运算符有两种用法：(1)按位与；(2)逻辑与。&&运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true整个表达式的值才是true。&&之所以称为短路运算是因为，如果&&左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算。很多时候我们可能都需要用&&而不是&，例如在验证用户登录时判定用户名不是null而且不是空字符串，应当写为：username != null &&!username.equals(“”)，二者的顺序不能交换，更不能用&运算符，因为第一个条件如果不成立，根本不能进行字符串的equals比较，否则会产生NullPointerException异常。注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。
		9. 解释内存中的栈（stack）、堆(heap)和静态存储区的用法。
			- 通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用内存中的栈空间；而通过new关键字和构造器创建的对象放在堆空间；程序中的字面量（literal）如直接书写的100、“hello”和常量都是放在静态存储区中。栈空间操作最快但是也很小，通常大量的对象都是放在堆空间，整个内存包括硬盘上的虚拟内存都可以被当成堆空间来使用。
			- String str = new String(“hello”);
			- 上面的语句中str放在栈上，用new创建出来的字符串对象放在堆上，而“hello”这个字面量放在静态存储区。
			- 补充：较新版本的Java中使用了一项叫“逃逸分析“的技术，可以将一些局部对象放在栈上以提升对象的操作性能。
		10. Math.round(11.5) 等于多少? Math.round(-11.5)等于多少?
			- Math.round(11.5)的返回值是12，Math.round(-11.5)的返回值是-11。四舍五入的原理是在参数上加0.5然后进行下取整。
		11. swtich 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上?
			- 早期的JDK中，switch（expr）中，expr可以是byte、short、char、int。从1.5版开始，Java中引入了枚举类型（enum），expr也可以是枚举，从JDK 1.7版开始，还可以是字符串（String）。长整型（long）是不可以的。
		12. 用最有效率的方法计算2乘以8?
			- 2 << 3（左移3位相当于乘以2的3次方，右移3位相当于除以2的3次方）。
			- 补充：我们为编写的类重写hashCode方法时，可能会看到如下所示的代码，其实我们不太理解为什么要使用这样的乘法运算来产生哈希码（散列码），而且为什么这个数是个素数，为什么通常选择31这个数？前两个问题的答案你可以自己百度一下，选择31是因为可以用移位和减法运算来代替乘法，从而得到更好的性能。说到这里你可能已经想到了：31 * num <==> (num << 5) - num，左移5位相当于乘以2的5次方（32）再减去自身就相当于乘以31。现在的VM都能自动完成这个优化。
		13. 数组有没有length()方法?String 有没有length()方法？
			- 数组没有length()方法，有length 的属性。String 有length()方法。JavaScript中，获得字符串的长度是通过length属性得到的，这一点容易和Java混淆。
		14. 在Java 中，如何跳出当前的多重嵌套循环？
			- 在最外层循环前加一个标记如A，然后用break A;可以跳出多重循环。（Java中支持带标签的break和continue语句，作用有点类似于C和C++中的goto语句，但是就像要避免使用goto一样，应该避免使用带标签的break和continue，因为它不会让你的程序变得更优雅，很多时候甚至有相反的作用，所以这种语法其实不知道更好）
		15. 造器（constructor）是否可被重写（override）?
			- 构造器不能被继承，因此不能被重写，但可以被重载。
		16. 两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对？
			- 对，如果两个对象x和y满足x.equals(y) == true，它们的哈希码（hash code）应当相同。Java对于eqauls方法和hashCode方法是这样规定的：(1)如果两个对象相同（equals方法返回true），那么它们的hashCode值一定要相同；(2)如果两个对象的hashCode相同，它们并不一定相同。当然，你未必要按照要求去做，但是如果你违背了上述原则就会发现在使用容器时，相同的对象可以出现在Set集合中，同时增加新元素的效率会大大下降（对于使用哈希存储的系统，如果哈希码频繁的冲突将会造成存取性能急剧下降）。
			- 补充：关于equals和hashCode方法，很多Java程序都知道，但很多人也就是仅仅知道而已，在Joshua Bloch的大作《Effective Java》（很多软件公司，《Effective Java》、《Java编程思想》以及《重构：改善既有代码质量》是Java程序员必看书籍，如果你还没看过，那就赶紧去亚马逊买一本吧）中是这样介绍equals方法的：首先equals方法必须满足自反性（x.equals(x)必须返回true）、对称性（x.equals(y)返回true时，y.equals(x)也必须返回true）、传递性（x.equals(y)和y.equals(z)都返回true时，x.equals(z)也必须返回true）和一致性（当x和y引用的对象信息没有被修改时，多次调用x.equals(y)应该得到同样的返回值），而且对于任何非null值的引用x，x.equals(null)必须返回false。实现高质量的equals方法的诀窍包括：1. 使用==操作符检查“参数是否为这个对象的引用”；2. 使用instanceof操作符检查“参数是否为正确的类型”；3. 对于类中的关键属性，检查参数传入对象的属性是否与之相匹配；4. 编写完equals方法后，问自己它是否满足对称性、传递性、一致性；5. 重写equals时总是要重写hashCode；6. 不要将equals方法参数中的Object对象替换为其他的类型，在重写时不要忘掉@Override注解。
		17. 是否可以继承String 类?
			- String 类是final类，不可以被继承。
			- 补充：继承String本身就是一个错误的行为，对String类型最好的重用方式是关联（HAS-A）而不是继承（IS-A）。
		18. 当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递?
			- 是值传递。Java 编程语言只有值传递参数。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用过程中被改变，但对象的引用是永远不会改变的。C++和C#中可以通过传引用或传输出参数来改变传入的参数的值。
			- 补充：Java中没有传引用实在是非常的不方便，这一点在Java 8中仍然没有得到改进，正是如此在Java编写的代码中才会出现大量的Wrapper类（将需要通过方法调用修改的引用置于一个Wrapper类中，再将Wrapper对象传入方法），这样的做法只会让代码变得臃肿，尤其是让从C和C++转型为Java程序员的开发者无法容忍。
		19. String 和StringBuilder、StringBuffer 的区别?
			- Java 平台提供了两种类型的字符串：String和StringBuffer / StringBuilder，它们可以储存和操作字符串。其中String是只读字符串，也就意味着String引用的字符串内容是不能被改变的。而StringBuffer和StringBuilder类表示的字符串对象可以直接进行修改。StringBuilder是JDK 1.5中引入的，它和StringBuffer的方法完全相同，区别在于它是在单线程环境下使用的，因为它的所有方面都没有被synchronized修饰，因此它的效率也比StringBuffer略高。
			- 补充1：有一个面试题问：有没有哪种情况用+做字符串连接比调用StringBuffer / StringBuilder对象的append方法性能更好？如果连接后得到的字符串在静态存储区中是早已存在的，那么用+做字符串连接是优于StringBuffer / StringBuilder的append方法的。
		20. 重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分?
			- 方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求。
		21. 描述一下JVM 加载class文件的原理机制?
			- JVM 中类的装载是由类加载器（ClassLoader） 和它的子类来实现的，Java中的类加载器是一个重要的Java 运行时系统组件，它负责在运行时查找和装入类文件中的类。
			- 补充：
				1. 由于Java的跨平台性，经过编译的Java源程序并不是一个可执行程序，而是一个或多个类文件。当Java程序需要使用某个类时，JVM会确保这个类已经被加载、连接(验证、准备和解析)和初始化。类的加载是指把类的.class文件中的数据读入到内存中，通常是创建一个字节数组读入.class文件，然后产生与所加载类对应的Class对象。加载完成后，Class对象还不完整，所以此时的类还不可用。当类被加载后就进入连接阶段，这一阶段包括验证、准备(为静态变量分配内存并设置默认的初始值)和解析(将符号引用替换为直接引用)三个步骤。最后JVM对类进行初始化，包括：1如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；2如果类中存在初始化语句，就依次执行这些初始化语句。
				2. 类的加载是由类加载器完成的，类加载器包括：根加载器（BootStrap）、扩展加载器（Extension）、系统加载器（System）和用户自定义类加载器（java.lang.ClassLoader的子类）。从JDK 1.2开始，类加载过程采取了父亲委托机制(PDM)。PDM更好的保证了Java平台的安全性，在该机制中，JVM自带的Bootstrap是根加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。JVM不会向Java程序提供对Bootstrap的引用。下面是关于几个类加载器的说明：
					1. Bootstrap：一般用本地代码实现，负责加载JVM基础核心类库（rt.jar）；
					2. Extension：从java.ext.dirs系统属性所指定的目录中加载类库，它的父加载器是Bootstrap；
					3. System：又叫应用类加载器，其父类是Extension。它是应用最广泛的类加载器。它从环境变量classpath或者系统属性java.class.path所指定的目录中记载类，是用户自定义加载器的默认父加载器。
		22. char 型变量中能不能存贮一个中文汉字?为什么?
			- char类型可以存储一个中文汉字，因为Java中使用的编码是Unicode（不选择任何特定的编码，直接使用字符在字符集中的编号，这是统一的唯一方法），一个char类型占2个字节（16bit），所以放一个中文是没问题的。
			- 补充：使用Unicode意味着字符在JVM内部和外部有不同的表现形式，在JVM内部都是Unicode，当这个字符被从JVM内部转移到外部时（例如存入文件系统中），需要进行编码转换。所以Java中有字节流和字符流，以及在字符流和字节流之间进行转换的转换流，如InputStreamReader和OutputStreamReader，这两个类是字节流和字符流之间的适配器类，承担了编码转换的任务；对于C程序员来说，要完成这样的编码转换恐怕要依赖于union（联合体/共用体）共享内存的特征来实现了。
		23. 抽象类（abstract class）和接口（interface）有什么异同?
			- 抽象类和接口都不能够实例化，但可以定义抽象类和接口类型的引用。一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要被声明为抽象类。接口比抽象类更加抽象，因为抽象类中可以定义构造器，可以有抽象方法和具体方法，而接口中不能定义构造器而且其中的方法全部都是抽象方法。抽象类中的成员可以是private、默认、protected、public的，而接口中的成员全都是public的。抽象类中可以定义成员变量，而接口中定义的成员变量实际上都是常量。有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法。
		24. 静态嵌套类(Static Nested Class)和内部类（Inner Class）的不同？
			- Static Nested Class是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。而通常的内部类需要在外部类实例化后才能实例化，其语法看起来挺诡异的，
		25. Java 中会存在内存泄漏吗，请简单描述。
			- 理论上Java因为有垃圾回收机制（GC）不会存在内存泄露问题（这也是Java被广泛使用于服务器端编程的一个重要原因）；然而在实际开发中，可能会存在无用但可达的对象，这些对象不能被GC回收也会发生内存泄露。一个例子就是Hibernate的Session（一级缓存）中的对象属于持久态，垃圾回收器是不会回收这些对象的，然而这些对象中可能存在无用的垃圾对象。
		26. 抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被synchronized修饰?
			- 都不能。抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的。本地方法是由本地代码（如C代码）实现的方法，而抽象方法是没有实现的，也是矛盾的。synchronized和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的。
		27. 静态变量和实例变量的区别？
			- 静态变量是被static修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷贝；实例变量必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。静态变量可以实现让多个对象共享内存。在Java开发中，上下文类和工具类中通常会有大量的静态成员。
		28. 是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？
			- 不可以，静态方法只能访问静态成员，因为非静态方法的调用要先创建对象，因此在调用静态方法时可能对象并没有被初始化。
		29. 如何实现对象克隆？
			- 有两种方式：
				1. 实现Cloneable接口并重写Object类中的clone()方法；
				2. 实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆
				3. 注意：基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛型限定，可以检查出要克隆的对象是否支持序列化，这项检查是编译器完成的，不是在运行时抛出异常，这种是方案明显优于使用Object类的clone方法克隆对象。
		30. GC 是什么？为什么要有GC？
			- GC是垃圾收集的意思，内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。Java程序员不用担心内存管理，因为垃圾收集器会自动进行管理。要请求垃圾收集，可以调用下面的方法之一：System.gc() 或Runtime.getRuntime().gc() ，但JVM可以屏蔽掉显示的垃圾回收调用。
			- 垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低优先级的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。在Java诞生初期，垃圾回收是Java最大的亮点之一，因为服务器端的编程需要有效的防止内存泄露问题，然而时过境迁，如今Java的垃圾回收机制已经成为被诟病的东西。移动智能终端用户通常觉得iOS的系统比Android系统有更好的用户体验，其中一个深层次的原因就在于Android系统中垃圾回收的不可预知性。
			- 补充：垃圾回收机制有很多种，包括：分代复制垃圾回收、标记垃圾回收、增量垃圾回收等方式。标准的Java进程既有栈又有堆。栈保存了原始型局部变量，堆保存了要创建的对象。Java平台对堆内存回收和再利用的基本算法被称为标记和清除，但是Java对其进行了改进，采用“分代式垃圾收集”。这种方法会跟Java对象的生命周期将堆内存划分为不同的区域，在垃圾收集过程中，可能会将对象移动到不同区域：
			- 伊甸园（Eden）：这是对象最初诞生的区域，并且对大多数对象来说，这里是它们唯一存在过的区域。
			- 幸存者乐园（Survivor）：从伊甸园幸存下来的对象会被挪到这里。
			- 终身颐养园（Tenured）：这是足够老的幸存对象的归宿。年轻代收集（Minor-GC）过程是不会触及这个地方的。当年轻代收集不能把对象放进终身颐养园时，就会触发一次完全收集（Major-GC），这里可能还会牵扯到压缩，以便为大对象腾出足够的空间。
			- 与垃圾回收相关的JVM参数：
				- -Xms / -Xmx --- 堆的初始大小 / 堆的最大大小
				- -Xmn --- 堆中年轻代的大小
				- -XX:-DisableExplicitGC --- 让System.gc()不产生任何作用
				- -XX:+PrintGCDetail --- 打印GC的细节
				- -XX:+PrintGCDateStamps --- 打印GC操作的时间戳
		31. String s=new String(“xyz”);创建了几个字符串对象？
			- 两个对象，一个是静态存储区的"xyz",一个是用new创建在堆上的对象。
		32. 接口是否可继承（extends）接口? 抽象类是否可实现（implements）接口? 抽象类是否可继承具体类（concrete class）?
			- 接口可以继承接口。抽象类可以实现(implements)接口，抽象类可继承具体类，但前提是具体类必须有明确的构造函数。
		33. 一个“.java”源文件中是否可以包含多个类（不是内部类）？有什么限制？
			- 可以，但一个源文件中最多只能有一个公开类（public class）而且文件名必须和公开类的类名完全保持一致。
		34. Anonymous Inner Class(匿名内部类)是否可以继承其它类？是否可以实现接口？
			- 可以继承其他类或实现其他接口，在Swing编程中常用此方式来实现事件监听和回调。
		35. 内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？
			- 一个内部类对象可以访问创建它的外部类对象的成员，包括私有成员。
		36. Java 中的final关键字有哪些用法？
			- (1)修饰类：表示该类不能被继承；(2)修饰方法：表示方法不能被重写；(3)修饰变量：表示变量只能一次赋值以后值不能被修改（常量）。
		37. 数据类型之间的转换
			1. 如何将字符串转换为基本数据类型？
				- 调用基本数据类型对应的包装类中的方法parseXXX(String)或valueOf(String)即可返回相应基本类型；
			2. 如何将基本数据类型转换为字符串？
				- 一种方法是将基本数据类型与空字符串（””）连接（+）即可获得其所对应的字符串；另一种方法是调用String 类中的valueOf(…)方法返回相应字符串
		38. 何实现字符串的反转及替换？
			- 方法很多，可以自己写实现也可以使用String或StringBuffer / StringBuilder中的方法。有一道很常见的面试题是用递归实现字符串反转
		39. 怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？
			- String s1 = "你好";
			- String s2 = newString(s1.getBytes("GB2312"), "ISO-8859-1");
		40. 日期和时间
			1. 如何取得年月日、小时分钟秒？
				- 创建java.util.Calendar 实例，调用其get()方法传入不同的参数即可获得参数所对应的值
			2. 如何取得从1970年1月1日0时0分0秒到现在的毫秒数？
				- Calendar.getInstance().getTimeInMillis();
				- System.currentTimeMillis();
			3. 如何取得某月的最后一天？
				- Calendar time = Calendar.getInstance();
				- time.getActualMaximum(Calendar.DAY_OF_MONTH);
			4. 如何格式化日期？
				- 利用java.text.DataFormat 的子类（如SimpleDateFormat类）中的format(Date)方法可将日期格式化。
		41. 打印昨天的当前时刻。
			- Calendar cal = Calendar.getInstance();
        	- cal.add(Calendar.DATE, -1);
		42. 比较一下Java 和JavaSciprt。
			- avaScript 与Java是两个公司开发的不同的两个产品。Java 是原Sun 公司推出的面向对象的程序设计语言，特别适合于互联网应用程序开发；而JavaScript是Netscape公司的产品，为了扩展Netscape浏览器的功能而开发的一种可以嵌入Web页面中运行的基于对象和事件驱动的解释性语言，它的前身是LiveScript；而Java 的前身是Oak语言。
			- 下面对两种语言间的异同作如下比较：
				1. 基于对象和面向对象：Java是一种真正的面向对象的语言，即使是开发简单的程序，必须设计对象；JavaScript是种脚本语言，它可以用来制作与网络无关的，与用户交互作用的复杂软件。它是一种基于对象（Object-Based）和事件驱动（Event-Driven）的编程语言。因而它本身提供了非常丰富的内部对象供设计人员使用；
				2. 解释和编译：Java 的源代码在执行之前，必须经过编译；JavaScript 是一种解释性编程语言，其源代码不需经过编译，由浏览器解释执行；
				3. 强类型变量和类型弱变量：Java采用强类型变量检查，即所有变量在编译之前必须作声明；JavaScript中变量声明，采用其弱类型。即变量在使用前不需作声明，而是解释器在运行时检查其数据类型；
				4. 代码格式不一样。
				- 补充：上面列出的四点是原来所谓的标准答案中给出的。其实Java和JavaScript最重要的区别是一个是静态语言，一个是动态语言。目前的编程语言的发展趋势是函数式语言和动态语言。在Java中类（class）是一等公民，而JavaScript中函数（function）是一等公民。对于这种问题，在面试时还是用自己的语言回答会更加靠谱。
		43. 什么时候用assert？
			- assertion(断言)在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制。一般来说，assertion用于保证程序最基本、关键的正确性。assertion检查通常在开发和测试时开启。为了提高性能，在软件发布后， assertion检查通常是关闭的。在实现中，断言是一个包含布尔表达式的语句，在执行这个语句时假定该表达式为true；如果表达式计算为false，那么系统会报告一个AssertionError。
		44. Error 和Exception 有什么区别?
			- Error 表示系统级的错误和程序不必处理的异常，是恢复不是不可能但很困难的情况下的一种严重问题；比如内存溢出，不可能指望程序能处理这样的情况；Exception 表示需要捕捉或者需要程序进行处理的异常，是一种设计或实现问题；也就是说，它表示如果程序运行正常，从不会发生的情况。
			- 补充：2005年摩托罗拉的面试中曾经问过这么一个问题“If a process reports a stack overflow run-time error, what’s the most possible cause?”，给了四个选项a. lack of memory; b. write on an invalid memory space; c. recursive function calling; d. array index out of boundary. Java程序在运行时也可能会遭遇StackOverflowError，这是一个错误无法恢复，只能重新修改代码了，这个面试题的答案是c。如果写了不能迅速收敛的递归，则很有可能引发栈溢出的错误
			- 因此，用递归编写程序时一定要牢记两点：1. 递归公式；2. 收敛条件（什么时候就不再递归而是回溯了）
		45. try{}里有一个return语句，那么紧跟在这个try后的finally{}里的code会不会被执行，什么时候被执行，在return前还是后?
			- 会执行，在方法返回调用者前执行。Java允许在finally中改变返回值的做法是不好的，因为如果存在finally代码块，try中的return语句不会立马返回调用者，而是记录下返回值待finally代码块执行完毕之后再向调用者返回其值，然后如果在finally中修改了返回值，这会对程序造成很大的困扰，C#中就从语法上规定不能做这样的事。
		46. Java 语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？
			- Java 通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接口。在Java 中，每个异常都是一个对象，它是Throwable 类或其子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并进行处理。Java 的异常处理是通过5 个关键词来实现的：try、catch、throw、throws和finally。一般情况下是用try来执行一段程序，如果出现异常，系统会抛出（throw）一个异常，这时候你可以通过它的类型来捕捉（catch）它，或最后（finally）由缺省处理器来处理；try用来指定一块预防所有“异常”的程序；catch 子句紧跟在try块后面，用来指定你想要捕捉的“异常”的类型；throw 语句用来明确地抛出一个“异常”；throws用来标明一个成员函数可能抛出的各种“异常”；finally 为确保一段代码不管发生什么“异常”都被执行一段代码；可以在一个成员函数调用的外面写一个try语句，在这个成员函数内部写另一个try语句保护其他代码。每当遇到一个try 语句，“异常”的框架就放到栈上面，直到所有的try语句都完成。如果下一级的try语句没有对某种“异常”进行处理，栈就会展开，直到遇到有处理这种“异常”的try 语句。
		47. 运行时异常与受检异常有何异同？
			- 异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误，只要程序设计得没有问题通常就不会发生。受检异常跟程序运行的上下文环境有关，即使程序设计无误，仍然可能因使用的问题而引发。Java编译器要求方法必须声明抛出可能发生的受检异常，但是并不要求必须声明抛出未被捕获的运行时异常。异常和继承一样，是面向对象程序设计中经常被滥用的东西，神作《Effective Java》中对异常的使用给出了以下指导原则：
				- 不要将异常处理用于正常的控制流（设计良好的API不应该强迫它的调用者为了正常的控制流而使用异常）
				- 对可以恢复的情况使用受检异常，对编程错误使用运行时异常
				- 避免不必要的使用受检异常（可以通过一些状态检测手段来避免异常的发生）
				- 优先使用标准的异常
				- 每个方法抛出的异常都要有文档
				- 保持异常的原子性
				- 不要在catch中忽略掉捕获到的异常
		48. 列出一些你常见的运行时异常？
			- ArithmeticException（算术异常）
			- ClassCastException （类转换异常）
			- IllegalArgumentException （非法参数异常）
			- IndexOutOfBoundsException （下表越界异常）
			- NullPointerExc                              eption （空指针异常）
			- SecurityException （安全异常）
		49. final, finally, finalize 的区别?
			- final：修饰符（关键字）有三种用法：如果一个类被声明为final，意味着它不能再派生出新的子类，即不能被继承，因此它和abstract是反义词。将变量声明为final，可以保证它们在使用中不被改变，被声明为final 的变量必须在声明时给定初值，而在以后的引用中只能读取不可修改。被声明为final 的方法也同样只能使用，不能在子类中被重写。
			-  vcfinally：通常放在try…catch的后面构造总是执行代码块，这就意味着程序无论正常执行还是发生异常，这里的代码只要JVM不关闭都能执行，可以将释放外部资源的代码写在finally块中。
			- finalize：Object类中定义的方法，Java中允许使用finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在销毁对象时调用的，通过重写finalize() 方法可以整理系统资源或者执行其他清理工作。
3. 多线程
	1. 什么是线程
		- 线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。程序员可以通过它进行多处理器编程，你可以使用多线程对运算密集型任务提速。比如，如果一个线程完成一个任务要100毫秒，那么用十个线程完成改任务只需10毫秒。Java在语言层面对多线程提供了卓越的支持，它也是一个很好的卖点。
	2. 线程和进程有什么区别
		- 线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务。不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存空间。别把它和栈内存搞混，每个线程都拥有单独的栈内存用来存储本地数据
	3. 如何在Java中实现线程
		- 在语言层面有两种方式。java.lang.Thread 类的实例就是一个线程但是它需要调用java.lang.Runnable接口来执行，由于线程类本身就是调用的Runnable接口所以你可以继承java.lang.Thread 类或者直接调用Runnable接口来重写run()方法实现线程
	4. 用Runnable还是Thread
		- 这个问题是上题的后续，大家都知道我们可以通过继承Thread类或者调用Runnable接口来实现线程，问题是，那个方法更好呢？什么情况下使用它？这个问题很容易回答，如果你知道Java不支持类的多重继承，但允许你调用多个接口。所以如果你要继承其他类，当然是调用Runnable接口好了。
	5. Thread类中的start()和run()方法有什么区别
		- 这个问题经常被问到，但还是能从此区分出面试者对Java线程模型的理解程度。start()方法被用来启动新创建的线程，而且start()内部调用了run()方法，这和直接调用run()方法的效果不一样。当你调用run()方法的时候，只会是在原来的线程中调用，没有新的线程启动，start()方法才会启动新线程
	6. Java中Runnable和Callable有什么不同
		- Runnable和Callable都代表那些要在不同的线程中执行的任务。Runnable从JDK1.0开始就有了，Callable是在JDK1.5增加的。它们的主要区别是Callable的 call() 方法可以返回值和抛出异常，而Runnable的run()方法没有这些功能。
	7. Java中CyclicBarrier 和 CountDownLatch有什么不同
		- CyclicBarrier 和 CountDownLatch 都可以用来让一组线程等待其它线程。与 CyclicBarrier 不同的是，CountdownLatch 不能重新使用。
	8. Java内存模型是什么
		- Java内存模型规定和指引Java程序在不同的内存架构、CPU和操作系统间有确定性地行为。它在多线程的情况下尤其重要。Java内存模型对一个线程所做的变动能被其它线程可见提供了保证，它们之间是先行发生关系。这个关系定义了一些规则让程序员在并发编程时思路更清晰。比如，先行发生关系确保了：
            - 线程内的代码能够按先后顺序执行，这被称为程序次序规则。
            -  对于同一个锁，一个解锁操作一定要发生在时间上后发生的另一个锁定操作之前，也叫做管程锁定规则。
            - 前一个对volatile的写操作在后一个volatile的读操作之前，也叫volatile变量规则。
            - 一个线程内的任何操作必需在这个线程的start()调用之后，也叫作线程启动规则。
            - 一个线程的所有操作都会在线程终止之前，线程终止规则。
            - 一个对象的终结操作必需在这个对象构造完成之后，也叫对象终结规则。
            - 可传递性
	9. Java中的volatile 变量是什么
		- volatile是一个特殊的修饰符，只有成员变量才能使用它。在Java并发程序缺少同步类的情况下，多线程对成员变量的操作对其它线程是透明的。volatile变量可以保证下一个读取操作会在前一个写操作之后发生，就是上一题的volatile变量规则
	10. 什么是线程安全？Vector是一个线程安全类吗
		- 如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。一个线程安全的计数器类的同一个实例对象在被多个线程使用的情况下也不会出现计算失误。很显然你可以将集合类分成两组，线程安全和非线程安全的。Vector 是用同步方法来实现线程安全的, 而和它相似的ArrayList不是线程安全的。
	11. Java中什么是竞态条件
		- 竞态条件会导致程序在并发情况下出现一些bugs。多线程对一些资源的竞争的时候就会产生竞态条件，如果首先要执行的程序竞争失败排到后面执行了，那么整个程序就会出现一些不确定的bugs。这种bugs很难发现而且会重复出现，因为线程间的随机竞争。一个例子就是无序处理，
	12. Java中如何停止一个线程
		- Java提供了很丰富的API但没有为停止线程提供API。JDK 1.0本来有一些像stop(), suspend() 和 resume()的控制方法但是由于潜在的死锁威胁因此在后续的JDK版本中他们被弃用了，之后Java API的设计者就没有提供一个兼容且线程安全的方法来停止一个线程。当run() 或者 call() 方法执行完的时候线程会自动结束,如果要手动结束一个线程，你可以用volatile 布尔变量来退出run()方法的循环或者是取消任务来中断线程。
	13. 一个线程运行时发生异常会怎样
		- 如果异常没有被捕获该线程将会停止执行。Thread.UncaughtExceptionHandler是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候JVM会使用Thread.getUncaughtExceptionHandler()来查询线程的UncaughtExceptionHandler并将线程和异常作为参数传递给handler的uncaughtException()方法进行处理。
	14. 如何在两个线程间共享数据
		- 你可以通过共享对象来实现这个目的，或者是使用像阻塞队列这样并发的数据结构。
	15. Java中notify 和 notifyAll有什么区别
		- 这又是一个刁钻的问题，因为多线程可以等待单监控锁，Java API 的设计人员提供了一些方法当等待条件改变的时候通知它们，但是这些方法没有完全实现。notify()方法不能唤醒某个具体的线程，所以只有一个线程在等待的时候它才有用武之地。而notifyAll()唤醒所有线程并允许他们争夺锁确保了至少有一个线程能继续运行。
	16. 为什么wait, notify 和 notifyAll这些方法不在thread类里面
		- 这是个设计相关的问题，它考察的是面试者对现有系统和一些普遍存在但看起来不合理的事物的看法。回答这些问题的时候，你要说明为什么把这些方法放在Object类里是有意义的，还有不把它放在Thread类里的原因。一个很明显的原因是JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。如果wait()方法定义在Thread类中，线程正在等待的是哪个锁就不明显了。简单的说，由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象。
	17. 什么是ThreadLocal变量
		- ThreadLocal是Java里一种特殊的变量。每个线程都有一个ThreadLocal就是每个线程都拥有了自己独立的一个变量，竞争条件被彻底消除了。它是为创建代价高昂的对象获取线程安全的好方法，比如你可以用ThreadLocal让SimpleDateFormat变成线程安全的，因为那个类创建代价高昂且每次调用都需要创建不同的实例所以不值得在局部范围使用它，如果为每个线程提供一个自己独有的变量拷贝，将大大提高效率。首先，通过复用减少了代价高昂的对象的创建个数。其次，你在没有使用高代价的同步或者不变性的情况下获得了线程安全。线程局部变量的另一个不错的例子是ThreadLocalRandom类，它在多线程环境中减少了创建代价高昂的Random对象的个数。
	18. 什么是FutureTask
		- 在Java并发程序中FutureTask表示一个可以取消的异步运算。它有启动和取消运算、查询运算是否完成和取回运算结果等方法。只有当运算完成的时候结果才能取回，如果运算尚未完成get方法将会阻塞。一个FutureTask对象可以对调用了Callable和Runnable的对象进行包装，由于FutureTask也是调用了Runnable接口所以它可以提交给Executor来执行。
	19. Java中interrupted 和 isInterruptedd方法的区别
		- interrupted() 和 isInterrupted()的主要区别是前者会将中断状态清除而后者不会。Java多线程的中断机制是用内部标识来实现的，调用Thread.interrupt()来中断一个线程就会设置中断标识为true。当中断线程调用静态方法Thread.interrupted()来检查中断状态时，中断状态会被清零。而非静态方法isInterrupted()用来查询其它线程的中断状态且不会改变中断状态标识。简单的说就是任何抛出InterruptedException异常的方法都会将中断状态清零。无论如何，一个线程的中断状态有有可能被其它线程调用中断来改变。
	20. 为什么wait和notify方法要在同步块中调用
		- 主要是因为Java API强制要求这样做，如果你不这么做，你的代码会抛出IllegalMonitorStateException异常。还有一个原因是为了避免wait和notify之间产生竞态条件。
	21. 为什么你应该在循环中检查等待条件
		- 处于等待状态的线程可能会收到错误警报和伪唤醒，如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出。因此，当一个等待线程醒来时，不能认为它原来的等待状态仍然是有效的，在notify()方法调用之后和等待线程醒来之前这段时间它可能会改变。这就是在循环中使用wait()方法效果更好的原因
	22. Java中的同步集合与并发集合有什么区别
		- 同步集合与并发集合都为多线程和并发提供了合适的线程安全的集合，不过并发集合的可扩展性更高。在Java1.5之前程序员们只有同步集合来用且在多线程并发的时候会导致争用，阻碍了系统的扩展性。Java5介绍了并发集合像ConcurrentHashMap，不仅提供线程安全还用锁分离和内部分区等现代技术提高了可扩展性。
	23. Java中堆和栈有什么不同
		- 为什么把这个问题归类在多线程和并发面试题里？因为栈是一块和线程紧密相关的内存区域。每个线程都有自己的栈内存，用于存储本地变量，方法参数和栈调用，一个线程中存储的变量对其它线程是不可见的。而堆是所有线程共享的一片公用内存区域。对象都在堆里创建，为了提升效率线程会从堆中弄一个缓存到自己的栈，如果多个线程使用该变量就可能引发问题，这时volatile 变量就可以发挥作用了，它要求线程从主存中读取变量的值。
	24. 什么是线程池？ 为什么要使用它
		- 创建线程要花费昂贵的资源和时间，如果任务来了才创建线程那么响应时间会变长，而且一个进程能创建的线程数有限。为了避免这些问题，在程序启动的时候就创建若干线程来响应处理，它们被称为线程池，里面的线程叫工作线程。从JDK1.5开始，Java API提供了Executor框架让你可以创建不同的线程池。比如单线程池，每次处理一个任务；数目固定的线程池或者是缓存线程池（一个适合很多生存期短的任务的程序的可扩展线程池）
	25. 如何写代码来解决生产者消费者问题
		- 在现实中你解决的许多线程问题都属于生产者消费者模型，就是一个线程生产任务供其它线程进行消费，你必须知道怎么进行线程间通信来解决这个问题。比较低级的办法是用wait和notify来解决这个问题，比较赞的办法是用Semaphore 或者 BlockingQueue来实现生产者消费者模型，这篇教程有实现它。
	26. 如何避免死锁
		- Java多线程中的死锁
		- 死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。这是一个严重的问题，因为死锁会让你的程序挂起无法完成任务，死锁的发生必须满足以下四个条件：

        - 互斥条件：一个资源每次只能被一个进程使用。
        - 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
        - 不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。
        - 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。
        - 避免死锁最简单的方法就是阻止循环等待条件，将系统中所有的资源设置标志位、排序，规定所有的进程申请资源必须以一定的顺序（升序或降序）做操作来避免死锁。
	27. Java中活锁和死锁有什么区别
		- 这是上题的扩展，活锁和死锁类似，不同之处在于处于活锁的线程或进程的状态是不断改变的，活锁可以认为是一种特殊的饥饿。一个现实的活锁例子是两个人在狭小的走廊碰到，两个人都试着避让对方好让彼此通过，但是因为避让的方向都一样导致最后谁都不能通过走廊。简单的说就是，活锁和死锁的主要区别是前者进程的状态可以改变但是却不能继续执行。
	28. 怎么检测一个线程是否拥有锁
		- 我一直不知道我们竟然可以检测一个线程是否拥有锁，直到我参加了一次电话面试。在java.lang.Thread中有一个方法叫holdsLock()，它返回true如果当且仅当当前线程拥有某个具体对象的锁。
	29. 你如何在Java中获取线程堆栈
		- 对于不同的操作系统，有多种方法来获得Java进程的线程堆栈。当你获取线程堆栈时，JVM会把所有线程的状态存到日志文件或者输出到控制台。在Windows你可以使用Ctrl + Break组合键来获取线程堆栈，Linux下用kill -3命令。你也可以用jstack这个工具来获取，它对线程id进行操作，你可以用jps这个工具找到id。
	30. JVM中哪个参数是用来控制线程的栈堆栈小的
		- 这个问题很简单， -Xss参数用来控制线程的堆栈大小。
	31. Java中synchronized 和 ReentrantLock 有什么不同
		- Java在过去很长一段时间只能通过synchronized关键字来实现互斥，它有一些缺点。比如你不能扩展锁之外的方法或者块边界，尝试获取锁时不能中途取消等。Java 5 通过Lock接口提供了更复杂的控制来解决这些问题。 ReentrantLock 类实现了 Lock，它拥有与 synchronized 相同的并发性和内存语义且它还具有可扩展性。
	32. 有三个线程T1，T2，T3，怎么确保它们按顺序执行
		- 在多线程中有多种方法让线程按特定顺序执行，你可以用线程类的join()方法在一个线程中启动另一个线程，另外一个线程完成该线程继续执行。为了确保三个线程的顺序你应该先启动最后一个(T3调用T2，T2调用T1)，这样T1就会先完成而T3最后完成。
	33. Thread类中的yield方法有什么作用
		- Yield方法可以暂停当前正在执行的线程对象，让其它有相同优先级的线程执行。它是一个静态方法而且只保证当前线程放弃CPU占用而不能保证使其它线程一定能占用CPU，执行yield()的线程有可能在进入到暂停状态后马上又被执行。
	34. Java中ConcurrentHashMap的并发度是什么
		- ConcurrentHashMap把实际map划分成若干部分来实现它的可扩展性和线程安全。这种划分是使用并发度获得的，它是ConcurrentHashMap类构造函数的一个可选参数，默认值为16，这样在多线程情况下就能避免争用。
	35. Java中Semaphore是什么
		- Java中的Semaphore是一种新的同步类，它是一个计数信号。从概念上讲，从概念上讲，信号量维护了一个许可集合。如有必要，在许可可用前会阻塞每一个 acquire()，然后再获取该许可。每个 release()添加一个许可，从而可能释放一个正在阻塞的获取者。但是，不使用实际的许可对象，Semaphore只对可用许可的号码进行计数，并采取相应的行动。信号量常常用于多线程的代码中，比如数据库连接池。
	36. 如果你提交任务时，线程池队列已满。会时发会生什么
		- 这个问题问得很狡猾，许多程序员会认为该任务会阻塞直到线程池队列有空位。事实上如果一个任务不能被调度执行那么ThreadPoolExecutor’s submit()方法将会抛出一个RejectedExecutionException异常。
	37. Java线程池中submit() 和 execute()方法有什么区别
		- 两个方法都可以向线程池提交任务，execute()方法的返回类型是void，它定义在Executor接口中, 而submit()方法可以返回持有计算结果的Future对象，它定义在ExecutorService接口中，它扩展了Executor接口，其它线程池类像ThreadPoolExecutor和ScheduledThreadPoolExecutor都有这些方法。
	38. 什么是阻塞式方法
		- 阻塞式方法是指程序会一直等待该方法完成期间不做其他事情，ServerSocket的accept()方法就是一直等待客户端连接。这里的阻塞是指调用结果返回之前，当前线程会被挂起，直到得到结果之后才会返回。此外，还有异步和非阻塞式方法在任务完成前就返回。
	39. Swing是线程安全的吗？ 为什么？
		- 你可以很肯定的给出回答，Swing不是线程安全的，但是你应该解释这么回答的原因即便面试官没有问你为什么。当我们说swing不是线程安全的常常提到它的组件，这些组件不能在多线程中进行修改，所有对GUI组件的更新都要在AWT线程中完成，而Swing提供了同步和异步两种回调方法来进行更新。
	40. Java中invokeAndWait 和 invokeLater有什么区别
		- 这两个方法是Swing API 提供给Java开发者用来从当前线程而不是事件派发线程更新GUI组件用的。InvokeAndWait()同步更新GUI组件，比如一个进度条，一旦进度更新了，进度条也要做出相应改变。如果进度被多个线程跟踪，那么就调用invokeAndWait()方法请求事件派发线程对组件进行相应更新。而invokeLater()方法是异步调用更新组件的。
	41. Swing API中那些方法是线程安全的
		- 这个问题又提到了swing和线程安全，虽然组件不是线程安全的但是有一些方法是可以被多线程安全调用的，比如repaint(), revalidate()。 JTextComponent的setText()方法和JTextArea的insert() 和 append() 方法也是线程安全的。
	42. 如何在Java中创建Immutable对象
		- 这个问题看起来和多线程没什么关系， 但不变性有助于简化已经很复杂的并发程序。Immutable对象可以在没有同步的情况下共享，降低了对该对象进行并发访问时的同步化开销。可是Java没有@Immutable这个注解符，要创建不可变类，要实现下面几个步骤：通过构造方法初始化所有成员、对变量不要提供setter方法、将所有的成员声明为私有的，这样就不允许直接访问这些成员、在getter方法中，不要直接返回对象本身，而是克隆对象，并返回对象的拷贝。
	43. Java中的ReadWriteLock是什么
		- 一般而言，读写锁是用来提升并发程序性能的锁分离技术的成果。Java中的ReadWriteLock是Java 5 中新增的一个接口，一个ReadWriteLock维护一对关联的锁，一个用于只读操作一个用于写。在没有写线程的情况下一个读锁可能会同时被多个读线程持有。写锁是独占的，你可以使用JDK中的ReentrantReadWriteLock来实现这个规则，它最多支持65535个写锁和65535个读锁。
	44. 多线程中的忙循环是什么
		- 忙循环就是程序员用循环让一个线程等待，不像传统方法wait(), sleep() 或 yield() 它们都放弃了CPU控制，而忙循环不会放弃CPU，它就是在运行一个空循环。这么做的目的是为了保留CPU缓存，在多核系统中，一个等待线程醒来的时候可能会在另一个内核运行，这样会重建缓存。为了避免重建缓存和减少等待重建的时间就可以使用它了
	45. volatile 变量和 atomic 变量有什么不同
		- 这是个有趣的问题。首先，volatile 变量和 atomic 变量看起来很像，但功能却不一样。Volatile变量可以确保先行关系，即写操作会发生在后续的读操作之前, 但它并不能保证原子性。例如用volatile修饰count变量那么 count++ 操作就不是原子性的。而AtomicInteger类提供的atomic方法可以让这种操作具有原子性如getAndIncrement()方法会原子性的进行增量操作把当前值加一，其它数据类型和引用变量也可以进行相似操作。
	46. 如果同步块内的线程抛出异常会发生什么
		- 这个问题坑了很多Java程序员，若你能想到锁是否释放这条线索来回答还有点希望答对。无论你的同步块是正常还是异常退出的，里面的线程都会释放锁，所以对比锁接口我更喜欢同步块，因为它不用我花费精力去释放锁，该功能可以在finally block里释放锁实现。
	47. 单例模式的双检锁是什么
		- 这个问题在Java面试中经常被问到，但是面试官对回答此问题的满意度仅为50%。一半的人写不出双检锁还有一半的人说不出它的隐患和Java1.5是如何对它修正的。它其实是一个用来创建线程安全的单例的老方法，当单例实例第一次被创建时它试图用单个锁进行性能优化，但是由于太过于复杂在JDK1.4中它是失败的，我个人也不喜欢它。无论如何，即便你也不喜欢它但是还是要了解一下，因为它经常被问到。
	48. 如何在Java中创建线程安全的Singleton
		- 这是上面那个问题的后续，如果你不喜欢双检锁而面试官问了创建Singleton类的替代方法，你可以利用JVM的类加载和静态变量初始化特征来创建Singleton实例，或者是利用枚举类型来创建Singleton，我很喜欢用这种方法。
	49. 写出3条你遵循的多线程最佳实践
		- 这种问题我最喜欢了，我相信你在写并发代码来提升性能的时候也会遵循某些最佳实践。以下三条最佳实践我觉得大多数Java程序员都应该遵循：

        - 给你的线程起个有意义的名字。
        - 这样可以方便找bug或追踪。OrderProcessor, QuoteProcessor or TradeProcessor 这种名字比 Thread-1. Thread-2 and Thread-3 好多了，给线程起一个和它要完成的任务相关的名字，所有的主要框架甚至JDK都遵循这个最佳实践。
        - 避免锁定和缩小同步的范围
        - 锁花费的代价高昂且上下文切换更耗费时间空间，试试最低限度的使用同步和锁，缩小临界区。因此相对于同步方法我更喜欢同步块，它给我拥有对锁的绝对控制权。
        - 多用同步类少用wait 和 notify
        - 首先，CountDownLatch, Semaphore, CyclicBarrier 和 Exchanger 这些同步类简化了编码操作，而用wait和notify很难实现对复杂控制流的控制。其次，这些类是由最好的企业编写和维护在后续的JDK中它们还会不断优化和完善，使用这些更高等级的同步工具你的程序可以不费吹灰之力获得优化。
        - 多用并发集合少用同步集合
        - 这是另外一个容易遵循且受益巨大的最佳实践，并发集合比同步集合的可扩展性更好，所以在并发编程时使用并发集合效果更好。如果下一次你需要用到map，你应该首先想到用ConcurrentHashMap。
	50. 如何强制启动一个线程
		- 这个问题就像是如何强制进行Java垃圾回收，目前还没有觉得方法，虽然你可以使用System.gc()来进行垃圾回收，但是不保证能成功。在Java里面没有办法强制启动一个线程，它是被线程调度器控制着且Java没有公布相关的API。
	51. Java中的fork join框架是什么
		- fork join框架是JDK7中出现的一款高效的工具，Java开发人员可以通过它充分利用现代服务器上的多处理器。它是专门为了那些可以递归划分成许多子模块设计的，目的是将所有可用的处理能力用来提升程序的性能。fork join框架一个巨大的优势是它使用了工作窃取算法，可以完成更多任务的工作线程可以从其它线程中窃取任务来执行。
	52. Java多线程中调用wait() 和 sleep()方法有什么不同
		- Java程序中wait 和 sleep都会造成某种形式的暂停，它们可以满足不同的需要。wait()方法用于线程间通信，如果等待条件为真且其它线程被唤醒时它会释放锁，而sleep()方法仅仅释放CPU资源或者让当前线程停止执行一段时间，但不会释放锁。
4. 集合
	1. Java集合框架是什么？说出一些集合框架的优点？
		- 每种编程语言中都有集合，最初的Java版本包含几种集合类：Vector、Stack、HashTable和Array。随着集合的广泛使用，Java1.2提出了囊括所有集合接口、实现和算法的集合框架。在保证线程安全的情况下使用泛型和并发集合类，Java已经经历了很久。它还包括在Java并发包中，阻塞接口以及它们的实现。集合框架的部分优点如下：
            1. 使用核心集合类降低开发成本，而非实现我们自己的集合类。
            2. 随着使用经过严格测试的集合框架类，代码质量会得到提高。
            3. 通过使用JDK附带的集合类，可以降低代码维护成本。
            4. 复用性和可操作性。
	2. 集合框架中的泛型有什么优点？
		- Java1.5引入了泛型，所有的集合接口和实现都大量地使用它。泛型允许我们为集合提供一个可以容纳的对象类型，因此，如果你添加其它类型的任何元素，它会在编译时报错。这避免了在运行时出现ClassCastException，因为你将会在编译时得到报错信息。泛型也使得代码整洁，我们不需要使用显式转换和instanceOf操作符。它也给运行时带来好处，因为不会产生类型检查的字节码指令。
	3. Java集合框架的基础接口有哪些？
		- Collection为集合层级的根接口。一个集合代表一组对象，这些对象即为它的元素。Java平台不提供这个接口任何直接的实现。
        - Set是一个不能包含重复元素的集合。这个接口对数学集合抽象进行建模，被用来代表集合，就如一副牌。
        - List是一个有序集合，可以包含重复元素。你可以通过它的索引来访问任何元素。List更像长度动态变换的数组。
        - Map是一个将key映射到value的对象.一个Map不能包含重复的key：每个key最多只能映射一个value。
        - 一些其它的接口有Queue、Dequeue、SortedSet、SortedMap和ListIterator。
	4. 为何Collection不从Cloneable和Serializable接口继承？
		- Collection接口指定一组对象，对象即为它的元素。如何维护这些元素由Collection的具体实现决定。例如，一些如List的Collection实现允许重复的元素，而其它的如Set就不允许。很多Collection实现有一个公有的clone方法。然而，把它放到集合的所有实现中也是没有意义的。这是因为Collection是一个抽象表现。重要的是实现。
        - 当与具体实现打交道的时候，克隆或序列化的语义和含义才发挥作用。所以，具体实现应该决定如何对它进行克隆或序列化，或它是否可以被克隆或序列化。
        - 在所有的实现中授权克隆和序列化，最终导致更少的灵活性和更多的限制。特定的实现应该决定它是否可以被克隆和序列化。
	5. 为何Map接口不继承Collection接口？
		- 尽管Map接口和它的实现也是集合框架的一部分，但Map不是集合，集合也不是Map。因此，Map继承Collection毫无意义，反之亦然。
		- 如果Map继承Collection接口，那么元素去哪儿？Map包含key-value对，它提供抽取key或value列表集合的方法，但是它不适合“一组对象”规范。
	6. Iterator是什么？
		- Iterator接口提供遍历任何Collection的接口。我们可以从一个Collection中使用迭代器方法来获取迭代器实例。迭代器取代了Java集合框架中的Enumeration。迭代器允许调用者在迭代过程中移除元素。
	7. Enumeration和Iterator接口的区别？
		- Enumeration的速度是Iterator的两倍，也使用更少的内存。Enumeration是非常基础的，也满足了基础的需要。但是，与Enumeration相比，Iterator更加安全，因为当一个集合正在被遍历的时候，它会阻止其它线程去修改集合。
		- 迭代器取代了Java集合框架中的Enumeration。迭代器允许调用者从集合中移除元素，而Enumeration不能做到。为了使它的功能更加清晰，迭代器方法名已经经过改善。
	8. 为何没有像Iterator.add()这样的方法，向集合中添加元素？
		- 语义不明，已知的是，Iterator的协议不能确保迭代的次序。然而要注意，ListIterator没有提供一个add操作，它要确保迭代的顺序。
	9. 为何迭代器没有一个方法可以直接获取下一个元素，而不需要移动游标？
		- 它可以在当前Iterator的顶层实现，但是它用得很少，如果将它加到接口中，每个继承都要去实现它，这没有意义。
	10. Iterater和ListIterator之间有什么区别？
		1. 我们可以使用Iterator来遍历Set和List集合，而ListIterator只能遍历List。
		2. Iterator只可以向前遍历，而LIstIterator可以双向遍历。
		3. ListIterator从Iterator接口继承，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。
	11. 遍历一个List有哪些不同的方式？
		- 使用for-each循环
		- using iterator
		- 使用迭代器更加线程安全，因为它可以确保，在当前遍历的集合元素被更改的时候，它会抛出ConcurrentModificationException。
	12. 通过迭代器fail-fast属性，你明白了什么？
		- 每次我们尝试获取下一个元素的时候，Iterator fail-fast属性检查当前集合结构里的任何改动。如果发现任何改动，它抛出ConcurrentModificationException。Collection中所有Iterator的实现都是按fail-fast来设计的（ConcurrentHashMap和CopyOnWriteArrayList这类并发集合类除外）。
	13. fail-fast与fail-safe有什么区别？
		- Iterator的fail-fast属性与当前的集合共同起作用，因此它不会受到集合中任何改动的影响。Java.util包中的所有集合类都被设计为fail-fast的，而java.util.concurrent中的集合类都为fail-safe的。Fail-fast迭代器抛出ConcurrentModificationException，而fail-safe迭代器从不抛出ConcurrentModificationException。
	14. 在迭代一个集合的时候，如何避免ConcurrentModificationException？
		- 在遍历一个集合的时候，我们可以使用并发集合类来避免ConcurrentModificationException，比如使用CopyOnWriteArrayList，而不是ArrayList。
	15. 为何Iterator接口没有具体的实现？
		- Iterator接口定义了遍历集合的方法，但它的实现则是集合实现类的责任。每个能够返回用于遍历的Iterator的集合类都有它自己的Iterator实现内部类。
		- 这就允许集合类去选择迭代器是fail-fast还是fail-safe的。比如，ArrayList迭代器是fail-fast的，而CopyOnWriteArrayList迭代器是fail-safe的。
	16. UnsupportedOperationException是什么？
		- UnsupportedOperationException是用于表明操作不支持的异常。在JDK类中已被大量运用，在集合框架java.util.Collections.UnmodifiableCollection将会在所有add和remove操作中抛出这个异常。
	17. 在Java中，HashMap是如何工作的？
		- HashMap在Map.Entry静态内部类实现中存储key-value对。HashMap使用哈希算法，在put和get方法中，它使用hashCode()和equals()方法。当我们通过传递key-value对调用put方法的时候，HashMap使用Key hashCode()和哈希算法来找出存储key-value对的索引。Entry存储在LinkedList中，所以如果存在entry，它使用equals()方法来检查传递的key是否已经存在，如果存在，它会覆盖value，如果不存在，它会创建一个新的entry然后保存。当我们通过传递key调用get方法时，它再次使用hashCode()来找到数组中的索引，然后使用equals()方法找出正确的Entry，然后返回它的值。
		- 其它关于HashMap比较重要的问题是容量、负荷系数和阀值调整。HashMap默认的初始容量是32，负荷系数是0.75。阀值是为负荷系数乘以容量，无论何时我们尝试添加一个entry，如果map的大小比阀值大的时候，HashMap会对map的内容进行重新哈希，且使用更大的容量。容量总是2的幂，所以如果你知道你需要存储大量的key-value对，比如缓存从数据库里面拉取的数据，使用正确的容量和负荷系数对HashMap进行初始化是个不错的做法。
	18. hashCode()和equals()方法有何重要性？
		- HashMap使用Key对象的hashCode()和equals()方法去决定key-value对的索引。当我们试着从HashMap中获取值的时候，这些方法也会被用到。如果这些方法没有被正确地实现，在这种情况下，两个不同Key也许会产生相同的hashCode()和equals()输出，HashMap将会认为它们是相同的，然后覆盖它们，而非把它们存储到不同的地方。同样的，所有不允许存储重复数据的集合类都使用hashCode()和equals()去查找重复，所以正确实现它们非常重要。equals()和hashCode()的实现应该遵循以下规则：
			1. 如果o1.equals(o2)，那么o1.hashCode() == o2.hashCode()总是为true的。
			2. 如果o1.hashCode() == o2.hashCode()，并不意味着o1.equals(o2)会为true。
	19. 我们能否使用任何类作为Map的key？
		- 我们可以使用任何类作为Map的key，然而在使用它们之前，需要考虑以下几点：
			1. 如果类重写了equals()方法，它也应该重写hashCode()方法。
			2. 类的所有实例需要遵循与equals()和hashCode()相关的规则。请参考之前提到的这些规则。
			3. 如果一个类没有使用equals()，你不应该在hashCode()中使用它。
			4. 用户自定义key类的最佳实践是使之为不可变的，这样，hashCode()值可以被缓存起来，拥有更好的性能。不可变的类也可以确保hashCode()和equals()在未来不会改变，这样就会解决与可变相关的问题了。
	20. Map接口提供了哪些不同的集合视图？
		- Map接口提供三个集合视图：
			1. Set keyset()：返回map中包含的所有key的一个Set视图。集合是受map支持的，map的变化会在集合中反映出来，反之亦然。当一个迭代器正在遍历一个集合时，若map被修改了（除迭代器自身的移除操作以外），迭代器的结果会变为未定义。集合支持通过Iterator的Remove、Set.remove、removeAll、retainAll和clear操作进行元素移除，从map中移除对应的映射。它不支持add和addAll操作。
			2. Collection values()：返回一个map中包含的所有value的一个Collection视图。这个collection受map支持的，map的变化会在collection中反映出来，反之亦然。当一个迭代器正在遍历一个collection时，若map被修改了（除迭代器自身的移除操作以外），迭代器的结果会变为未定义。集合支持通过Iterator的Remove、Set.remove、removeAll、retainAll和clear操作进行元素移除，从map中移除对应的映射。它不支持add和addAll操作。
			3. Set<Map.Entry<K,V>> entrySet()：返回一个map钟包含的所有映射的一个集合视图。这个集合受map支持的，map的变化会在collection中反映出来，反之亦然。当一个迭代器正在遍历一个集合时，若map被修改了（除迭代器自身的移除操作，以及对迭代器返回的entry进行setValue外），迭代器的结果会变为未定义。集合支持通过Iterator的Remove、Set.remove、removeAll、retainAll和clear操作进行元素移除，从map中移除对应的映射。它不支持add和addAll操作。
	21. HashMap和HashTable有何不同？
		1. HashMap允许key和value为null，而HashTable不允许。
		2. HashTable是同步的，而HashMap不是。所以HashMap适合单线程环境，HashTable适合多线程环境。
		3. 在Java1.4中引入了LinkedHashMap，HashMap的一个子类，假如你想要遍历顺序，你很容易从HashMap转向LinkedHashMap，但是HashTable不是这样的，它的顺序是不可预知的。
		4. HashMap提供对key的Set进行遍历，因此它是fail-fast的，但HashTable提供对key的Enumeration进行遍历，它不支持fail-fast。
		5. HashTable被认为是个遗留的类，如果你寻求在迭代的时候修改Map，你应该使用CocurrentHashMap。
	22. 如何决定选用HashMap还是TreeMap？
		- 对于在Map中插入、删除和定位元素这类操作，HashMap是最好的选择。然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择。基于你的collection的大小，也许向HashMap中添加元素会更快，将map换为TreeMap进行有序key的遍历。
	23. ArrayList和Vector有何异同点？
		- ArrayList和Vector在很多时候都很类似。
			1. 两者都是基于索引的，内部由一个数组支持。
			2. 两者维护插入的顺序，我们可以根据插入顺序来获取元素。
			3. ArrayList和Vector的迭代器实现都是fail-fast的。
			4. ArrayList和Vector两者允许null值，也可以使用索引值对元素进行随机访问。

		- 以下是ArrayList和Vector的不同点。
			1. Vector是同步的，而ArrayList不是。然而，如果你寻求在迭代的时候对列表进行改变，你应该使用CopyOnWriteArrayList。
			2. ArrayList比Vector快，它因为有同步，不会过载。			 3. ArrayList更加通用，因为我们可以使用Collections工具类轻易地获取同步列表和只读列表。
	24. Array和ArrayList有何区别？什么时候更适合用Array？
		- Array可以容纳基本类型和对象，而ArrayList只能容纳对象。
		- Array是指定大小的，而ArrayList大小是固定的。
		- Array没有提供ArrayList那么多功能，比如addAll、removeAll和iterator等。尽管ArrayList明显是更好的选择，但也有些时候Array比较好用。
			1. 如果列表的大小已经指定，大部分情况下是存储和遍历它们。
			2. 对于遍历基本数据类型，尽管Collections使用自动装箱来减轻编码任务，在指定大小的基本类型的列表上工作也会变得很慢。
			3. 如果你要使用多维数组，使用[][]比List<List<>>更容易。
	25. ArrayList和LinkedList有何区别？
		- ArrayList和LinkedList两者都实现了List接口，但是它们之间有些不同。
			1. ArrayList是由Array所支持的基于一个索引的数据结构，所以它提供对元素的随机访问，复杂度为O(1)，但LinkedList存储一系列的节点数据，每个节点都与前一个和下一个节点相连接。所以，尽管有使用索引获取元素的方法，内部实现是从起始点开始遍历，遍历到索引的节点然后返回元素，时间复杂度为O(n)，比ArrayList要慢。
			2. 与ArrayList相比，在LinkedList中插入、添加和删除一个元素会更快，因为在一个元素被插入到中间的时候，不会涉及改变数组的大小，或更新索引。
			3. LinkedList比ArrayList消耗更多的内存，因为LinkedList中的每个节点存储了前后节点的引用。
	26. 哪些集合类提供对元素的随机访问？
		- ArrayList、HashMap、TreeMap和HashTable类提供对元素的随机访问。
	27. EnumSet是什么？
		- java.util.EnumSet是使用枚举类型的集合实现。当集合创建时，枚举集合中的所有元素必须来自单个指定的枚举类型，可以是显示的或隐示的。EnumSet是不同步的，不允许值为null的元素。它也提供了一些有用的方法，比如copyOf(Collection c)、of(E first,E…rest)和complementOf(EnumSet s)。
	28. 哪些集合类是线程安全的？
		- Vector、HashTable、Properties和Stack是同步类，所以它们是线程安全的，可以在多线程环境下使用。Java1.5并发API包括一些集合类，允许迭代时修改，因为它们都工作在集合的克隆上，所以它们在多线程环境中是安全的。
	29. 并发集合类是什么？
		- Java1.5并发包（java.util.concurrent）包含线程安全集合类，允许在迭代时修改集合。迭代器被设计为fail-fast的，会抛出ConcurrentModificationException。一部分类为：CopyOnWriteArrayList、 ConcurrentHashMap、CopyOnWriteArraySet。
	30. BlockingQueue是什么？
		- Java.util.concurrent.BlockingQueue是一个队列，在进行检索或移除一个元素的时候，它会等待队列变为非空；当在添加一个元素时，它会等待队列中的可用空间。BlockingQueue接口是Java集合框架的一部分，主要用于实现生产者-消费者模式。我们不需要担心等待生产者有可用的空间，或消费者有可用的对象，因为它都在BlockingQueue的实现类中被处理了。Java提供了集中BlockingQueue的实现，比如ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue,、SynchronousQueue等。
	31. 队列和栈是什么，列出它们的区别？
		- 栈和队列两者都被用来预存储数据。java.util.Queue是一个接口，它的实现类在Java并发包中。队列允许先进先出（FIFO）检索元素，但并非总是这样。Deque接口允许从两端检索元素。
		- 栈与队列很相似，但它允许对元素进行后进先出（LIFO）进行检索。
		- Stack是一个扩展自Vector的类，而Queue是一个接口。
	32. Collections类是什么？
		- Java.util.Collections是一个工具类仅包含静态方法，它们操作或返回集合。它包含操作集合的多态算法，返回一个由指定集合支持的新集合和其它一些内容。这个类包含集合框架算法的方法，比如折半搜索、排序、混编和逆序等。
	33. Comparable和Comparator接口是什么？
		- 如果我们想使用Array或Collection的排序方法时，需要在自定义类里实现Java提供Comparable接口。Comparable接口有compareTo(T OBJ)方法，它被排序方法所使用。我们应该重写这个方法，如果“this”对象比传递的对象参数更小、相等或更大时，它返回一个负整数、0或正整数。但是，在大多数实际情况下，我们想根据不同参数进行排序。比如，作为一个CEO，我想对雇员基于薪资进行排序，一个HR想基于年龄对他们进行排序。这就是我们需要使用Comparator接口的情景，因为Comparable.compareTo(Object o)方法实现只能基于一个字段进行排序，我们不能根据对象排序的需要选择字段。Comparator接口的compare(Object o1, Object o2)方法的实现需要传递两个对象参数，若第一个参数比第二个小，返回负整数；若第一个等于第二个，返回0；若第一个比第二个大，返回正整数。
	34. Comparable和Comparator接口有何区别？
		- Comparable和Comparator接口被用来对对象集合或者数组进行排序。Comparable接口被用来提供对象的自然排序，我们可以使用它来提供基于单个逻辑的排序。
		- Comparator接口被用来提供不同的排序算法，我们可以选择需要使用的Comparator来对给定的对象集合进行排序。
	35. 我们如何对一组对象进行排序？
		- 如果我们需要对一个对象数组进行排序，我们可以使用Arrays.sort()方法。如果我们需要排序一个对象列表，我们可以使用Collection.sort()方法。两个类都有用于自然排序（使用Comparable）或基于标准的排序（使用Comparator）的重载方法sort()。Collections内部使用数组排序方法，所有它们两者都有相同的性能，只是Collections需要花时间将列表转换为数组。
	36. 当一个集合被作为参数传递给一个函数时，如何才可以确保函数不能修改它？
		- 在作为参数传递之前，我们可以使用Collections.unmodifiableCollection(Collection c)方法创建一个只读集合，这将确保改变集合的任何操作都会抛出UnsupportedOperationException。
	37. 我们如何从给定集合那里创建一个synchronized的集合？
		- 我们可以使用Collections.synchronizedCollection(Collection c)根据指定集合来获取一个synchronized（线程安全的）集合。
	38. 集合框架里实现的通用算法有哪些？
		- Java集合框架提供常用的算法实现，比如排序和搜索。Collections类包含这些方法实现。大部分算法是操作List的，但一部分对所有类型的集合都是可用的。部分算法有排序、搜索、混编、最大最小值。
	39. 大写的O是什么？举几个例子？
		- 大写的O描述的是，就数据结构中的一系列元素而言，一个算法的性能。Collection类就是实际的数据结构，我们通常基于时间、内存和性能，使用大写的O来选择集合实现。比如：例子1：ArrayList的get(index i)是一个常量时间操作，它不依赖list中元素的数量。所以它的性能是O(1)。例子2：一个对于数组或列表的线性搜索的性能是O(n)，因为我们需要遍历所有的元素来查找需要的元素。
	40. 与Java集合框架相关的有哪些最好的实践？
		1. 根据需要选择正确的集合类型。比如，如果指定了大小，我们会选用Array而非ArrayList。如果我们想根据插入顺序遍历一个Map，我们需要使用TreeMap。如果我们不想重复，我们应该使用Set。
		2. 一些集合类允许指定初始容量，所以如果我们能够估计到存储元素的数量，我们可以使用它，就避免了重新哈希或大小调整。
		3. 基于接口编程，而非基于实现编程，它允许我们后来轻易地改变实现。
		4. 总是使用类型安全的泛型，避免在运行时出现ClassCastException。
		5. 使用JDK提供的不可变类作为Map的key，可以避免自己实现hashCode()和equals()。
		6. 尽可能使用Collections工具类，或者获取只读、同步或空的集合，而非编写自己的实现。它将会提供代码重用性，它有着更好的稳定性和可维护性。
5. 开源框架
	1. spring
		1. 什么是Spring？
			- Spring是一个开源的Java EE开发框架。Spring框架的核心功能可以应用在任何Java应用程序中，但对Java EE平台上的Web应用程序有更好的扩展性。Spring框架的目标是使得Java EE应用程序的开发更加简捷，通过使用POJO为基础的编程模型促进良好的编程风格。
		2. Spring有哪些优点？
			- 轻量级：Spring在大小和透明性方面绝对属于轻量级的，基础版本的Spring框架大约只有2MB。
			- 控制反转(IOC)：Spring使用控制反转技术实现了松耦合。依赖被注入到对象，而不是创建或寻找依赖对象。
			- 面向切面编程(AOP)： Spring支持面向切面编程，同时把应用的业务逻辑与系统的服务分离开来。
			- 容器：Spring包含并管理应用程序对象的配置及生命周期。
			- MVC框架：Spring的web框架是一个设计优良的web MVC框架，很好的取代了一些web框架。
			- 事务管理：Spring对下至本地业务上至全局业务(JAT)提供了统一的事务管理接口。
			- 异常处理：Spring提供一个方便的API将特定技术的异常(由JDBC, Hibernate, 或JDO抛出)转化为一致的、Unchecked异常。
		3. Spring框架有哪些模块？
			- Core module
			- Bean module
			- Context module
			- Expression Language module
			- JDBC module
			- ORM module
			- OXM module
			- Java Messaging Service(JMS) module
			- Transaction module
			- Web module
			- Web-Servlet module
			- Web-Struts module
			- Web-Portlet module
		4. 解释核心容器(应用上下文)模块
			- 这是Spring的基本模块，它提供了Spring框架的基本功能。BeanFactory 是所有Spring应用的核心。Spring框架是建立在这个模块之上的，这也使得Spring成为一个容器。
		5. BeanFactory – BeanFactory 实例
			- BeanFactory是工厂模式的一种实现，它使用控制反转将应用的配置和依赖与实际的应用代码分离开来。
			- 最常用的BeanFactory实现是XmlBeanFactory类。
		6. XmlBeanFactory
			- 最常用的就是org.springframework.beans.factory.xml.XmlBeanFactory，它根据XML文件中定义的内容加载beans。该容器从XML文件中读取配置元数据，并用它来创建一个完备的系统或应用。
		7. 解释AOP模块
			- AOP模块用来开发Spring应用程序中具有切面性质的部分。该模块的大部分服务由AOP Aliance提供，这就保证了Spring框架和其他AOP框架之间的互操作性。另外，该模块将元数据编程引入到了Spring。
		8. 解释抽象JDBC和DAO模块
			- 通过使用抽象JDBC和DAO模块保证了与数据库连接代码的整洁与简单，同时避免了由于未能关闭数据库资源引起的问题。它在多种数据库服务器的错误信息之上提供了一个很重要的异常层。它还利用Spring的AOP模块为Spring应用程序中的对象提供事务管理服务。
		9. 解释对象/关系映射集成模块
			- Spring通过提供ORM模块在JDBC的基础上支持对象关系映射工具。这样的支持使得Spring可以集成主流的ORM框架，包括Hibernate, JDO, 及iBATIS SQL Maps。Spring的事务管理可以同时支持以上某种框架和JDBC。
		10. 解释web模块
			- Spring的web模块建立在应用上下文(application context)模块之上，提供了一个适合基于web应用程序的上下文环境。该模块还支持了几个面向web的任务，如透明的处理多文件上传请求及将请求参数同业务对象绑定起来。
		11. 解释Spring MVC模块
			- Spring提供MVC框架构建web应用程序。Spring可以很轻松的同其他MVC框架结合，但Spring的MVC是个更好的选择，因为它通过控制反转将控制逻辑和业务对象完全分离开来。
		12. Spring的配置文件
			- Spring的配置文件是一个XML文件，文件包含了类信息并描述了这些类是如何配置和互相调用的。
		13. Spring IoC容器是什么？
			- Spring IOC负责创建对象、管理对象(通过依赖注入)、整合对象、配置对象以及管理这些对象的生命周期。
		14. IOC有什么优点？
			- IOC或依赖注入减少了应用程序的代码量。它使得应用程序的测试很简单，因为在单元测试中不再需要单例或JNDI查找机制。简单的实现以及较少的干扰机制使得松耦合得以实现。IOC容器支持勤性单例及延迟加载服务。
		15. 应用上下文是如何实现的？
			- FileSystemXmlApplicationContext 容器加载XML文件中beans的定义。XML Bean配置文件的完整路径必须传递给构造器。
			- FileSystemXmlApplicationContext 容器也加载XML文件中beans的定义。注意，你需要正确的设置CLASSPATH，因为该容器会在CLASSPATH中查看bean的XML配置文件。
			- WebXmlApplicationContext：该容器加载xml文件，这些文件定义了web应用中所有的beans。
		16. Bean Factory和ApplicationContext有什么区别？
			- ApplicationContext提供了一种解决文档信息的方法，一种加载文件资源的方式(如图片)，他们可以向监听他们的beans发送消息。另外，容器或者容器中beans的操作，这些必须以bean工厂的编程方式处理的操作可以在应用上下文中以声明的方式处理。应用上下文实现了MessageSource，该接口用于获取本地消息，实际的实现是可选的。
		17. Spring应用程序看起来像什么？
			- 一个定义功能的接口
			- 实现包括属性，setter和getter方法，功能等
			- Spring AOP
			- Spring的XML配置文件
			- 使用该功能的客户端编程
		18. Spring中的依赖注入是什么？
			- 依赖注入作为控制反转(IOC)的一个层面，可以有多种解释方式。在这个概念中，你不用创建对象而只需要描述如何创建它们。你不必通过代码直接的将组件和服务连接在一起，而是通过配置文件说明哪些组件需要什么服务。之后IOC容器负责衔接。
		19. 有哪些不同类型的IOC(依赖注入)？
			- 构造器依赖注入：构造器依赖注入在容器触发构造器的时候完成，该构造器有一系列的参数，每个参数代表注入的对象。
			- Setter方法依赖注入：首先容器会触发一个无参构造函数或无参静态工厂方法实例化对象，之后容器调用bean中的setter方法完成Setter方法依赖注入。
		20. 你推荐哪种依赖注入？构造器依赖注入还是Setter方法依赖注入？
			- 你可以同时使用两种方式的依赖注入，最好的选择是使用构造器参数实现强制依赖注入，使用setter方法实现可选的依赖关系。
		21. 什么是Spring Beans？
			- Spring Beans是构成Spring应用核心的Java对象。这些对象由Spring IOC容器实例化、组装、管理。这些对象通过容器中配置的元数据创建，例如，使用XML文件中定义的创建。
			- 在Spring中创建的beans都是单例的beans。在bean标签中有一个属性为”singleton”,如果设为true，该bean是单例的，如果设为false，该bean是原型bean。Singleton属性默认设置为true。因此，spring框架中所有的bean都默认为单例bean。
		22. Spring Bean中定义了什么内容？
			- Spring Bean中定义了所有的配置元数据，这些配置信息告知容器如何创建它，它的生命周期是什么以及它的依赖关系。
		23. 如何向Spring 容器提供配置元数据？
			- 有三种方式向Spring 容器提供元数据:
				1. XML配置文件
				2. 基于注解配置
				3. 基于Java的配置
		24. 你如何定义bean的作用域？
			- 在Spring中创建一个bean的时候，我们可以声明它的作用域。只需要在bean定义的时候通过’scope’属性定义即可。例如，当Spring需要产生每次一个新的bean实例时，应该声明bean的scope属性为prototype。如果每次你希望Spring返回一个实例，应该声明bean的scope属性为singleton。
		25. 说一下Spring中支持的bean作用域
			- Spring框架支持如下五种不同的作用域：
				- singleton：在Spring IOC容器中仅存在一个Bean实例，Bean以单实例的方式存在。
				- prototype：一个bean可以定义多个实例。
				- request：每次HTTP请求都会创建一个新的Bean。该作用域仅适用于WebApplicationContext环境。
				- session：一个HTTP Session定义一个Bean。该作用域仅适用于WebApplicationContext环境.
				- globalSession：同一个全局HTTP Session定义一个Bean。该作用域同样仅适用于WebApplicationContext环境.
				- bean默认的scope属性是’singleton‘。
		26. Spring框架中单例beans是线程安全的吗？
			- 不是，Spring框架中的单例beans不是线程安全的。
		27. 解释Spring框架中bean的生命周期
			1. Spring容器读取XML文件中bean的定义并实例化bean。
			2. Spring根据bean的定义设置属性值。
			3. 如果该Bean实现了BeanNameAware接口，Spring将bean的id传递给setBeanName()方法。
			4. 如果该Bean实现了BeanFactoryAware接口，Spring将beanfactory传递给setBeanFactory()方法。
			5. 如果任何bean BeanPostProcessors 和该bean相关，Spring调用postProcessBeforeInitialization()方法。
			6. 如果该Bean实现了InitializingBean接口，调用Bean中的afterPropertiesSet方法。如果bean有初始化函数声明，调用相应的初始化方法。
			7. 如果任何bean BeanPostProcessors 和该bean相关，调用postProcessAfterInitialization()方法。
			8. 如果该bean实现了DisposableBean，调用destroy()方法。
		28. 哪些是最重要的bean生命周期方法？能重写它们吗？
			- 有两个重要的bean生命周期方法。第一个是setup方法，该方法在容器加载bean的时候被调用。第二个是teardown方法，该方法在bean从容器中移除的时候调用。
			- bean标签有两个重要的属性(init-method 和 destroy-method)，你可以通过这两个属性定义自己的初始化方法和析构方法。Spring也有相应的注解：@PostConstruct 和 @PreDestroy。
		29. 什么是Spring的内部bean？
			- 当一个bean被用作另一个bean的属性时，这个bean可以被声明为内部bean。在基于XML的配置元数据中，可以通过把元素定义在 或元素内部实现定义内部bean。内部bean总是匿名的并且它们的scope总是prototype。
		30. 如何在Spring中注入Java集合类？
			- Spring提供如下几种类型的集合配置元素：
				- list元素用来注入一系列的值，允许有相同的值。
				- set元素用来注入一些列的值，不允许有相同的值。
				- map用来注入一组”键-值”对，键、值可以是任何类型的。
				- props也可以用来注入一组”键-值”对，这里的键、值都字符串类型。
		31. 什么是bean wiring？
			- Wiring，或者说bean Wiring是指beans在Spring容器中结合在一起的情况。当装配bean的时候，Spring容器需要知道需要哪些beans以及如何使用依赖注入将它们结合起来。
		32. 什么是bean自动装配？
			- Spring容器可以自动配置相互协作beans之间的关联关系。这意味着Spring可以自动配置一个bean和其他协作bean之间的关系，通过检查BeanFactory 的内容里没有使用和< property>元素。
		33. 解释自动装配的各种模式？
			- 自动装配提供五种不同的模式供Spring容器用来自动装配beans之间的依赖注入:
				- no：默认的方式是不进行自动装配，通过手工设置ref 属性来进行装配bean。
				- byName：通过参数名自动装配，Spring容器查找beans的属性，这些beans在XML配置文件中被设置为byName。之后容器试图匹配、装配和该bean的属性具有相同名字的bean。
				- byType：通过参数的数据类型自动自动装配，Spring容器查找beans的属性，这些beans在XML配置文件中被设置为byType。之后容器试图匹配和装配和该bean的属性类型一样的bean。如果有多个bean符合条件，则抛出错误。
				- constructor：这个同byType类似，不过是应用于构造函数的参数。如果在BeanFactory中不是恰好有一个bean与构造函数参数相同类型，则抛出一个严重的错误。
				- autodetect：如果有默认的构造方法，通过 construct的方式自动装配，否则使用 byType的方式自动装配。
		34. 自动装配有哪些局限性？
			- 自动装配有如下局限性：
				- 重写：你仍然需要使用 和< property>设置指明依赖，这意味着总要重写自动装配。
				- 原生数据类型:你不能自动装配简单的属性，如原生类型、字符串和类。
				- 模糊特性：自动装配总是没有自定义装配精确，因此，如果可能尽量使用自定义装配。
		35. 你可以在Spring中注入null或空字符串吗?
			- 完全可以。
		36. 什么是Spring基于Java的配置？给出一些注解的例子
			- 基于Java的配置允许你使用Java的注解进行Spring的大部分配置而非通过传统的XML文件配置。
			- 以注解@Configuration为例，它用来标记类，说明作为beans的定义，可以被Spring IOC容器使用。另一个例子是@Bean注解，它表示该方法定义的Bean要被注册进Spring应用上下文中。
		37. 什么是基于注解的容器配置?
			- 另外一种替代XML配置的方式为基于注解的配置，这种方式通过字节元数据装配组件而非使用尖括号声明。开发人员将直接在类中进行配置，通过注解标记相关的类、方法或字段声明，而不再使用XML描述bean之间的连线关系。
		38. 如何开启注解装配？
			- 注解装配默认情况下在Spring容器中是不开启的。如果想要开启基于注解的装配只需在Spring配置文件中配置元素即可。
		39. @Required 注解
			- @Required表明bean的属性必须在配置时设置，可以在bean的定义中明确指定也可通过自动装配设置。如果bean的属性未设置，则抛出BeanInitializationException异常。
		40. @Autowired 注解
			- @Autowired 注解提供更加精细的控制，包括自动装配在何处完成以及如何完成。它可以像@Required一样自动装配setter方法、构造器、属性或者具有任意名称和/或多个参数的PN方法。
		41. @Qualifier 注解
			- 当有多个相同类型的bean而只有其中的一个需要自动装配时，将@Qualifier 注解和@Autowire 注解结合使用消除这种混淆，指明需要装配的bean。
		42. 在Spring框架中如何更有效的使用JDBC？
			- 使用Spring JDBC框架，资源管理以及错误处理的代价都会减轻。开发人员只需通过statements和queries语句从数据库中存取数据。Spring框架中通过使用模板类能更有效的使用JDBC，也就是所谓的JdbcTemplate(例子)。
		43. JdbcTemplate
			- JdbcTemplate类提供了许多方法，为我们与数据库的交互提供了便利。例如，它可以将数据库的数据转化为原生类型或对象，执行写好的或可调用的数据库操作语句，提供自定义的数据库错误处理功能。
		44. Spring对DAO的支持
			- Spring对数据访问对象(DAO)的支持旨在使它可以与数据访问技术(如 JDBC, Hibernate 及JDO)方便的结合起来工作。这使得我们可以很容易在的不同的持久层技术间切换，编码时也无需担心会抛出特定技术的异常。
		45. 使用Spring可以通过什么方式访问Hibernate？
			- 使用Spring有两种方式访问Hibernate：
				1. 使用Hibernate Template的反转控制以及回调方法
				2. 继承HibernateDAOSupport，并申请一个AOP拦截器节点
		46. Spring支持的ORM
			- Hibernate
            - iBatis
            - JPA (Java -Persistence API)
            - TopLink
            - JDO (Java Data Objects)
            - OJB
		47. 如何通过HibernateDaoSupport将Spring和Hibernate结合起来？
			- 使用Spring的SessionFactory 调用LocalSessionFactory。结合过程分为以配置Hibernate SessionFactory下三步：
				1. 配置Hibernate SessionFactory
				2. 继承HibernateDaoSupport实现一个DAO
				3. 使用AOP装载事务支持
		48. Spring支持的事务管理类型
			- Spring支持如下两种方式的事务管理：
				- 编程式事务管理：这意味着你可以通过编程的方式管理事务，这种方式带来了很大的灵活性，但很难维护。
				- 声明式事务管理：这种方式意味着你可以将事务管理和业务代码分离。你只需要通过注解或者XML配置管理事务。
		49. Spring框架的事务管理有哪些优点？
			- 它为不同的事务API(如JTA, JDBC, Hibernate, JPA, 和JDO)提供了统一的编程模型。
			- 它为编程式事务管理提供了一个简单的API而非一系列复杂的事务API(如JTA).
			- 它支持声明式事务管理。
			- 它可以和Spring 的多种数据访问技术很好的融合。
		50. 你更推荐那种类型的事务管理？
			- 许多Spring框架的用户选择声明式事务管理，因为这种方式和应用程序的关联较少，因此更加符合轻量级容器的概念。声明式事务管理要优于编程式事务管理，尽管在灵活性方面它弱于编程式事务管理(这种方式允许你通过代码控制业务)。
		51. 解释AOP
			- 面向切面编程,或AOP允许程序员模块化横向业务逻辑，或定义核心部分的功能，例如日志管理和事务管理。
		52. 切面(Aspect)
			- AOP的核心就是切面，它将多个类的通用行为封装为可重用的模块。该模块含有一组API提供 cross-cutting功能。例如,日志模块称为日志的AOP切面。根据需求的不同，一个应用程序可以有若干切面。在Spring AOP中，切面通过带有@Aspect注解的类实现。
		53. 在Spring AOP中concern和 cross-cutting concern的区别是什么？
			- Concern(核心逻辑)：表示在应用程序中一个模块的行为。Concern可以定义为我们想要实现的功能。
			- Cross-cutting concern(横向的通用逻辑)：指的是整个应用程序都会用到的功能，它影响整个应用程序。例如，日志管理（Logging）、安全管理（Security）以及数据交互是应用程序的每个模块都要涉及到的，因此这些都属于Cross-cutting concern。
		54. 连接点(Join point)
			- 连接点代表应用程序中插入AOP切面的地点。它实际上是Spring AOP框架在应用程序中执行动作的地点。
		55. 通知(Advice)
			- 通知表示在方法执行前后需要执行的动作。实际上它是Spring AOP框架在程序执行过程中触发的一些代码。
			- Spring切面可以执行一下五种类型的通知:
				- before(前置通知)：在一个方法之前执行的通知。
				- after(最终通知)：当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）。
				- after-returning(后置通知)：在某连接点正常完成后执行的通知。
				- after-throwing(异常通知)：在方法抛出异常退出时执行的通知。
				- around(环绕通知)：在方法调用前后触发的通知。
		56. 切入点(Pointcut)
			- 切入点是一个或一组连接点，通知将在这些位置执行。可以通过表达式或匹配的方式指明切入点。
		57. 什么是引入？
			- 引入允许我们在已有的类上添加新的方法或属性。
		58. 什么是目标对象？
			- 被一个或者多个切面所通知的对象。它通常是一个代理对象。也被称做被通知（advised）对象。
		59. 什么是代理？
			- 代理是将通知应用到目标对象后创建的对象。从客户端的角度看，代理对象和目标对象是一样的。
		60. 有几种不同类型的自动代理？
			- BeanNameAutoProxyCreator：bean名称自动代理创建器
			- DefaultAdvisorAutoProxyCreator：默认通知者自动代理创建器
			- Metadata autoproxying：元数据自动代理
		61. 什么是织入？什么是织入应用的不同点？
			- 织入是将切面和其他应用类型或对象连接起来创建一个通知对象的过程。织入可以在编译、加载或运行时完成。
		62. 解释基于XML Schema方式的切面实现
			- 在这种情况下，切面由使用XML文件配置的类实现
		63. 解释基于注解方式(基于@AspectJ)的切面实现
			- 在这种情况下(基于@AspectJ的实现)，指的是切面的对应的类使用Java 5注解的声明方式。
		64. 什么是Spring的MVC框架？
			- Spring提供了一个功能齐全的MVC框架用于构建Web应用程序。Spring框架可以很容易的和其他的MVC框架融合(如Struts)，该框架使用控制反转(IOC)将控制器逻辑和业务对象分离开来。它也允许以声明的方式绑定请求参数到业务对象上。
		65. DispatcherServlet
			- Spring的MVC框架围绕DispatcherServlet来设计的，它用来处理所有的HTTP请求和响应。
		66. WebApplicationContext
			- WebApplicationContext继承了ApplicationContext，并添加了一些web应用程序需要的功能。和普通的ApplicationContext 不同，WebApplicationContext可以用来处理主题样式，它也知道如何找到相应的servlet。
		67. 什么是Spring MVC框架的控制器？
			- 控制器提供对应用程序行为的访问，通常通过服务接口实现。控制器解析用户的输入，并将其转换为一个由视图呈现给用户的模型。Spring 通过一种极其抽象的方式实现控制器，它允许用户创建多种类型的控制器。
		68. @Controller annotation
			- @Controller注解表示该类扮演控制器的角色。Spring不需要继承任何控制器基类或应用Servlet API。
		69. @RequestMapping annotation
			- @RequestMapping注解用于将URL映射到任何一个类或者一个特定的处理方法上。
	2. ibatis
		1. #{}和${}的区别是什么？
			- ${}是Properties文件中的变量占位符，它可以用于标签属性值和sql内部，属于静态文本替换，比如${driver}会被静态替换为com.mysql.jdbc.Driver。#{}是sql的参数占位符，Mybatis会将sql中的#{}替换为?号，在sql执行前会使用PreparedStatement的参数设置方法，按序给sql的?号占位符设置参数值，比如ps.setInt(0, parameterValue)，#{item.name}的取值方式为使用反射从参数对象中获取item对象的name属性值，相当于param.getItem().getName()。
		2. Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？
			- 还有很多其他的标签，resultMap>、parameterMap>、sql>、include>、selectKey>，加上动态sql的9个标签，trim|where|set|foreach|if|choose|when|otherwise|bind等，其中sql>为sql片段标签，通过include>标签引入sql片段，selectKey>为不支持自增的主键生成策略标签。
		3. 最佳实践中，通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？
			- Dao接口，就是人们常说的Mapper接口，接口的全限名，就是映射文件中的namespace的值，接口的方法名，就是映射文件中MappedStatement的id值，接口方法内的参数，就是传递给sql的参数。Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为key值，可唯一定位一个MappedStatement，举例：com.mybatis3.mappers.StudentDao.findStudentById，可以唯一找到namespace为com.mybatis3.mappers.StudentDao下面id = findStudentById的MappedStatement。在Mybatis中，每一个select>、insert>、update>、delete>标签，都会被解析为一个MappedStatement对象。
			- Dao接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。
			- Dao接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Dao接口生成代理proxy对象，代理对象proxy会拦截接口方法，转而执行MappedStatement所代表的sql，然后将sql执行结果返回。
		4. Mybatis是如何进行分页的？分页插件的原理是什么？
			- Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页，可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。
			- 分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。
		5. 简述Mybatis的插件运行原理，以及如何编写一个插件。
			- Mybatis仅可以编写针对ParameterHandler、ResultSetHandler、StatementHandler、Executor这4种接口的插件，Mybatis使用JDK的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这4种接口对象的方法时，就会进入拦截方法，具体就是InvocationHandler的invoke()方法，当然，只会拦截那些你指定需要拦截的方法。
			- 实现Mybatis的Interceptor接口并复写intercept()方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。
		6. Mybatis执行批量插入，能返回数据库主键列表吗？
			- 能，JDBC都能，Mybatis当然也能。
		7. Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？
			- Mybatis动态sql可以让我们在Xml映射文件内，以标签的形式编写动态sql，完成逻辑判断和动态拼接sql的功能，Mybatis提供了9种动态sql标签trim|where|set|foreach|if|choose|when|otherwise|bind。
			- 其执行原理为，使用OGNL从sql参数对象中计算表达式的值，根据表达式的值动态拼接sql，以此来完成动态sql的功能。
		8. Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？
			- 第一种是使用resultMap>标签，逐一定义列名和对象属性名之间的映射关系。第二种是使用sql列的别名功能，将列别名书写为对象属性名，比如T_NAME AS NAME，对象属性名一般是name，小写，但是列名不区分大小写，Mybatis会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成T_NAME AS NaMe，Mybatis一样可以正常工作。
			- 有了列名与属性名的映射关系后，Mybatis通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。
		9. Mybatis能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别。
			- 能，Mybatis不仅可以执行一对一、一对多的关联查询，还可以执行多对一，多对多的关联查询，多对一查询，其实就是一对一查询，只需要把selectOne()修改为selectList()即可；多对多查询，其实就是一对多查询，只需要把selectOne()修改为selectList()即可。
			- 关联对象查询，有两种实现方式，一种是单独发送一个sql去查询关联对象，赋给主对象，然后返回主对象。另一种是使用嵌套查询，嵌套查询的含义为使用join查询，一部分列是A对象的属性值，另外一部分列是关联对象B的属性值，好处是只发一个sql查询，就可以把主对象和其关联对象查出来。
			- 那么问题来了，join查询出来100条记录，如何确定主对象是5个，而不是100个？其去重复的原理是resultMap>标签内的id>子标签，指定了唯一确定一条记录的id列，Mybatis根据id>列值来完成100条记录的去重复功能，id>可以有多个，代表了联合主键的语意。
			- 同样主对象的关联对象，也是根据这个原理去重复的，尽管一般情况下，只有主对象会有重复记录，关联对象一般不会重复。
		10. Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？
			- Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false。
			- 它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。
			- 当然了，不光是Mybatis，几乎所有的包括Hibernate，支持延迟加载的原理都是一样的。
		11. Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？
			- 不同的Xml映射文件，如果配置了namespace，那么id可以重复；如果没有配置namespace，那么id不能重复；毕竟namespace不是必须的，只是最佳实践而已。
			- 原因就是namespace+id是作为Map，String, MappedStatement>的key使用的，如果没有namespace，就剩下id，那么，id重复会导致数据互相覆盖。有了namespace，自然id就可以重复，namespace不同，namespace+id自然也就不同。
		12. Mybatis中如何执行批处理？
			- 使用BatchExecutor完成批处理。
		13. Mybatis都有哪些Executor执行器？它们之间的区别是什么？
			- Mybatis有三种基本的Executor执行器，SimpleExecutor、ReuseExecutor、BatchExecutor。
			- SimpleExecutor：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。
			- ReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map，String, Statement>内，供下一次使用。简言之，就是重复使用Statement对象。
			- BatchExecutor：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。
			- 作用范围：Executor的这些特点，都严格限制在SqlSession生命周期范围内。
		14. Mybatis中如何指定使用哪一种Executor执行器？
			- 在Mybatis配置文件中，可以指定默认的ExecutorType执行器类型，也可以手动给DefaultSqlSessionFactory的创建SqlSession的方法传递ExecutorType类型参数。
		15. Mybatis是否可以映射Enum枚举类？
			- Mybatis可以映射枚举类，不单可以映射枚举类，Mybatis可以映射任何对象到表的一列上。映射方式为自定义一个TypeHandler，实现TypeHandler的setParameter()和getResult()接口方法。TypeHandler有两个作用，一是完成从javaType至jdbcType的转换，二是完成jdbcType至javaType的转换，体现为setParameter()和getResult()两个方法，分别代表设置sql问号占位符参数和获取列查询结果。
		16. Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？
			- 虽然Mybatis解析Xml映射文件是按照顺序解析的，但是，被引用的B标签依然可以定义在任何地方，Mybatis都可以正确识别。
			- 原理是，Mybatis解析A标签，发现A标签引用了B标签，但是B标签尚未解析到，尚不存在，此时，Mybatis会将A标签标记为未解析状态，然后继续解析余下的标签，包含B标签，待所有标签解析完毕，Mybatis会重新解析那些被标记为未解析的标签，此时再解析A标签时，B标签已经存在，A标签也就可以正常解析完成了。
		17. 简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？
			- Mybatis将所有Xml配置信息都封装到All-In-One重量级对象Configuration内部。在Xml映射文件中，parameterMap>标签会被解析为ParameterMap对象，其每个子元素会被解析为ParameterMapping对象。resultMap>标签会被解析为ResultMap对象，其每个子元素会被解析为ResultMapping对象。每一个select>、insert>、update>、delete>标签均会被解析为MappedStatement对象，标签内的sql会被解析为BoundSql对象。
		18. 为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？
			- Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半自动ORM映射工具。
	3. hibernate
		1. Hibernate中get和load有什么不同之处?
			- 把get和load放到一起进行对比是Hibernate面试时最常问到的问题，这是因为只有正确理解get()和load()这二者后才有可能高效地使用Hibernate。get和load的最大区别是，如果在缓存中没有找到相应的对象，get将会直接访问数据库并返回一个完全初始化好的对象，而这个过程有可能会涉及到多个数据库调用；而load方法在缓存中没有发现对象的情况下，只会返回一个代理对象，只有在对象getId()之外的其它方法被调用时才会真正去访问数据库，这样就能在某些情况下大幅度提高性能。
		2. Hibernate中save、persist和saveOrUpdate这三个方法的不同之处？
			- 除了get和load，这又是另外一个经常出现的Hibernate面试问题。 所有这三个方法，也就是save()、saveOrUpdate()和persist()都是用于将对象保存到数据库中的方法，但其中有些细微的差别。例如，save()只能INSERT记录，但是saveOrUpdate()可以进行 记录的INSERT和UPDATE。还有，save()的返回值是一个Serializable对象，而persist()方法返回值为void。你还可以访问 save、persist以及saveOrUpdate，找到它们所有的不同之处。
		3. Hibernate中的命名SQL查询指的是什么?
			- Hibernate的这个面试问题同Hibernate提供的查询功能相关。命名查询指的是用sql-query>标签在影射文档中定义的SQL查询，可以通过使用Session.getNamedQuery()方法对它进行调用。命名查询使你可以使用你所指定的一个名字拿到某个特定的查询。 Hibernate中的命名查询可以使用注解来定义，也可以使用我前面提到的xml影射问句来定义。在Hibernate中，@NameQuery用来定义单个的命名查询，@NameQueries用来定义多个命名查询。
		4. Hibernate中的SessionFactory有什么作用? SessionFactory是线程安全的吗？
			- 这也是Hibernate框架的常见面试问题。顾名思义，SessionFactory就是一个用于创建Hibernate的Session对象的工厂。SessionFactory通常是在应用启动时创建好的，应用程序中的代码用它来获得Session对象。作为一个单个的数据存储，它也是 线程安全的，所以多个线程可同时使用同一个SessionFactory。Java JEE应用一般只有一个SessionFactory，服务于客户请求的各线程都通过这个工厂来获得Hibernate的Session实例，这也是为什么SessionFactory接口的实现必须是线程安全的原因。还有，SessionFactory的内部状态包含着同对象关系影射有关的所有元数据，它是 不可变的，一旦创建好后就不能对其进行修改了。
		5. Hibernate中的Session指的是什么? 可否将单个的Session在多个线程间进行共享？
			- 前面的问题问完之后，通常就会接着再问这两个问题。问完SessionFactory的问题后就该轮到Session了。Session代表着Hibernate所做的一小部分工作，它负责维护者同数据库的链接而且 不是线程安全的，也就是说，Hibernage中的Session不能在多个线程间进行共享。虽然Session会以主动滞后的方式获得数据库连接，但是Session最好还是在用完之后立即将其关闭。
		6. hibernate中sorted collection和ordered collection有什么不同?
			- T这个是你会碰到的所有Hibernate面试问题中比较容易的问题。sorted collection是通过使用 Java的Comparator在内存中进行排序的，ordered collection中的排序用的是数据库的order by子句。对于比较大的数据集，为了避免在内存中对它们进行排序而出现 Java中的OutOfMemoryError，最好使用ordered collection。
		7. Hibernate中transient、persistent、detached对象三者之间有什么区别？
			- 在Hibernate中，对象具有三种状态：transient、persistent和detached。同Hibernate的session有关联的对象是persistent对象。对这种对象进行的所有修改都会按照事先设定的刷新策略，反映到数据库之中，也即，可以在对象的任何一个属性发生改变时自动刷新，也可以通过调用Session.flush()方法显式地进行刷新。如果一个对象原来同Session有关联关系，但当下却没有关联关系了，这样的对象就是detached的对象。你可以通过调用任意一个session的update()或者saveOrUpdate()方法，重新将该detached对象同相应的seesion建立关联关系。Transient对象指的是新建的持久化类的实例，它还从未同Hibernate的任何Session有过关联关系。同样的，你可以调用persist()或者save()方法，将transient对象变成persistent对象。可要记住，这里所说的transient指的可不是 Java中的transient关键字，二者风马牛不相及。
		8. Hibernate中Session的lock()方法有什么作用?
			- 这是一个比较棘手的Hibernate面试问题，因为Session的lock()方法重建了关联关系却并没有同数据库进行同步和更新。因此，你在使用lock()方法时一定要多加小心。顺便说一下，在进行关联关系重建时，你可以随时使用Session的update()方法同数据库进行同步。有时这个问题也可以这么来问：Session的lock()方法和update()方法之间有什么区别？。这个小节中的关键点也可以拿来回答这个问题。
		9. Hibernate中二级缓存指的是什么？
			- 这是同Hibernate的缓存机制相关的第一个面试问题，不出意外后面还会有更多这方面的问题。二级缓存是在SessionFactory这个级别维护的缓存，它能够通过节省几番数据库调用往返来提高性能。还有一点值得注意，二级缓存是针对整个应用而不是某个特定的session的。
		10. Hibernate中的查询缓存指的是什么？
			- 这个问题有时是作为上个Hibernate面试问题的后继问题提出的。查询缓存实际上保存的是sql查询的结果，这样再进行相同的sql查询就可以之间从缓存中拿到结果了。为了改善性能，查询缓存可以同二级缓存一起来使用。Hibernate支持用多种不同的开源缓存方案，比如EhCache，来实现查询缓存。
		11. 为什么在Hibernate的实体类中要提供一个无参数的构造器这一点非常重要？
			- 每个Hibernate实体类必须包含一个 无参数的构造器, 这是因为Hibernate框架要使用Reflection API，通过调用Class.newInstance()来创建这些实体类的实例。如果在实体类中找不到无参数的构造器，这个方法就会抛出一个InstantiationException异常。
		12. 可不可以将Hibernate的实体类定义为final类?
			- 是的，你可以将Hibernate的实体类定义为final类，但这种做法并不好。因为Hibernate会使用代理模式在延迟关联的情况下提高性能，如果你把实体类定义成final类之后，因为 Java不允许对final类进行扩展，所以Hibernate就无法再使用代理了，如此一来就限制了使用可以提升性能的手段。不过，如果你的持久化类实现了一个接口而且在该接口中声明了所有定义于实体类中的所有public的方法轮到话，你就能够避免出现前面所说的不利后果。
	4. strtus
		1. struts2工作流程
			1. Struts 2框架本身大致可以分为3个部分：核心控制器FilterDispatcher、业务控制器Action和用户实现的企业业务逻辑组件。
				1. 核心控制器FilterDispatcher是Struts 2框架的基础，包含了框架内部的控制流程和处理机制。
				2. 业务控制器Action和业务逻辑组件是需要用户来自己实现的。用户在开发Action和业务逻辑组件的同时，还需要编写相关的配置文件，供核心控制器FilterDispatcher来使用。Struts 2的工作流程相对于Struts 1要简单，与WebWork框架基本相同，所以说Struts2WebWork的升级版本。
			2. 基本简要流程如下：
				1. 客户端初始化一个指向Servlet容器的请求；
				2. 这个请求经过一系列的过滤器（Filter）
					- 这些过滤器中有一个叫做ActionContextCleanUp的可选过滤器，这个过滤器对于Struts2和其他框架的集成很有帮助，例如：SiteMesh Plugin
				3. 接着FilterDispatcher被调用,FilterDispatcher询问ActionMapper来决定这个请是否需要调用某个Action
				4. 如果ActionMapper决定需要调用某个Action，FilterDispatcher把请求的处理交给ActionProxy
				5. ActionProxy通过Configuration Manager询问框架的配置文件，找到需要调用的Action类
				6. ActionProxy创建一个ActionInvocation的实例。
				7. ActionInvocation实例使用命名模式来调用，在调用Action的过程前后，涉及到相关拦截器（Intercepter）的调用。
				8. 一旦Action执行完毕，ActionInvocation负责根据struts.xml中的配置找到对应的返回结果。返回结果通常是（但不总是，也可 能是另外的一个Action链）一个需要被表示的JSP或者FreeMarker的模版。在表示的过程中可以使用Struts2 框架中继承的标签。在这个过程中需要涉及到ActionMapper
				9. 响应的返回是通过我们在web.xml中配置的过滤器
				10. 如果ActionContextCleanUp是当前使用的，则FilterDispatecher将不会清理sreadlocal ActionContext;如果ActionContextCleanUp不使用，则将会去清理sreadlocals。
		2. 说下Struts的设计模式
			- MVC模式:
				1. web应用程序启动时就会加载并初始化ActionServler。
				2. 用户提交表单时，一个配置好的ActionForm对象被创建，并被填入表单相应的数据，ActionServler根据Struts-config.xml文件配置好的设置决定是否需要表单验证，如果需要就调用ActionForm的Validate（）验证后选择将请求发送到哪个Action，如果Action不存在，ActionServlet会先创建这个对象，然后调用Action的execute（）方法.
				3. Execute（）从ActionForm对象中获取数据，完成业务逻辑，返回一个ActionForward对象，ActionServlet再把客户请求转发给ActionForward对象指定的jsp组件，ActionForward对象指定的jsp生成动态的网页，返回给客户。
		3. 拦截器和过滤器的区别
			1. 拦截器是基于java反射机制的，而过滤器是基于函数回调的。
			2. 过滤器依赖于servlet容器，而拦截器不依赖于servlet容器。
			3. 拦截器只能对Action请求起作用，而过滤器则可以对几乎所有请求起作用。
			4. 拦截器可以访问Action上下文、值栈里的对象，而过滤器不能。
			5. 在Action的生命周期中，拦截器可以多次调用，而过滤器只能在容器初始化时被调用一次。
		4. struts1于struts2的比较
			1. Action类:
				- Struts1要求Action类继承一个抽象基类。Struts1的一个普遍问题是使用抽象类编程而不是接口。
				- Struts2Action类可以实现一个Action接口，也可实现其他接口，使可选和定制的服务成为可能。Struts2提供一个ActionSupport基类去 实现常用的接口。Action接口不是必须的，任何有execute标识的POJO对象都可以用作Struts2的Action对象。
			2. 线程模式:
    			- Struts1Action是单例模式并且必须是线程安全的，因为仅有Action的一个实例来处理所有的请求。单例策略限制了Struts1   Action能作的事，并且要在开发时特别小心。Action资源必须是线程安全的或同步的。
				- Struts2Action对象为每一个请求产生一个实例，因此没有线程安全问题。（实际上，servlet容器给每个请求产生许多可丢弃的对象，并且不会导致性能和垃圾回收问题）
			3. Servlet依赖:
				- Struts1Action依赖于ServletAPI,因为当一个Action被调用时HttpServletRequest和HttpServletResponse被传递给execute方法。
				- Struts2Action不依赖于容器，允许Action脱离容器单独被测试。如果需要，Struts2Action仍然可以访问初始的request和response。但是，其他的元素减少或者消除了直接访问HttpServetRequest和HttpServletResponse的必要性。
			4. 可测性:
				- 测试Struts1Action的一个主要问题是execute方法暴露了servletAPI（这使得测试要依赖于容器）。一个第三方扩展－－StrutsTestCase－－提供了一套Struts1的模拟对象（来进行测试）。
				- Struts2Action可以通过初始化、设置属性、调用方法来测试，“依赖注入”支持也使测试更容易。
			5. 捕获输入:
				- Struts1使用ActionForm对象捕获输入。所有的ActionForm必须继承一个基类。因为其他JavaBean不能用作ActionForm，开发者经 常创建多余的类捕获输入。动态Bean（DynaBeans）可以作为创建传统ActionForm的选择，但是，开发者可能是在重新描述(创建)已经存 在的JavaBean（仍然会导致有冗余的javabean）。
				- Struts2直接使用Action属性作为输入属性，消除了对第二个输入对象的需求。输入属性可能是有自己(子)属性的rich对象类型。Action属性能够通过web页面上的taglibs访问。Struts2也支持ActionForm模式。rich对象类型，包括业务对象，能够用作输入/输出对象。这种ModelDriven特性简化了taglib对POJO输入对象的引用。
			6. 表达式语言：
				- Struts1整合了JSTL，因此使用JSTLEL。这种EL有基本对象图遍历，但是对集合和索引属性的支持很弱。
				- Struts2可以使用JSTL，但是也支持一个更强大和灵活的表达式语言－－ "Object Graph Notation Language "   (OGNL).
			7. 绑定值到页面（view）:
   				- Struts1使用标准JSP机制把对象绑定到页面中来访问。
				- Struts2使用"ValueStack "技术，使taglib能够访问值而不需要把你的页面（view）和对象绑定起来。ValueStack策略允许通过一系列名称相同但类型不同的属性重用页面（view）。
			8. 类型转换：
   				- Struts1ActionForm属性通常都是String类型。Struts1使用Commons-Beanutils进行类型转换。每个类一个转换器，对每一个实例来说是不可配置的。
				- Struts2使用OGNL进行类型转换。提供基本和常用对象的转换器。
			9. 校验：
				- Struts1支持在ActionForm的validate方法中手动校验，或者通过CommonsValidator的扩展来校验。同一个类可以有不同的校验内容，但不能校验子对象。
				- Struts2支持通过validate方法和XWork校验框架来进行校验。XWork校验框架使用为属性类类型定义的校验和内容校验，来支持chain校验子属性
			10. Action执行的控制：
				- Struts1支持每一个模块有单独的RequestProcessors（生命周期），但是模块中的所有Action必须共享相同的生命周期。
				- Struts2支持通过拦截器堆栈（Interceptor   Stacks）为每一个Action创建不同的生命周期。堆栈能够根据需要和不同的Action一起使用。
		5. 为什么要使用Struts2
			- Struts2 是一个相当强大的Java Web开源框架，是一个基于POJO的Action的MVC Web框架。它基于当年的Webwork和XWork框架，继承其优点，同时做了相当的改进。
			- 原因
				1. Struts2基于MVC架构
					- 框架结构清晰，开发流程一目了然，开发人员可以很好的掌控开发的过程。
				2. 使用OGNL进行参数传递
					- OGNL提供了在Struts2里访问各种作用域中的数据的简单方式，你可以方便的获取Request，Attribute，Application，Session，Parameters中的数据。大大简化了开发人员在获取这些数据时的代码量。
				3. 强大的拦截器
					- Struts2 的拦截器是一个Action级别的AOP，Struts2中的许多特性都是通过拦截器来实现的，例如异常处理，文件上传，验证等。拦截器是可配置与重用的，可以将一些通用的功能如：登录验证，权限验证等置于拦截器中以完成一些Java Web项目中比较通用的功能。在我实现的的一Web项目中，就是使用Struts2的拦截器来完成了系统中的权限验证功能。
				4. 易于测试
					- Struts2的Action都是简单的POJO，这样可以方便的对Struts2的Action编写测试用例，大大方便了5Java Web项目的测试。
					- 易于扩展的插件机制在Struts2添加扩展是一件愉快而轻松的事情，只需要将所需要的Jar包放到WEB-INF/lib文件夹中，在struts.xml中作一些简单的设置就可以实现扩展。
				5. 模块化管理
					- Struts2已经把模块化作为了体系架构中的基本思想，可以通过三种方法来将应用程序模块化：将配置信息拆分成多个文件把自包含的应用模块创建为插件创建新的框架特性，即将与特定应用无关的新功能组织成插件，以添加到多个应用中去。
				6. 全局结果与声明式异常
					- 为应用程序添加全局的Result，和在配置文件中对异常进行处理，这样当处理过程中出现指定异常时，可以跳转到特定页面。
			- 他的如此之多的优点，是很多人比较的青睐，与spring ,Hibernate进行结合，组成了现在比较流行的ssh框架，当然每个公司都要自己的框架，也是ssh变异的产品。
		6. struts2有哪些优点？
			1. 在软件设计上Struts2的应用可以不依赖于Servlet API和struts API。 Struts2的这种设计属于无侵入式设计；
			2. 拦截器，实现如参数拦截注入等功能；
			3. 类型转换器，可以把特殊的请求参数转换成需要的类型；
			4. 多种表现层技术，如：JSP、freeMarker、Velocity等；
			5. Struts2的输入校验可以对指定某个方法进行校验；
			6. 提供了全局范围、包范围和Action范围的国际化资源文件管理实现
		7. struts2是如何启动的？
			1. struts2框架是通过Filter启动的，即StrutsPrepareAndExecuteFilter，此过滤器为struts2的核心过滤器； 
			2. StrutsPrepareAndExecuteFilter的init()方法中将会读取类路径下默认的配置文件struts.xml完成初始化操作。struts2读取到struts.xml的内容后，是将内容封装进javabean对象然后存放在内存中，以后用户的每次请求处理将使用内存中的数据，而不是每次请求都读取struts.xml文件。
		8. struts2框架的核心控制器是什么？它有什么作用？
			- Struts2框架的核心控制器是StrutsPrepareAndExecuteFilter。
			- 作用：
				- 负责拦截由<url-pattern>/*</url-pattern>指定的所有用户请求，当用户请求到达时，该Filter会过滤用户的请求。默认情况下，如果用户请求的路径 不带后缀或者后缀以.action结尾，这时请求将被转入struts2框架处理，否则struts2框架将略过该请求的处理。 可以通过常量"struts.action.extension"修改action的后缀，如： constant name="struts.action.extension" value="do"/> 如果用户需要指定多个请求后缀，则多个后缀之间以英文逗号（,）隔开。constant name="struts.action.extension" value="do,go"/>
		9. struts2配置文件的加载顺序？
			- struts.xml ——> struts.properties
			- 常量可以在struts.xml或struts.properties中配置，如果在多个文件中配置了同一个常量，则后一个文件中配置的常量值会覆盖前面文件中配置的常量值.
			- struts.xml文件的作用：通知Struts2框架加载对应的Action资源
		10. struts2常量的修改方式？
			- 常量可以在struts.xml或struts.properties中配置，两种配置方式如下：
				1. 在struts.xml文件中配置常量constant name="struts.action.extension" value="do"/>
				2. 在struts.properties中配置常量（struts.properties文件放置在src下）：struts.action.extension=dostruts2如何访问HttpServletRequest、HttpSession、ServletContext三个域对象
					- 方案一
						- HttpServletRequest request =ServletActionContext.getRequest();
						- HttpServletResponse response =ServletActionContext.getResponse();
						- HttpSession  session=   request.getSession();
						- ServletContext servletContext=ServletActionContext.getServletContext();
					- 方案二：
						- 类 implements ServletRequestAware,ServletResponseAware，SessionAware，ServletContextAware
					- 注意：框架自动传入对应的域对象
		11. struts2是如何管理action的？这种管理方式有什么好处？
			- struts2框架中使用包来管理Action，包的作用和java中的类包是非常类似的。主要用于管理一组业务功能相关的action。在实际应用中，我们应该把一组业务功能相关的Action放在同一个包下。
			- struts2中的默认包struts-default有什么作用？ 
				1. struts-default包是由struts内置的，它定义了struts2内部的众多拦截器和Result类型，而Struts2很多核心的功能都是通过这些内置的拦截器实现，如：从请求中把请求参数封装到action、文件上传和数据验证等等都是通过拦截器实现的。当包继承了struts-default包才能使用struts2为我们提供的这些功能。
				2. struts-default包是在struts-default.xml中定义，struts-default.xml也是Struts2默认配置文件。 Struts2每次都会自动加载 struts-default.xml文件。
				3. 通常每个包都应该继承struts-default包。
		12. struts2如何对指定的方法进行验证？
			1. validate()方法会校验action中所有与execute方法签名相同的方法；
			2. 要校验指定的方法通过重写validateXxx()方法实现， validateXxx()只会校验action中方法名为Xxx的方法。其中Xxx的第一个字母要大写；
			3. 当某个数据校验失败时，调用addFieldError()方法往系统的fieldErrors添加校验失败信息（为了使用addFieldError()方法，action可以继承ActionSupport）， 如果系统 的fieldErrors包含失败信息，struts2会将请求转发到名为input的result；
			4. 在input视图中可以通过<s:fielderror/>显示失败信息。
			5. 先执行validateXxxx()->validate()->如果出错了，会转发<result name="input"/>所指定的页面，如果不出错，会直接进行Action::execute()方法 
		13. struts2默认能解决get和post提交方式的乱码问题吗？
			 - 不能。struts.i18n.encoding=UTF-8属性值只能解析POST提交下的乱码问题。
		14. 请你写出struts2中至少5个的默认拦截器？
			- fileUpload
				- 提供文件上传功能
			- i18n
				- 记录用户选择的locale
			- cookies
            	- 使用配置的name,value来是指cookies
            - checkbox
            	- 添加了checkbox自动处理代码，将没有选中的checkbox的内容设定为false，而html默认情况下不提交没有选中的checkbox。
            - chain
            	- 让前一个Action的属性可以被后一个Action访问，现在和chain类型的result（）结合使用。
            - alias
            	- 在不同请求之间将请求参数在不同名字件转换，请求内容不变
		15. 值栈ValueStack的原理与生命周期？
			1. ValueStack贯穿整个 Action 的生命周期，保存在request域中，所以ValueStack和request的生命周期一样。当Struts2接受一个请求时，会迅速创建ActionContext，ValueStack，action。然后把action存放进ValueStack，所以action的实例变量可以被OGNL访问。 请求来的时候，action、ValueStack的生命开始，请求结束，action、    ValueStack的生命结束；
			2. action是多例的，和Servlet不一样，Servelt是单例的；
			3. 每个action的都有一个对应的值栈，值栈存放的数据类型是该action的实例，以及该action中的实例变量，Action对象默认保存在栈顶；
			4. ValueStack本质上就是一个ArrayList；
			5. 关于ContextMap，Struts 会把下面这些映射压入 ContextMap 中：parameters:该Map中包含当前请求的请求参数 request:该 Map 中包含当前 request 对象中的所有属性session :该 Map 中包含当前 session 对象中的所有属性application :该 Map 中包含当前 application 对象中的所有属性attr:该 Map 按如下顺序来检索某个属性: request, session, application
			6. 使用OGNL访问值栈的内容时，不需要#号，而访问request、session、application、attr时，需要加#号；
			7. 注意： Struts2中，OGNL表达式需要配合Struts标签才可以使用。如：s:property value="name"/>
			8. 在struts2配置文件中引用ognl表达式 ,引用值栈的值 ，此时使用的"$"，而不是#或者%;
		16. ActionContext、ServletContext、pageContext的区别？
			1. ActionContext是当前的Action的上下文环境，通过ActionContext可以获取到request、session、ServletContext等与Action有关的对象的引用；
			2. ServletContext是域对象，一个web应用中只有一个ServletContext，生命周期伴随整个web应用；
			3. pageContext是JSP中的最重要的一个内置对象，可以通过pageContext获取其他域对象的应用，同时它是一个域对象，作用范围只针对当前页面，当前页面结束时，pageContext销毁，生命周期是JSP四个域对象中最小的。
		17. result的type属性中有哪几种结果类型？
			- 一共10种
				- dispatcher是struts默认的结果类型，把控制权转发给应用程序里的某个资源不能把控制权转发给一个外部资源，若需要把控制权重定向到一个外部资源, 应该使用redirect结果类型redirect把响应重定向到另一个资源（包括一个外部资源）redirectAction把响应重定向到另一个Action freemarker、velocity、chain、httpheader、xslt、plainText、stream
		18. 拦截器的生命周期与工作过程？
			1. 每个拦截器都是实现了Interceptor接口的 Java 类； 
			2. init(): 该方法将在拦截器被创建后立即被调用, 它在拦截器的生命周期内只被调用一次. 可以在该方法中对相关资源进行必要的初始化；
			3. intercept(ActionInvocation invocation): 每拦截一个动作请求, 该方法就会被调用一次；
			4. destroy: 该方法将在拦截器被销毁之前被调用, 它在拦截器的生命周期内也只被调用一次；
			5. struts2中有内置了18个拦截器。
		19. struts2如何完成文件的上传？
			1. JSP页面
				1. JSP页面的上传文件的组件：<s: file name=”upload” />，如果需要一次上传多个文件, 就必须使用多个 file 标签, 但它们的名字必须是相同的，即name=“xxx”的值必须一样；
				2. 必须把表单的enctype属性设置为：multipart/form-data；
				3. 表单的方法必须为post，因为post提交的数据在消息体中，而无大小限制。
			2. 对应的action
				1. 在Action中新添加3个和文件上传相关的属性；
				2. 如果是上传单个文件, uploadImage属性的类型就是 java.io.File, 它代表被上传的文件, 第二个和第三个属性的类型是 String, 它们分别代表上传文件的文件名和文件类型，定义方式是分别是：jsp页面file组件的名称+ContentType,  jsp页面file组件的名称+FileName
				3. 如果上上传多个文件, 可以使用数组或List
		20. struts的工作原理
			1. 初始化，读取struts-config.xml、web.xml等配置文件（所有配置文件的初始化）
			2. 发送HTTP请求,客户端发送以.do结尾的请求
			3. 填充FormBean（实例化、复位、填充数据、校验、保存）
			4. 将请求转发到Action（调用Action的execute（）方法）
			5. 处理业务（可以调用后台类，返回ActionForward对象）
			6. 返回目标响应对象（从Action返回到ActionServlet）
			7. 转换Http请求到目标响应对象（查找响应，根据返回的Forward keyword）
			8. Http响应，返回到Jsp页面
		21. 用自己的话简要阐述struts2的执行流程。
			- Struts 2框架本身大致可以分为3个部分：核心控制器FilterDispatcher、业务控制器Action和用户实现的企业业务逻辑组件。
			- 核心控制器FilterDispatcher是Struts 2框架的基础，包含了框架内部的控制流程和处理机制。
			- 业务控制器Action和业务逻辑组件是需要用户来自己实现的。用户在开发Action和业务逻辑组件的同时，还需要编写相关的配置文件，供核心控制器FilterDispatcher来使用。
			- Struts 2的工作流程相对于Struts 1要简单，与WebWork框架基本相同，所以说Struts 2是WebWork的升级版本。基本简要流程如下：
				1. 客户端浏览器发出HTTP请求。
				2. 根据web.xml配置，该请求被FilterDispatcher接收。
				3. 根据struts.xml配置，找到需要调用的Action类和方法， 并通过IoC方式，将值注入给Aciton。
				4. Action调用业务逻辑组件处理业务逻辑，这一步包含表单验证。
				5. Action执行完毕，根据struts.xml中的配置找到对应的返回结果result，并跳转到相应页面。
				6. 返回HTTP响应到客户端浏览器。
				7. 它是以Webwork的设计思想为核心，吸收struts1的优点，可以说 struts2是struts1和Webwork结合的产物。
			- struts2 的工作原理图： 一个请求在Struts2框架中的处理分为以下几个步骤：
			1. 客户端发出一个指向servlet容器的请求(tomcat)；
			2. 这个请求会经过图中的几个过滤器，最后会到达FilterDispatcher过滤器。
			3. 过滤器FilterDispatcher是struts2框架的心脏，在处理用户请求时，它和请求一起相互配合访问struts2 的底层框架结构。在web容器启动时，struts2框架会自动加载配置文件里相关参数，并转换成相应的类。 如：ConfigurationManager、ActionMapper和ObjectFactory。ConfigurationManager 存有配置文件的一 些基本信息，ActionMapper存有action的配置信息。在请求过程中所有的对象（Action，Results， Interceptors，等）都是通过ObjectFactory来创建的。过滤器会通过询问ActionMapper类来查找请求中 需要用到的Action。
			4. 如果找到需要调用的Action，过滤器会把请求的处理交给ActionProxy。ActionProxy为Action的代理对象 。ActionProxy通过ConfigurationManager询问框架的配置文件，找到需要调用的Action。
			5. ActionProxy创建一个ActionInvocation的实例。ActionInvocation在ActionProxy层之下，它表示了 Action的执行状态,或者说它控制的Action的执行步骤。它持有Action实例和所有的Interceptor。
			6. ActionInvocation实例使用命名模式来调用，
				1. ActionInvocation初始化时，根据配置，加载Action相 关的所有Interceptor。
				2. 通过ActionInvocation.invoke方法调用Action实现时，执行Interceptor。在 调用Action的过程前后，涉及到相关拦截器(intercepetor)的调用。
			7. 一旦Action执行完毕，ActionInvocation负责根据struts.xml中的配置找到对应的返回结果。返回结果 通常是（但不总是，也可能是另外的一个Action链）一个需要被表示的JSP或者FreeMarker的模版。在表 示的过程中可以使用Struts2 框架中继承的标签。
6. 熟悉分布式系统的设计和应用
	1. http://blog.csdn.net/gugemichael/article/details/36688043
	2. http://blog.csdn.net/huaweitman/article/details/50526562
	3. http://www.cnblogs.com/pains/archive/2011/06/06/2073482.html
7. 熟悉分布式
	- http://blog.jobbole.com/95588/
8. 缓存
	- http://blog.csdn.net/xiaoxiaocoder/article/details/8080369
	- http://developer.51cto.com/art/201411/456219.htm
	- http://blog.csdn.net/qingtong_gu/article/details/53762178
	-  http://blog.csdn.net/duruiqi_fx/article/details/52950377
9. 消息等机制
	- http://www.cnblogs.com/jevo/archive/2013/04/12/3017518.htm
	- http://blog.csdn.net/luoweifu/article/details/45702135
	- http://blog.csdn.net/luoweifu/article/details/45568411
10. 能对分布式常用技术进行合理应用，解决问题
	- http://www.cnblogs.com/Riven-/p/6941854.html
11. 掌握多线程
12. 高性能的设计
	- http://www.360doc.com/content/16/0907/18/32626470_589132231.shtml
	- http://www.csdn.net/article/2014-06-27/2820432
	- http://6126218.blog.51cto.com/6116218/1020421

13. 编码及性能调优
	1. 尽量指定类、方法的final修饰符
		- 带有final修饰符的类是不可派生的。在Java核心API中，有许多应用final的例子，例如java.lang.String，整个类都是 final的。为类指定final修饰符可以让类不可以被继承，为方法指定final修饰符可以让方法不可以被重写。如果指定了一个类为final，则该 类所有的方法都是final的。Java编译器会寻找机会内联所有的final方法，内联对于提升Java运行效率作用重大，具体参见Java运行期优 化。此举能够使性能平均提高50%。
	2. 尽量重用对象
		- 特别是String对象的使用，出现字符串连接时应该使用StringBuilder/StringBuffer代替。由于Java虚拟机不仅要花时间生成对象，以后可能还需要花时间对这些对象进行垃圾回收和处理，因此，生成过多的对象将会给程序的性能带来很大的影响。
	3. 尽可能使用局部变量
		- 调用方法时传递的参数以及在调用中创建的临时变量都保存在栈中速度较快，其他变量，如静态变量、实例变量等，都在堆中创建，速度较慢。另外，栈中创建的变量，随着方法的运行结束，这些内容就没了，不需要额外的垃圾回收。
	4. 及时关闭流
		- Java编程过程中，进行数据库连接、I/O流操作时务必小心，在使用完毕后，及时关闭以释放资源。因为对这些大对象的操作会造成系统大的开销，稍有不慎，将会导致严重的后果。
	5. 尽量减少对变量的重复计算
		- 明确一个概念，对方法的调用，即使方法中只有一句语句，也是有消耗的，包括创建栈帧、调用方法时保护现场、调用方法完毕时恢复现场等。
	6. 尽量采用懒加载的策略，即在需要的时候才创建
	7. 慎用异常
		- 异常对性能不利。抛出异常首先要创建一个新的对象，Throwable接口的构造函数调用名为fillInStackTrace()的本地同步方 法，fillInStackTrace()方法检查堆栈，收集调用跟踪信息。只要有异常被抛出，Java虚拟机就必须调整调用堆栈，因为在处理过程中创建 了一个新的对象。异常只能用于错误处理，不应该用来控制程序流程。
	8. 不要在循环中使用try…catch…，应该把其放在最外层
	9. 如果能估计到待添加的内容长度，为底层以数组方式实现的集合、工具类指定初始长度
		- 比如ArrayList、LinkedLlist、StringBuilder、StringBuffer、HashMap、HashSet等等
		- 可以通过类（这里指的不仅仅是上面的StringBuilder）的来设定它的初始化容量，这样可以明显地提升性能。比如 StringBuilder吧，length表示当前的StringBuilder能保持的字符数量。因为当StringBuilder达到最大容量的时 候，它会将自身容量增加到当前的2倍再加2，无论何时只要StringBuilder达到它的最大容量，它就不得不创建一个新的字符数组然后将旧的字符数 组内容拷贝到新字符数组中—-这是十分耗费性能的一个操作。试想，如果能预估到字符数组中大概要存放5000个字符而不指定长度，最接近5000的2次幂 是4096，每次扩容加的2不管，那么：
			1. 在4096 的基础上，再申请8194个大小的字符数组，加起来相当于一次申请了12290个大小的字符数组，如果一开始能指定5000个大小的字符数组，就节省了一倍以上的空间
			2. 把原来的4096个字符拷贝到新的的字符数组中去
			- 这样，既浪费内存空间又降低代码运行效率。所以，给底层以数组实现的集合、工具类设置一个合理的初始化容量是错不了的，这会带来立竿见影的效果。但 是，注意，像HashMap这种是以数组+链表实现的集合，别把初始大小和你估计的大小设置得一样，因为一个table上只连接一个对象的可能性几乎为 0。初始大小建议设置为2的N次幂，如果能估计到有2000个元素，设置成new HashMap(128)、new HashMap(256)都可以。
	10. 当复制大量数据时，使用System.arraycopy()命令
	11. 乘法和除法使用移位操作
		- 用移位操作可以极大地提高性能，因为在计算机底层，对位的操作是最方便、最快的
		- 移位操作虽然快，但是可能会使代码不太好理解，因此最好加上相应的注释。
	12. 循环内不要不断创建对象引用
		- 内存中只有一份Object对象引用，每次new Object()的时候，Object对象引用指向不同的Object罢了，但是内存中只有一份，这样就大大节省了内存空间了。
	13. 基于效率和类型检查的考虑，应该尽可能使用array，无法确定数组大小时才使用ArrayList
	14. 尽量使用HashMap、ArrayList、StringBuilder，除非线程安全需要，否则不推荐使用Hashtable、Vector、StringBuffer，后三者由于使用同步机制而导致了性能开销
	15. 不要将数组声明为public static final
		- 因为这毫无意义，这样只是定义了引用为static final，数组的内容还是可以随意改变的，将数组声明为public更是一个安全漏洞，这意味着这个数组可以被外部类所改变
	16. 尽量在合适的场合使用单例
		- 使用单例可以减轻加载的负担、缩短加载的时间、提高加载的效率，但并不是所有地方都适用于单例，简单来说，单例主要适用于以下三个方面：
			1. 控制资源的使用，通过线程同步来控制资源的并发访问
			2. 控制实例的产生，以达到节约资源的目的
			3. 控制数据的共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信
	17. 尽量避免随意使用静态变量
		- 当某个对象被定义为static的变量所引用，那么gc通常是不会回收这个对象所占有的堆内存的
	18. 及时清除不再需要的会话
		- 为了清除不再活动的会话，许多应用服务器都有默认的会话超时时间，一般为30分钟。当应用服务器需要保存更多的会话时，如果内存不足，那么操作系统 会把部分数据转移到磁盘，应用服务器也可能根据MRU（最近最频繁使用）算法把部分不活跃的会话转储到磁盘，甚至可能抛出内存不足的异常。如果会话要被转 储到磁盘，那么必须要先被序列化，在大规模集群中，对对象进行序列化的代价是很昂贵的。因此，当会话不再需要时，应当及时调用HttpSession的 invalidate()方法清除会话。
	19. 实现RandomAccess接口的集合比如ArrayList，应当使用最普通的for循环而不是foreach循环来遍历
		- 这是JDK推荐给用户的。JDK API对于RandomAccess接口的解释是：实现RandomAccess接口用来表明其支持快速随机访问，此接口的主要目的是允许一般的算法更改 其行为，从而将其应用到随机或连续访问列表时能提供良好的性能。实际经验表明，实现RandomAccess接口的类实例，假如是随机访问的，使用普通 for循环效率将高于使用foreach循环；反过来，如果是顺序访问的，则使用Iterator会效率更高。可以使用类似如下的代码作判断：
			if (list instanceof RandomAccess)
			{ for (int i = 0; i < list.size(); i++){}
			}else{
			Iterator<?> iterator = list.iterable(); 			while (iterator.hasNext()){iterator.next()}
			}
			- foreach循环的底层实现原理就是迭代器Iterator，参见Java语法糖1：可变长度参数以及foreach循环原理。所以后半句”反过来，如果是顺序访问的，则使用Iterator会效率更高”的意思就是顺序访问的那些类实例，使用foreach循环去遍历。
	20. 使用同步代码块替代同步方法
		- 这点在多线程模块中的synchronized锁方法块一文中已经讲得很清楚了，除非能确定一整个方法都是需要进行同步的，否则尽量使用同步代码块，避免对那些不需要进行同步的代码也进行了同步，影响了代码执行效率。
	21. 将常量声明为static final，并以大写命名
		- 这样在编译期间就可以把这些内容放入常量池中，避免运行期间计算生成常量的值。另外，将常量的名字以大写命名也可以方便区分出常量与变量
	22. 不要创建一些不使用的对象，不要导入一些不使用的类
		- 这毫无意义，如果代码中出现”The value of the local variable i is not used”、”The import java.util is never used”，那么请删除这些无用的内容
	23. 程序运行过程中避免使用反射
		- 关于，请参见反射。反射是Java提供给用户一个很强大的功能，功能强大往往意味着效率不高。不建议在程序运行过程中使用尤其是频繁使用反射机制， 特别是Method的invoke方法，如果确实有必要，一种建议性的做法是将那些需要通过反射加载的类在项目启动的时候通过反射实例化出一个对象并放入 内存—-用户只关心和对端交互的时候获取最快的响应速度，并不关心对端的项目启动花多久时间。
	24. 使用数据库连接池和线程池
		- 这两个池都是用于重用对象的，前者可以避免频繁地打开和关闭连接，后者可以避免频繁地创建和销毁线程
	25. 使用带缓冲的输入输出流进行IO操作
		- 带缓冲的输入输出流，即BufferedReader、BufferedWriter、BufferedInputStream、BufferedOutputStream，这可以极大地提升IO效率
	26. 顺序插入和随机访问比较多的场景使用ArrayList，元素删除和中间插入比较多的场景使用LinkedList
		- ArrayList和LinkedList的原理
	27. 不要让public方法中有太多的形参
		- public方法即对外提供的方法，如果给这些方法太多形参的话主要有两点坏处：
			1. 违反了面向对象的编程思想，Java讲求一切都是对象，太多的形参，和面向对象的编程思想并不契合
			2. 参数太多势必导致方法调用的出错概率增加
			- 至于这个”太多”指的是多少个，3、4个吧。比如我们用JDBC写一个insertStudentInfo方法，有10个学生信息字段要插如Student表中，可以把这10个参数封装在一个实体类中，作为insert方法的形参
	28. 字符串变量和字符串常量equals的时候将字符串常量写在前面
		- 可以避免空指针异常
	29. 请知道，在java中if (i == 1)和if (1 == i)是没有区别的，但从阅读习惯上讲，建议使用前者
		- 避免开发者在if语句中不正确的赋值操作
	30. 不要对数组使用toString()方法
		1. 整型默认的数据类型是int，long l = 12345678901234L，这个数字已经超出了int的范围了，所以最后有一个L，表示这是一个long型数。顺便，浮点型的默认类型是 double，所以定义float的时候要写成”"float f = 3.5f”
		2. 接下来再写一句”int ii = l + i;”会报错，因为long + int是一个long，不能赋值给int
	31. 不要对超出范围的基本数据类型做向下强制转型
		- 如果一个集合类是公用的（也就是说不是方法里面的属性），那么这个集合里面的元素是不会自动释放的，因为始终有引用指向它们。所以，如果公用集合里面的某些数据不使用而不去remove掉它们，那么将会造成这个公用集合不断增大，使得系统有内存泄露的隐患。
	32. 把一个基本数据类型转为字符串，基本数据类型.toString()是最快的方式、String.valueOf(数据)次之、数据+”"最慢
		1. String.valueOf()方法底层调用了Integer.toString()方法，但是会在调用前做空判断
		2. Integer.toString()方法就不说了，直接调用了
		3. i + “”底层使用了StringBuilder实现，先用append方法拼接，再用toString()方法获取字符串
		- 三者对比下来，明显是2最快、1次之、3最慢
	33. 使用最有效率的方式去遍历Map
		- 如果你只是想遍历一下这个Map的key值，那用”Set,String> keySet = hm.keySet();”会比较合适一些
	34. 对资源的close()建议分开操作
		- 虽然有些麻烦，却能避免资源泄露。我们想，如果没有修改过的代码，万一XXX.close()抛异常了，那么就进入了cath块中 了，YYY.close()不会执行，YYY这块资源就不会回收了，一直占用着，这样的代码一多，是可能引起资源句柄泄露的。而改为下面的写法之后，就保 证了无论如何XXX和YYY都会被close掉。
14. 有高并发应用开发经验
	- 无
15. 掌握Linux 操作系统
	1. 如何查看当前的Linux服务器的运行级别？
		- 'who -r' 和 'runlevel' 命令可以用来查看当前的Linux服务器的运行级别。
	2. 如何查看Linux的默认网关？
		- 用 "route -n" 和 "netstat -nr" 命令，我们可以查看默认网关。除了默认的网关信息，这两个命令还可以显示当前的路由表。
	3. 如何在Linux上重建初始化内存盘镜像文件？
		- 在CentOS 5.X / RHEL 5.X中，可以用mkinitrd命令来创建初始化内存盘文件
			- # mkinitrd -f -v /boot/initrd-$(uname -r).img $(uname -r)
			- 如果你想要给特定的内核版本创建初始化内存盘，你就用所需的内核名替换掉 'uname -r'
		- 在CentOS 6.X / RHEL 6.X中，则用dracut命令来创建初始化内存盘文件
			- # dracut -f
			- 以上命令能给当前的系统版本创建初始化内存盘，给特定的内核版本重建初始化内存盘文件则使用以下命令
			- # dracut -f initramfs-2.x.xx-xx.el6.x86_64.img 2.x.xx-xx.el6.x86_64
	4. cpio命令是什以上命令能给当前的系统版本创建初始化内存盘，给特定的内核版本重建初始化内存盘文件则使用以下命令么？
		- cpio就是复制入和复制出的意思。cpio可以向一个归档文件（或单个文件）复制文件、列表，还可以从中提取文件。
	5. patch命令是什么？如何使用？
		- 顾名思义，patch命令就是用来将修改（或补丁）写进文本文件里。patch命令通常是接收diff的输出并把文件的旧版本转换为新版本。举个例子，Linux内核源代码由百万行代码文件构成，所以无论何时，任何代码贡献者贡献出代码，只需发送改动的部分而不是整个源代码，然后接收者用patch命令将改动写进原始的源代码里。
		- 创建一个diff文件给patch使用
			- # diff -Naur old_file new_file > diff_file

	6. aspell有什么用 ?
		- 顾名思义，aspell就是Linux操作系统上的一款交互式拼写检查器。aspell命令继任了更早的一个名为ispell的程序，并且作为一款免费替代品 ，最重要的是它非常好用。当aspell程序主要被其它一些需要拼写检查能力的程序所使用的时候，在命令行中作为一个独立运行的工具的它也能十分有效。
	7. 如何从命令行查看域SPF记录？
		- 我们可以用dig命令来查看域SPF记录。
		- dig -t TXT google.com
	8. 如何识别Linux系统中指定文件(/etc/fstab)的关联包？
		- # rpm -qf /etc/fstab
	9. 哪条命令用来查看bond0的状态？
		- cat /proc/net/bonding/bond0
	10. Linux系统中的/proc文件系统有什么用？
		-  /proc文件系统是一个基于内存的文件系统，其维护着关于当前正在运行的内核状态信息，其中包括CPU、内存、分区划分、I/O地址、直接内存访问通道和正在运行的进程。这个文件系统所代表的并不是各种实际存储信息的文件，它们指向的是内存里的信息。/proc文件系统是由系统自动维护的。
	11. 如何在/usr目录下找出大小超过10MB的文件？
		- # find /usr -size +10M
	12. 如何在/home目录下找出120天之前被修改过的文件？
		- # find /home -mtime +120
	13. 如何在/var目录下找出90天之内未被访问过的文件？
		- # find /var \! -atime -90
	14. 在整个目录树下查找文件"core"，如发现则无需提示直接删除它们。
		- # find / -name core -exec rm {} \;
	15. strings命令有什么作用？
		- strings命令用来提取和显示非文本文件中的文本字符串。（LCTT 译注：当用来分析你系统上莫名其妙出现的二进制程序时，可以从中找到可疑的文件访问，对于追查入侵有用处）
	16. tee 过滤器有什么作用 ?
		- tee 过滤器用来向多个目标发送输出内容。如果用于管道的话，它可以将输出复制一份到一个文件，并复制另外一份到屏幕上（或一些其它程序）。
	17. export PS1 = "$LOGNAME@hostname:\$PWD:" 这条命令是在做什么？
		- 这条export命令会更改登录提示符来显示用户名、本机名和当前工作目录。
	18. ll | awk '{print $3,"owns",$9}' 这条命令是在做什么？
		- 这条ll命令会显示这些文件的文件名和它们的拥有者。
	19. Linux中的at命令有什么用？
		- at命令用来安排一个程序在未来的做一次一次性执行。所有提交的任务都被放在 /var/spool/at 目录下并且到了执行时间的时候通过atd守护进程来执行。
	20. linux中lspci命令的作用是什么？
		- spci命令用来显示你的系统上PCI总线和附加设备的信息。指定-v，-vv或-vvv来获取越来越详细的输出，加上-r参数的话，命令的输出则会更具有易读性。
16. 大型数据库（Oracle、MySql）
	- oracle
	- mysql
        1. 主键 超键 候选键 外键
        	- 主键
        		- 数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。
        	- 超键
        		- 在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。
        	- 候选键
        		- 是最小超键，即没有冗余元素的超键。
        	- 外键
        		- 在一个表中存在的另一个表的主键称此表的外键。
        2. 数据库事务的四个特性及含义
        	- 数据库事务transanction正确执行的四个基本要素。ACID,原子性(Atomicity)、一致性(Correspondence)、隔离性(Isolation)、持久性(Durability)。
        		- 原子性
        			- 整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。
        		- 一致性
        			- 在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。
        		- 隔离性
        			- 隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，执行 相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。这种属性有时称为串行化，为了防止事务操作间的混淆，必须串行化或序列化请 求，使得在同一时间仅有一个请求用于同一数据。
        		- 持久性
        			- 在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。
        3. 视图的作用，视图可以更改么？
        	- 视图是虚拟的表，与包含数据的表不一样，视图只包含使用时动态检索数据的查询；不包含任何列或数据。使用视图可以简化复杂的sql操作，隐藏具体的细节，保护数据；视图创建后，可以使用与表相同的方式利用它们。
        	- 视图不能被索引，也不能有关联的触发器或默认值，如果视图本身内有order by 则对视图再次order by将被覆盖。
        	- 创建视图：create view XXX as XXXXXXXXXXXXXX;
        	-  对于某些视图比如未使用联结子查询分组聚集函数Distinct Union等，是可以对其更新的，对视图的更新将对基表进行更新；但是视图主要用于简化检索，保护数据，并不用于更新，而且大部分视图都不可以更新。
        4. drop,delete与truncate的区别
        	- drop直接删掉表 truncate删除表中数据，再插入时自增长id又从1开始 delete删除表中数据，可以加where字句。
				1. DELETE语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行进行回滚操作。TRUNCATE TABLE 则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除行是不能恢复的。并且在删除的过程中不会激活与表有关的删除触发器。执行速度快。
				2. 表和索引所占空间。当表被TRUNCATE 后，这个表和索引所占用的空间会恢复到初始大小，而DELETE操作不会减少表或索引所占用的空间。drop语句将表所占用的空间全释放掉。
				3. 一般而言，drop > truncate > delete
				4. 应用范围。TRUNCATE 只能对TABLE；DELETE可以是table和view
				5. TRUNCATE 和DELETE只删除数据，而DROP则删除整个表（结构和数据）。
				6. truncate与不带where的delete ：只删除数据，而不删除表的结构（定义）drop语句将删除表的结构被依赖的约束（constrain),触发器（trigger)索引（index);依赖于该表的存储过程/函数将被保留，但其状态会变为：invalid。
				7. delete语句为DML（data maintain Language),这个操作会被放到 rollback segment中,事务提交后才生效。如果有相应的 tigger,执行的时候将被触发。
				8. truncate、drop是DLL（data define language),操作立即生效，原数据不放到 rollback segment中，不能回滚
				9. 在没有备份情况下，谨慎使用 drop 与 truncate。要删除部分数据行采用delete且注意结合where来约束影响范围。回滚段要足够大。要删除表用drop;若想保留表而将表中数据删除，如果于事务无关，用truncate即可实现。如果和事务有关，或老师想触发trigger,还是用delete。
				10. Truncate table 表名 速度快,而且效率高,因为:
					- truncate table 在功能上与不带 WHERE 子句的 DELETE 语句相同：二者均删除表中的全部行。但 TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少。DELETE 语句每次删除一行，并在事务日志中为所删除的每行记录一项。TRUNCATE TABLE 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。
				11. TRUNCATE TABLE 删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用 DELETE。如果要删除表定义及其数据，请使用 DROP TABLE 语句。
				12. 对于由 FOREIGN KEY 约束引用的表，不能使用 TRUNCATE TABLE，而应使用不带 WHERE 子句的 DELETE 语句。由于 TRUNCATE TABLE 不记录在日志中，所以它不能激活触发器。
        5. 索引的工作原理及其种类
        	- 数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。
        	- 在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。
        	- 为表设置索引要付出代价的：一是增加了数据库的存储空间，二是在插入和修改数据时要花费较多的时间(因为索引也要随之变动)。
			![2015041610033731.png](./2015041610033731.png)
            - 图展示了一种可能的索引方式。左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在O(log2n)的复杂度内获取到相应数据。
            - 创建索引可以大大提高系统的性能。
            	1. 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。
            	2. 可以大大加快数据的检索速度，这也是创建索引的最主要的原因。
            	3. 可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。
            	4. 在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。
            	5. 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。
            - 也许会有人要问：增加索引有如此多的优点，为什么不对表中的每一个列创建一个索引呢？因为，增加索引也有许多不利的方面。
            	1. 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。
            	2. 索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。
            	3. 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。
			- 索引是建立在数据库表中的某些列的上面。在创建索引的时候，应该考虑在哪些列上可以创建索引，在哪些列上不能创建索引。一般来说，应该在这些列上创建索引：在经常需要搜索的列上，可以加快搜索的速度；在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。
			- 同样，对于有些列不应该创建索引。一般来说，不应该创建索引的的这些列具有下列特点：
				1. 对于那些在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。
				2. 对于那些只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。
				3. 对于那些定义为text, image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。
				4. 当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。
			- 根据数据库的功能，可以在数据库设计器中创建三种索引：唯一索引、主键索引和聚集索引。
			- 唯一索引
			- 唯一索引是不允许其中任何两行具有相同索引值的索引。
				- 当现有数据中存在重复的键值时，大多数数据库不允许将新创建的唯一索引与表一起保存。数据库还可能防止添加将在表中创建重复键值的新数据。例如，如果在employee表中职员的姓(lname)上创建了唯一索引，则任何两个员工都不能同姓。 主键索引 数据库表经常有一列或列组合，其值唯一标识表中的每一行。该列称为表的主键。 在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问。 聚集索引 在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引。
				- 如果某索引不是聚集索引，则表中行的物理顺序与键值的逻辑顺序不匹配。与非聚集索引相比，聚集索引通常提供更快的数据访问速度。
			- 局部性原理与磁盘预读
				- 由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用。程序运行期间所需要的数据通常比较集中。
				- 由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。
				- 预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。
			- B-/+Tree索引的性能分析
				- 到这里终于可以分析B-/+Tree索引的性能了。
				- 上文说过一般使用磁盘I/O次数评价索引结构的优劣。先从B-Tree分析，根据B-Tree的定义，可知检索一次最多需要访问h个节点。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：
				- 每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。
				- B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O(h)=O(logdN)。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。
				- 而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。
				- 综上所述，用B-Tree作为索引结构效率是非常高的。
        6. mysql_fetch_row()和mysql_fetch_array()的区别 
        	- 这两个函数，返回的都是一个数组，区别就是第一个函数返回的数组是只包含值，我们只能row[0],row[1],这样以数组下标来读取数据，而mysql_fetch_array()返回的数组既包含第一种，也包含键值对的形式，我们可以这样读取数据，（假如数据库的字段是 username,passwd）:row[‘username‘],row[‘passwd‘。
        7. 数据库范式
        	1. 第一范式（1NF）
        		- 在任何一个关系数据库中，第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库。
        		- 所谓第一范式（1NF）是指数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之间为一对多关系。在第一范式（1NF）中表的每一行只包含一个实例的信息。简而言之，第一范式就是无重复的列。
        	2. 第二范式（2NF）
				- 第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求数据库表中的每个实例或行必须可以被惟一地区分。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被称为主关键字或主键、主码。
				- 第二范式（2NF）要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。简而言之，第二范式就是非主属性非部分依赖于主关键字。
			3. 第三范式（3NF）
				- 满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。简而言之，第三范式就是属性不依赖于其它非主属性。（我的理解是消除冗余）

        8. 数据库优化的思路
        	1. SQL语句优化
        		1. 应尽量避免在 where 子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描。
        		2. 应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：
					select id from t where num is null
					可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：
					select id from t where num=0
                3. 很多时候用 exists 代替 in 是一个好的选择
                4. 用Where子句替换HAVING 子句 因为HAVING 只会在检索出所有记录之后才对结果集进行过滤

			2. 索引优化
			3. 数据库结构优化
				1. 范式优化： 比如消除冗余（节省空间。。）
				2. 反范式优化：比如适当加冗余等（减少join
				3. 拆分表： 分区将数据在物理上分隔开，不同分区的数据可以制定保存在处于不同磁盘上的数据文件里。这样，当对这个表进行查询时，只需要在表分区中进行扫描，而不必进行全表扫描，明显缩短了查询时间，另外处于不同磁盘的分区也将对这个表的数据传输分散在不同的磁盘I/O，一个精心设置的分区可以将数据传输对磁盘I/O竞争均匀地分散开。对数据量大的时时表可采取此方法。可按月自动建表分区。
				4. 拆分其实又分垂直拆分和水平拆分：
					- 案例： 简单购物系统暂设涉及如下表：
						1. 产品表（数据量10w，稳定）
						2. 订单表（数据量200w，且有增长趋势）
						3. 用户表 （数据量100w，且有增长趋势） 以mysql为例讲述下水平拆分和垂直拆分，mysql能容忍的数量级在百万静态数据可以到千万 垂直拆分：解决问题：表与表之间的io竞争 不解决问题：单表中数据量增长出现的压力 方案： 把产品表和用户表放到一个server上 订单表单独放到一个server上 水平拆分： 解决问题：单表中数据量增长出现的压力 不解决问题：表与表之间的io争夺
						- 方案： 用户表通过性别拆分为男用户表和女用户表 订单表通过已完成和完成中拆分为已完成订单和未完成订单 产品表 未完成订单放一个server上 已完成订单表盒男用户表放一个server上 女用户表放一个server上(女的爱购物 哈哈)
        9. 存储过程与触发器的区别
        	- 触发器与存储过程非常相似，触发器也是SQL语句集，两者唯一的区别是触发器不能用EXECUTE语句调用，而是在用户执行Transact-SQL语句时自动触发（激活）执行。触发器是在一个修改了指定表中的数据时执行的存储过程。通常通过创建触发器来强制实现不同表中的逻辑相关数据的引用完整性和一致性。由于用户不能绕过触发器，所以可以用它来强制实施复杂的业务规则，以确保数据的完整性。触发器不同于存储过程，触发器主要是通过事件执行触发而被执行的，而存储过程可以通过存储过程名称名字而直接调用。当对某一表进行诸如UPDATE、INSERT、DELETE这些操作时，SQLSERVER就会自动执行触发器所定义的SQL语句，从而确保对数据的处理必须符合这些SQL语句所定义的规则。
        10. 如果发现CPU，或者IO压力很大，怎么定位问题？
        	1. 首先我会用top命令和iostat命令，定位是什么进程在占用cpu和磁盘io；
        	2. 如果是mysql的问题，我会登录到数据库，通过show full processlist命令，看现在数据库在执行什么sql语句，是否有语句长时间执行使数据库卡住；
        	3. 执行show innodb engine status命令，查看数据库是否有锁资源争用；
        	4. 查看mysql慢查询日志，看是否有慢sql；
        	5. 找到引起数据库占用资源高的语句，进行优化，该建索引的建索引，索引不合适的删索引，或者根据情况kill掉耗费资源的sql语句等
        11. mysql的权限怎么管理？
        	- 给insert,update，select和delete四个权限即可。有时候delete都不给。
        12. 新创建的数据库，需要调整哪些参数？
        	- 调整两方面的参数，即调整操作系统的和数据库my.cnf的：
        		1. 操作系统的参数
      				- linux参数系统的默认参数很多都是很保守的，所以需要根据服务器性能将一些参数进行加大，如我会调整nofile（最大文件句柄数）和nproc（最大线程数），将其放到最大；我会将vm.swappiness设置为0，表示最大限度使用物理内存，然后才是 swap空间；我会将net.ipv4.tcp_tw_reuse 设置为1，表示将netstat中出现的TIME-WAIT状态的sockets重用到新的TCP连接上...等等
  				2. 数据库的参数
					- 对于mysql来说，my.cnf的参数调整非常重要，如果采用默认值，那么是很难发挥mysql性能的。一般我会特别关注innodb_buffer_pool这个值，该值一般设置为物理内存的70%,这样就可以把mysql的表和索引最大限度的load到内存中，从而使mysql数据库性能得到大的提升；另外，我还特别关注sync_binlog和innodb_flush_log_at_trx_commit这两个值的设置，具体含义见上；还有max_user_connections ，我一般将该值设置为2000；还有innodb_lock_wait_timeout，看程序是长连接还是短连接，一般我会设置为60秒；还有innodb_log_file_size ，这个值也设置的大一点，我一般设置的为500M或1G。
        13. sql语句应该考虑哪些安全性？
        	1. 防止sql注入，对特殊字符进行转义，过滤或者使用预编译的sql语句绑定变量。
        	2. 最小权限原则，特别是不要用root账户，为不同的类型的动作或者组建使用不同的账户。
        	3. 当sql运行出错时，不要把数据库返回的错误信息全部显示给用户，以防止泄漏服务器和数据库相关信息。
        14. Innodb是行锁，那什么时候会产生行锁，什么情况下会变成表锁？
        	- 一般情况下，innodb只对指定的行进行锁定，其他进程还是可以对表中的其他行进行操作的，因此，这时候innodb加的就是行锁；
   			- 但是，如果在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表，例如update table set num=1 where name like “%aaa%”。
        15. 如果insert等dml语句的性能有问题的话，或者其他问题的存在，可能造成同步延迟，所以如何有效避免同步延迟的出现？
        	- MySQL主从同步延迟的最主要原因就是主库是多线程写，而从库只有一个线程（即slave_sql_running）来同步，所以在主库中如果有一个ddl或dml操作执行10分钟，那么这个操作在从库上同样需要执行10分钟。有人可能会问：“主库上那个相同的DDL、DML也需要执行10分，为什么slave会延时？”，答案是master可以并发，Slave_SQL_Running线程却不可以。
			- 所以，为了减少从库的延时，我们需要平时做好以下维护：
				1. 尽量让主库的dml或者ddl快速执行，如提高insert的效率（方法见上）；
				2. 为了安全，有人可能会将主库的sync_binlog设置为1，innodb_flush_log_at_trx_commit也设置为1之类的，而slave则不需要这么高的数据安全，完全可以讲sync_binlog设置为0或者关闭binlog，innodb_flushlog也可以设置为0，来提高从库sql的执行效率。
					- 备注：sync_binlog是控制binlog_cache刷新到磁盘binlog频率的，而innodb_flush_log_at_trx_commit是控制redo log buffer刷新到磁盘redolog频率的。sync_binlog=0，表示MySQL不控制binlog的刷新，由文件系统自己控制它的缓存的刷新。如果sync_binlog>0，表示每sync_binlog次事务提交，MySQL调用文件系统的刷新操作将缓存刷下去。最安全的就是sync_binlog=1了，表示每次事务提交，MySQL都会把binlog刷下去。这样的话，在数据库所在的主机操作系统损坏或者突然掉电的情况下，系统才有可能丢失1个事务的数据。所以sync_binlog=1保证了数据安全，但是性能最差。）
				3. 使用比主库更好的硬件设备作为slave
				4. 使用mysql 5.6新参数 slave_parallel_workers ，使从库多线程，不过，slave_parallel_workers只能支持一个实例下多个 database 间的并发复制，并不能真正做到多表并发复制。因此在较大并发负载时，slave还是没有办法及时追上master，需要想办法进行优化。
				5. 升级Mysql到5.7，因为mysql 5.7支持真正意义的从库多线程了，即主库多少线程，从库也多少线程。mysql 5.7号称主从复制永不丢数据（一直没时间试用过）。
        16. 如何提高insert的性能？
        	- 有如下方法：
        		1. 合并多条 insert 为一条，即： insert into t values(a,b,c),  (d,e,f) ,,,
        			- 原因分析：主要原因是多条insert合并后日志量（MySQL的binlog和innodb的事务让日志） 减少了，降低日志刷盘的数据量和频率，从而提高效率。通过合并SQL语句，同时也能减少SQL语句解析的次数，减少网络传输的IO。
        		2. 修改参数 bulk_insert_buffer_size，调大批量插入的缓存；
        		3. 设置 innodb_flush_log_at_trx_commit = 0 ，相对于 innodb_flush_log_at_trx_commit = 1 可以十分明显的提升导入速度；
      				- 备注：innodb_flush_log_at_trx_commit 参数对 InnoDB Log 的写入性能有非常关键的影响。该参数可以设置为0，1，2，解释如下：
						1. log buffer中的数据将以每秒一次的频率写入到log file中，且同时会进行文件系统到磁盘的同步操作，但是每个事务的commit并不会触发任何log buffer 到log file  的刷新或者文件系统到磁盘的刷新操作;
						2. 在每次事务提交的时候将log buffer 中的数据都会写入到log file，同时也会触发文件系统到磁盘的同步;
						3. 事务提交会触发log buffer 到log file的刷新，但并不会触发磁盘文件系统到磁盘的同步。此外，每秒会有一次文件系统到磁盘同步操作。
				4. 手动使用事务
           因为mysql默认是autocommit的，这样每插入一条数据，都会进行一次commit；所以，为了减少创建事务的消耗，我们可用手工使用事务，即START TRANSACTION;insert 。。,insert。。 commit；即执行多个insert后再一起提交；一般1000条insert 提交一次。
17. 对sql优化有丰富的经验
	1. 尽量避免耗时操作
		- 带有DISTINCT,UNION,MINUS,INTERSECT,ORDER BY的SQL语句会启动SQL引 执行，耗费资源的排序(SORT)功能。DISTINCT需要一次排序操作, 而其他的至少需要执行两次排序
	2. 如果无需排除重复值或是操作集无重复则用UNION ALL， UNION更费事（因为要比较）
		- 如果无需排除重复值或是操作集无重复则用UNION ALL， UNION更费事（因为要比较）
		- UNION因为会将各查询子集的记录做比较，故比起UNION ALL ，通常速度都会慢上许多。一般来说，如果使用UNION ALL能满足要求的话， 务必使用UNION ALL。还有一种情况大家可能会忽略掉，就是虽然要求几个子集的并集需要过滤掉重复记录，但由于脚本的特殊性，不可能存在重复记录，这时便应该使用UNION ALL，如xx模块的某个查询程序就曾经存在这种情况，见，由于语句的特殊性，在这个脚本中几个子集的记录绝对不可能重复，故可以改用UNION ALL）连接操作
	3. 避免在WHERE子句中使用in，not  in，or 或者having。
		- 可以使用 exist 和not exist代替 in和not in。
		- 可以使用表链接代替 exist。
		- Having可以用where代替，如果无法代替可以分两步处理。
	4. 不要在建立的索引的数据列上进行下列操作
		1. 避免对索引字段进行计算操作
		2. 避免在索引字段上使用not，<>，!=
		3. 避免在索引列上使用IS NULL和IS NOT NULL
		4. 避免在索引列上出现数据类型转换
		5. 避免在索引字段上使用函数
			- 例如：where trunc(create_date)=trunc(:date1)
			- 虽然已对create_date 字段建了索引，但由于加了TRUNC，使得索引无法用上。此处正确的写法应该是
			- where create_date>=trunc(:date1) and create_date
		6. 避免建立索引的列中使用空值。
	5. 查询的模糊匹配
		- 尽量避免在一个复杂查询里面使用 LIKE '%parm1%'—— 红色标识位置的百分号会导致相关列的索引无法使用，最好不要用。
		- 解决办法:
			- 其实只需要对该脚本略做改进，查询速度便会提高近百倍。改进方法如下：
				1. 修改前台程序——把查询条件的供应商名称一栏由原来的文本输入改为下拉列表，用户模糊输入供应商名称时，直接在前台就帮忙定位到具体的供应商，这样在调用后台程序时，这列就可以直接用等于来关联了。
				2. 直接修改后台——根据输入条件，先查出符合条件的供应商，并把相关记录保存在一个临时表里头，然后再用临时表去做复杂关联
	6. 避免使用临时表
		1. 除非却有需要，否则应尽量避免使用临时表，相反，可以使用表变量代替;
		2. 大多数时候(99%)，表变量驻扎在内存中，因此速度比临时表更快，临时表驻扎在TempDb数据库中，因此临时表上的操作需要跨数据库通信，速度自然慢。
			- 可以使用联合(UNION)来代替手动创建的临时表
			- MySQL 从 4.0 的版本开始支持 UNION 查询，它可以把需要使用临时表的两条或更多的 SELECT 查询合并的一个查询中。在客户端的查询会话结束的时候，临时表会被自动删除，从而保证数据库整齐、高效。使用 UNION 来创建查询的时候，我们只需要用UNION作为关键字把多个SELECT语句连接起来就可以了，要注意的是所有 SELECT 语句中的字段数目要想同。下面的例子就演示了一个使用 UNION的查询。
	7. 尽量少做重复的工作
		- 尽量减少无效工作，但是这一点的侧重点在客户端程序，需要注意的如下：
			1.  控制同一语句的多次执行，特别是一些基础数据的多次执行是很多程序员很少注意的
			2.  减少多次的数据转换，也许需要数据转换是设计的问题，但是减少次数是程序员可以做到的。
			3.  杜绝不必要的子查询和连接表，子查询在执行计划一般解释成外连接，多余的连接表带来额外的开销。
			4.  合并对同一表同一条件的多次UPDATE，比如
				- UPDATE EMPLOYEE SET FNAME='HAIWER' WHERE EMP_ID=' VPA30890F'
				- UPDATE EMPLOYEE SET LNAME='YANG' WHERE EMP_ID=' VPA30890F'
				- 这两个语句应该合并成以下一个语句
				- UPDATE EMPLOYEE SET FNAME='HAIWER',LNAME='YANG'
				- WHERE EMP_ID=' VPA30890F'
			5. UPDATE操作不要拆成DELETE操作+INSERT操作的形			式，虽然功能相同，但是性能差别是很大的。
			6. 不要写一些没有意义的查询，比如
				- SELECT * FROM EMPLOYEE WHERE 1=2
				- Where后面的原则
					1. 在where子句中应把最具限制性的条件放在最前面。
					2. where子句中字段的顺序应和索引中字段顺序一致。
					- select field3,field4 from tb where upper(field2)='RMN'不使用索引。
					- 如果一个表有两万条记录，建议不使用函数；如果一个表有五万条以上记录，严格禁止使用函数！两万条记录以下没有限制。

18. 学习能力强，适应能力好，有强烈的责任心，具备耐心/细心的品质；
19. 最后,参考博客：
	- http://www.cnblogs.com/zuoxiaolong/p/life51.html
































