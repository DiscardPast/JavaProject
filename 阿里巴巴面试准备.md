# 阿里巴巴Java开发工程师(资深/专家)面试准备
## 面试邀请邮件
强鹏阳，您好！
非常高兴的通知您，胡颖于2017-10-13推荐您应聘阿里巴巴职位：业务平台-JAVA研发工程师／专家-杭州。我们会在10个工作日内处理，请您耐心等待。
您应聘的职位详情如下：
职位名称：业务平台-JAVA研发工程师／专家-杭州
职位描述：业务平台事业部，是阿里巴巴电子商务操作系统的基石，是中台战略的主阵地，由会员、商品、交易、店铺、资金、拍卖、数据等多个核心业务平台组成，旨在提供简单可信赖的电商技术基础产品，高效高质量地支持阿里巴巴集团业务的全球化布局和创新性发展。 为承接集团的中台及全球化战略，业务平台事业部需要和更多有志之士携手，在平台的可靠、高效、易扩展方面进行探索，如果你对复杂的业务场景有经验，对技术的深度有追求，对商业的本质感兴趣，欢迎加入阿里巴巴业务平台事业部。 1.负责具体业务功能的开发（拍卖、会员、商品、交易、店铺、资金等），深入发掘业务需求，独当一面，包括需求分析、架构设计和代码实现； 2.持续优化系统架构，提高系统在高并发、大流量下的容灾容错能力，保证系统的高可用性（性能、安全、容量）； 3.通过梳理和抽象，沉淀通用性的平台或服务能力，发现和解决存在的技术问题，并在具体的业务场景中进行验证推广；
职位要求：1. 本科及以上学历，计算机软件或相关专业； 2. 3年及以上使用JAVA开发的经验，JAVA基础扎实，理解io、多线程、集合等基础框架，对JVM原理有一定的了解，对Spring,ibatis,struts等开源框架熟悉； 3. 熟悉分布式系统的设计和应用，熟悉分布式、缓存、消息等机制；能对分布式常用技术进行合理应用，解决问题； 4. 掌握多线程及高性能的设计与编码及性能调优；有高并发应用开发经验； 5. 掌握Linux 操作系统和大型数据库（Oracle、MySql）；对sql优化有丰富的经验； 6. 学习能力强，适应能力好，有强烈的责任心，具备耐心/细心的品质；

应聘体验反馈电话：0571-81595900
阿里巴巴集团
人力资源部


Hello 强鹏阳，
We are very happy to tell you that on 2017-10-13, 胡颖 recommended you for an Alibaba position：业务平台-JAVA研发工程师／专家-杭州.We will process your application within 10 working days, and thank you for your patience.
Your recruitment position details are as follows:
职位名称：业务平台-JAVA研发工程师／专家-杭州
职位描述：业务平台事业部，是阿里巴巴电子商务操作系统的基石，是中台战略的主阵地，由会员、商品、交易、店铺、资金、拍卖、数据等多个核心业务平台组成，旨在提供简单可信赖的电商技术基础产品，高效高质量地支持阿里巴巴集团业务的全球化布局和创新性发展。 为承接集团的中台及全球化战略，业务平台事业部需要和更多有志之士携手，在平台的可靠、高效、易扩展方面进行探索，如果你对复杂的业务场景有经验，对技术的深度有追求，对商业的本质感兴趣，欢迎加入阿里巴巴业务平台事业部。 1.负责具体业务功能的开发（拍卖、会员、商品、交易、店铺、资金等），深入发掘业务需求，独当一面，包括需求分析、架构设计和代码实现； 2.持续优化系统架构，提高系统在高并发、大流量下的容灾容错能力，保证系统的高可用性（性能、安全、容量）； 3.通过梳理和抽象，沉淀通用性的平台或服务能力，发现和解决存在的技术问题，并在具体的业务场景中进行验证推广；
职位要求：1. 本科及以上学历，计算机软件或相关专业； 2. 3年及以上使用JAVA开发的经验，JAVA基础扎实，理解io、多线程、集合等基础框架，对JVM原理有一定的了解，对Spring,ibatis,struts等开源框架熟悉； 3. 熟悉分布式系统的设计和应用，熟悉分布式、缓存、消息等机制；能对分布式常用技术进行合理应用，解决问题； 4. 掌握多线程及高性能的设计与编码及性能调优；有高并发应用开发经验； 5. 掌握Linux 操作系统和大型数据库（Oracle、MySql）；对sql优化有丰富的经验； 6. 学习能力强，适应能力好，有强烈的责任心，具备耐心/细心的品质；

Recruitment experience feedback number：0571-8159590
Alibaba Group
Human Resources Department

## 投递岗位详情
![cac3e187-4000-491f-b81a-e7e8d9356e8a.jpg](./cac3e187-4000-491f-b81a-e7e8d9356e8a.jpg)

## 岗位要求
1. 本科及以上学历，计算机软件或相关专业；
2. 3年及以上使用JAVA开发的经验，JAVA基础扎实，理解io、多线程、集合等基础框架，对JVM原理有一定的了解，对Spring,ibatis,struts等开源框架熟悉；
3. 熟悉分布式系统的设计和应用，熟悉分布式、缓存、消息等机制；能对分布式常用技术进行合理应用，解决问题；
4. 掌握多线程及高性能的设计与编码及性能调优；有高并发应用开发经验；
5. 掌握Linux 操作系统和大型数据库（Oracle、MySql）；对sql优化有丰富的经验；
6. 学习能力强，适应能力好，有强烈的责任心，具备耐心/细心的品质；

## 岗位要求详解
1. 本科及以上学历，计算机软件或相关专业；
2. 3年及以上使用JAVA开发的经验
3. JAVA基础扎实
4. 多线程
5. 集合
6. 开源框架
	- spring
	- ibatis
	- hibernate
	- strtus
7. 熟悉分布式系统的设计和应用
8. 熟悉分布式
9. 缓存
10. 消息等机制
11. 能对分布式常用技术进行合理应用，解决问题
12. 掌握多线程
13. 高性能的设计
14. 编码及性能调优
15. 有高并发应用开发经验
16. 掌握Linux 操作系统
17. 大型数据库（Oracle、MySql）
18. 对sql优化有丰富的经验
19. 学习能力强，适应能力好，有强烈的责任心，具备耐心/细心的品质；

## 面试准备
1. 自我介绍
2. Java基础相关内容
	- 计算机网络基础
		1. TCP/UDP区别以及TCP如何保证传输可靠性
			- TCP
				- TCP（Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“对话”才能建立起来，其中的过程非常复杂，我们这里只做简单、形象的介绍，你只要做到能够理解这个过程即可。我们来看看这三次对话的简单过程：主机A向主机B发出连接请求数据包：“我想给你发数据，可以吗？”，这是第一次对话；主机B向主机A发送同意连接和要求同步（同步就是两台主机一个在发送，一个在接收，协调工作）的数据包：“可以，你什么时候发？”，这是第二次对话；主机A再发出一个数据包确认主机B的要求同步：“我现在就发，你接着吧！”，这是第三次对话。三次“对话”的目的是使数据包的发送和接收同步，经过三次“对话”之后，主机A才向主机B正式发送数据。
			- UDP
				- UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境。大家可以看到，发送的数据包数量是4包，收到的也是4包（因为对方主机收到后会发回一个确认收到的数据包）。这充分说明了UDP协议是面向非连接的协议，没有建立连接的过程。正因为UDP协议没有连接的过程，所以它的通信效果高；但也正因为如此，它的可靠性不如TCP协议高。QQ就使用UDP发消息，因此有时会出现收不到消息的情况。
			- TCP协议和UDP协议的差别
				- tcp协议和udp协议的差别
					 ![2017-10-14 19-42-10屏幕截图.png](./2017-10-14 19-42-10屏幕截图.png)
			- TCP的可靠性如何保证
				- 在TCP的连接中，数据流必须以正确的顺序送达对方。TCP的可靠性是通过顺序编号和确认（ACK）来实现的。TCP在开始传送一个段时，为准备重传而首先将该段插入到发送队列之中，同时启动时钟。其后，如果收到了接受端对该段的ACK信息，就将该段从队列中删去。如果在时钟规定的时间内，ACK未返回，那么就从发送队列中再次送出这个段。TCP在协议中就对数据可靠传输做了保障，握手与断开都需要通讯双方确认，数据传输也需要双方确认成功，在协议中还规定了：分包、重组、重传等规则；而UDP主要是面向不可靠连接的，不能保证数据正确到达目的地。
			- TCP三次握手 四次挥手
				 ![cac3e187-4000-491f-b81a-e7e8d9356e8a.jpg](/home/discardpast/桌面/20150414204215804)
				 ![cac3e187-4000-491f-b81a-e7e8d9356e8a.jpg](/home/discardpast/桌面/20170610143353555)
		2. 常见的路由选择协议，以及它们的区别
			- 常见的路由选择协议有：RIP协议、OSPF协议。
			- RIP协议：底层是贝尔曼福特算法，它选择路由的度量标准（metric)是跳数，最大跳数是15跳，如果大于15跳，它就会丢弃数据包。
			- OSPF协议：底层是迪杰斯特拉算法，是链路状态路由选择协议，它选择路由的度量标准是带宽，延迟。
		3. OSI七层模型与TCP/IP五层模型
			- OSI七层模型
			 ![2017-10-14 19-46-30屏幕截图.png](./2017-10-14 19-46-30屏幕截图.png)
            - TCP/IP五层模型的协议
			 ![2017-10-14 19-47-03屏幕截图.png](./2017-10-14 19-47-03屏幕截图.png)
            - TCP/IP中，每一层对应的协议
            	- 网络层：IP协议、ICMP协议、ARP协议、RARP协议。
				- 传输层：UDP协议、TCP协议。
				- 应用层：FTP（文件传送协议）、Telenet（远程登录协议）、DNS（域名解析协议）、SMTP（邮件传送协议），POP3协议（邮局协议），HTTP协议。
			- 注意
				- 在OSI模型中ARP协议属于链路层；而在TCP/IP模型中，ARP协议属于网络层。
			- 除了层的数量之外，开放式系统互联（OSI）模型与TCP/IP协议有什么区别？
				- 开放式 系统互联模型是一个参考标准，解释协议相互之间应该如何相互作用。TCP/IP协议是美国国防部发明的，是让互联网成为了目前这个样子的标准之一。 开放式系统互联模型中没有清楚地描绘TCP/IP协议，但是在解释TCP/IP协议时很容易想到开放式系统互联模型。
			- 两者的主要区别如下
				- TCP/IP协议中的应用层处理开放式系统互联模型中的第五层、第六层和第七层的功能
				- TCP/IP协议中的传输层并不能总是保证在传 输层可靠地传输数据包，而开放式系统互联模型可以做到。
				- TCP/IP协议中的传输层并不能总是保证在传 输层可靠地传输数据包，而开放式系统互联模型可以做到。TCP/IP协议还提供一项名为UDP（用户数据报协议）的选择。UDP不能保证可靠的数据包传输。
		4. OSI七层模型详解及各层的硬件设备
			- 应用层
				- 很简单，就是应用程序。这一层负责确定通信对象，并确保由足够的资源用于通信，这些当然都是想要通信的应用程序干的事情。为操作系统或网络应用程序提供访问网络服务的接口。
				- 应用层协议的代表包括：Telnet、FTP、HTTP、SNMP等。
			- 表示层
				- 责数据的编码、转化，确保应用层的正常工作。这一层，是将我们看到的界面与二进制间互相转化的地方，就是我们的语言与机器语言间的转化。数据的压缩、解压，加密、解密都发生在这一层。这一层根据不同的应用目的将数据处理为不同的格式，表现出来就是我们看到的各种各样的文件扩展名。
			- 会话层
				- 负责建立、维护、控制会话，区分不同的会话，以及提供单工(Simplex)、半双工(Half duplex)、全双工(Full duplex)三种通信模式的服务。我们平时所知的NFS，RPC,X Windows等都工作在这一层。管理主机之间的会话进程，即负责建立、管理、终止进程之间的会话。会话层还利用在数据中插入校验点来实现数据的同步。
			- 传输层
				- 负责建立、维护、控制会话，区分不同的会话，以及提供单工(Simplex)、半双工(Half duplex)、全双工(Full duplex)三种通信模式的服务。我们平时所知的NFS，RPC,X Windows等都工作在这一层。管理主机之间的会话进程，即负责建立、管理、终止进程之间的会话。会话层还利用在数据中插入校验点来实现数据的同步。
				- 在这一层，数据的单位称为数据段（segment）。
				- 传输层协议的代表包括：TCP、UDP、SPX等
			- 网络层
				- 负责管理网络地址，定位设备，决定路由。我们所熟知的IP地址和路由器就是工作在这一层。上层的数据段在这一层被分割，封装后叫做包(Packet)，包有两种，一种叫做用户数据包(Data packets)，是上层传下来的用户数据；另一种叫路由更新包(Route update packets)，是直接由路由器发出来的，用来和其他路由器进行路由信息的交换。负责对子网间的数据包进行路由选择。网络层还可以实现拥塞控制、网际互连等功能。
				- 在这一层，数据的单位称为数据包（packet）。
				- 网络层协议的代表包括：IP、IPX、RIP、OSPF等
			- 数据链路层
				- 负责准备物理传输，CRC校验，错误通知，网络拓扑，流控等。我们所熟知的MAC地址和交换机都工作在这一层。上层传下来的包在这一层被分割封装后叫做帧(Frame)。在不可靠的物理介质上提供可靠的传输。该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。
				- 在这一层，数据的单位称为帧（frame）。
				- 数据链路层协议的代表包括：SDLC、HDLC、PPP、STP、帧中继等
			- 物理层
				- 就是实实在在的物理链路，负责将数据以比特流的方式发送、接收，就不多说了。
			- 各层的设备
				- 物理层
					- 中继器（Repeater，也叫放大器），集线器，网线。
				- 数据链路层
					- 网桥，交换机。
				- 网络层
					- 路由器。
				- 网关
					- 网络层以上的设备。
		5. IP地址的分类（尤其注意特殊I传输层协议的代表包括：TCP、UDP、SPX等P）
			1. A类
     			- 十进制中第一位在1~126之间
    			- 十进制中第一个数代表不同的网络
     			- 所以最大网络数为126(2^7-2)个
                 - 1.0.0.0代表网络本身,不能分配
                 - 1.255.255.255代表当前网络的广播地址,不能分配
                 - 所以最大主机数为2^24-2个
                 - 使用路由器跨网络通信
                 - 使用交换机同网络通信
                 - 广播地址是专门用于同时向网络中所有工作站进行发送的一个地址
                 - 私有IP不能直接访问公网IP,这样节约了有限的公网IP地址
			2. 127.0.0.0 代表当前计算机本身
			3. B类
                 - 十进制中第一位在128~191之间
                 - 十进制中的前两个数代表不同的网络
                 - 所以最大网络数为16384(2^14)
                 - 128.0.0.0代表网络本身,不能分配
                 - 191.255.255.255代表当前网络的广播地址,不能分配
                 - 所以最大主机数为2^16-2个
			4. C类
                 - 十进制中第一位在192~223之间
                 - 十进制中的前三个数代表不同网络
                 - 所以最大网络数为2^21个
                 - 192.0.0.0代表网络本身,不能分配
                 - 223.255.255.255代表当前网络的广播地址,不能分配
                 - 所以最大主机数为2^8-2个
		6. ARP协议的工作原理
			-  首先，每台主机都会在自己的ARP缓冲区中建立一个 ARP列表，以表示IP地址和MAC地址的对应关系。当源主机需要将一个数据包要发送到目的主机时，会首先检查自己 ARP列表中是否存在该 IP地址对应的MAC地址，如果有，就直接将数据包发送到这个MAC地址；如果没有，就向本地网段发起一个ARP请求的广播包，查询此目的主机对应的MAC地址。此ARP请求数据包里包括源主机的IP地址、硬件地址、以及目的主机的IP地址。网络中所有的主机收到这个ARP请求后，会检查数据包中的目的IP是否和自己的IP地址一致。如果不相同就忽略此数据包；如果相同，该主机首先将发送端的MAC地址和IP地址添加到自己的ARP列表中，如果ARP表中已经存在该IP的信息，则将其覆盖，然后给源主机发送一个 ARP响应数据包，告诉对方自己是它需要查找的MAC地址；源主机收到这个ARP响应数据包后，将得到的目的主机的IP地址和MAC地址添加到自己的ARP列表中，并利用此信息开始数据的传输。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。
		7. 在浏览器中输入网址后执行的全部过程
			1. 查找域名对应的IP地址。这一步会依次查找浏览器缓存，系统缓存，路由器缓存，ISPNDS缓存，根域名服务器。
            2. 向IP对应的服务器发送请求。
            3. 服务器响应请求，发回网页内容。
            4. 浏览器解析网页内容。
            5. 由于网页可能有重定向，或者嵌入了图片，AJAX，其它子网页等等，这4个步骤可能反复进行多次才能将最终页面展示给用户。
		8. TCP对应的协议和UDP对应的协议
			- TCP对应的协议
				1. FTP
					- 定义了文件传输协议，使用21端口。常说某某计算机开了FTP服务便是启动了文件传输服务。下载文件，上传主页，都要用到FTP服务。 
				2. Telnet
					- 它是一种用于远程登陆的端口，用户可以以自己的身份远程连接到计算机上，通过这种端口可以提供一种基于DOS模式下的通信服务。如以前的BBS是-纯字符界面的，支持BBS的服务器将23端口打开，对外提供服务。
				3. SMTP
					- 定义了简单邮件传送协议，现在很多邮件服务器都用的是这个协议，用于发送邮件。如常见的免费邮件服务中用的就是这个邮件服务端口，所以在电子邮件设置-中常看到有这么SMTP端口设置这个栏，服务器开放的是25号端口。
				4. POP3
					- 它是和SMTP对应，POP3用于接收邮件。通常情况下，POP3协议所用的是110端口。也是说，只要你有相应的使用POP3协议的程序（例如Fo-xmail或Outlook），就可以不以Web方式登陆进邮箱界面，直接用邮件程序就可以收到邮件（如是163邮箱就没有必要先进入网易网站，再进入自己的邮-箱来收信）。
				5. HTTP
					- 是从Web服务器传输超文本到本地浏览器的传送协议。
			- UDP对应的协议
				1. DNS
					- 用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。
				2. SNMP
					- 简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。
				3. TFTP
					- 简单文件传输协议，该协议在熟知端口69上使用UDP服务。
		9. 强调下上文的特殊IP地址
			1. 网络地址
				-  IP地址由网络号（包括子网号）和主机号组成，网络地址的主机号为全0，网络地址代表着整个网络。
			2. 广播地址
				- 广播地址通常称为直接广播地址，是为了区分受限广播地址。
				- 广播地址与网络地址的主机号正好相反，广播地址中，主机号为全1。当向某个网络的广播地址发送消息时，该网络内的所有主机都能收到该广播消息。
			3. 组播地址
				- D类地址就是组播地址。
				- 先回忆下A，B，C，D类地址吧
					- A类地址以00开头，第一个字节作为网络号，地址范围为：0.0.0.0~127.255.255.255；
					- B类地址以10开头，前两个字节作为网络号，地址范围是：128.0.0.0~191.255.255.255;
					- C类地址以110开头，前三个字节作为网络号，地址范围是：192.0.0.0~223.255.255.255。
					- D类地址以1110开头，地址范围是224.0.0.0~239.255.255.255，D类地址作为组播地址（一对多的通信）；
					- E类地址以1111开头，地址范围是240.0.0.0~255.255.255.255，E类地址为保留地址，供以后使用。
					- Notice：只有A,B,C有网络号和主机号之分，D类地址和E类地址没有划分网络号和主机号。
			4. 255.255.255.255
				-  该IP地址指的是受限的广播地址。受限广播地址与一般广播地址（直接广播地址）的区别在于，受限广播地址之只能用于本地网络，路由器不会转发以受限广播地址为目的地址的分组；一般广播地址既可在本地广播，也可跨网段广播。例如：主机192.168.1.1/30上的直接广播数据包后，另外一个网段192.168.1.5/30也能收到该数据报；若发送受限广播数据报，则不能收到。
				- Notice：一般的广播地址（直接广播地址）能够通过某些路由器（当然不是所有的路由器），而受限的广播地址不能通过路由器。
			5. 0.0.0.0
				- 常用于寻找自己的IP地址，例如在我们的RARP，BOOTP和DHCP协议中，若某个未知IP地址的无盘机想要知道自己的IP地址，它就以255.255.255.255为目的地址，向本地范围（具体而言是被各个路由器屏蔽的范围内）的服务器发送IP请求分组。
			6. 回环地址
				- 127.0.0.0/8被用作回环地址，回环地址表示本机的地址，常用于对本机的测试，用的最多的是127.0.0.1。
			7. A、B、C类私有地址
				- 私有地址(private address)也叫专用地址，它们不会在全球使用，只具有本地意义。
				- A类私有地址：10.0.0.0/8，范围是：10.0.0.0~10.255.255.255
				- B类私有地址：172.16.0.0/12，范围是：172.16.0.0~172.31.255.255
				- C类私有地址：192.168.0.0/16，范围是：192.168.0.0~192.168.255.255
		10. NAT协议、DHCP协议、DNS协议的作用
			- NAT协议
				- 网络地址转换(NAT,Network AddressTranslation)属接入广域网(WAN)技术，
				- 是一种将私有（保留）地址转化为合法IP地址的转换技术，它被广泛应用于各种类型Internet接入方式和各种类型的网络中。原因很简单，NAT不仅完美地解决了lP地址不足的问题，而且还能够有效地避免来自网络外部的攻击，隐藏并保护网络内部的计算机。
				- 借助于NAT，私有（保留）地址的"内部"网络通过路由器发送数据包时，私有地址被转换成合法的IP地址，一个局域网只需使用少量IP地址（甚至是1个）即可实现私有地址网络内所有计算机与Internet的通信需求。
			- DHCP协议
				- ：动态主机设置协议（Dynamic Host ConfigurationProtocol, DHCP）
				- 是一个局域网的网络协议，使用UDP协议工作，主要有两个用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。
			- DNS协议
				- DNS 是域名系统 (Domain Name System) 的缩写，是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。
		11. 子网掩码的作用
			- 子网掩码只有一个作用，就是将某个IP地址划分成网络地址和主机地址两部分。
			- 用于子网掩码的位数决定于可能的子网数目和每个子网的主机数目。
			- 计算方法示例
			![2017-10-14 20-19-24屏幕截图.png](./2017-10-14 20-19-24屏幕截图.png)
	- 数据结构
	- 算法
	- java语言基础
3. 多线程
	1. 什么是线程
		- 线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。程序员可以通过它进行多处理器编程，你可以使用多线程对运算密集型任务提速。比如，如果一个线程完成一个任务要100毫秒，那么用十个线程完成改任务只需10毫秒。Java在语言层面对多线程提供了卓越的支持，它也是一个很好的卖点。
	2. 线程和进程有什么区别
		- 线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务。不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存空间。别把它和栈内存搞混，每个线程都拥有单独的栈内存用来存储本地数据
	3. 如何在Java中实现线程
		- 在语言层面有两种方式。java.lang.Thread 类的实例就是一个线程但是它需要调用java.lang.Runnable接口来执行，由于线程类本身就是调用的Runnable接口所以你可以继承java.lang.Thread 类或者直接调用Runnable接口来重写run()方法实现线程
	4. 用Runnable还是Thread
		- 这个问题是上题的后续，大家都知道我们可以通过继承Thread类或者调用Runnable接口来实现线程，问题是，那个方法更好呢？什么情况下使用它？这个问题很容易回答，如果你知道Java不支持类的多重继承，但允许你调用多个接口。所以如果你要继承其他类，当然是调用Runnable接口好了。
	5. Thread类中的start()和run()方法有什么区别
		- 这个问题经常被问到，但还是能从此区分出面试者对Java线程模型的理解程度。start()方法被用来启动新创建的线程，而且start()内部调用了run()方法，这和直接调用run()方法的效果不一样。当你调用run()方法的时候，只会是在原来的线程中调用，没有新的线程启动，start()方法才会启动新线程
	6. Java中Runnable和Callable有什么不同
		- Runnable和Callable都代表那些要在不同的线程中执行的任务。Runnable从JDK1.0开始就有了，Callable是在JDK1.5增加的。它们的主要区别是Callable的 call() 方法可以返回值和抛出异常，而Runnable的run()方法没有这些功能。
	7. Java中CyclicBarrier 和 CountDownLatch有什么不同
		- CyclicBarrier 和 CountDownLatch 都可以用来让一组线程等待其它线程。与 CyclicBarrier 不同的是，CountdownLatch 不能重新使用。
	8. Java内存模型是什么
		- Java内存模型规定和指引Java程序在不同的内存架构、CPU和操作系统间有确定性地行为。它在多线程的情况下尤其重要。Java内存模型对一个线程所做的变动能被其它线程可见提供了保证，它们之间是先行发生关系。这个关系定义了一些规则让程序员在并发编程时思路更清晰。比如，先行发生关系确保了：
            - 线程内的代码能够按先后顺序执行，这被称为程序次序规则。
            -  对于同一个锁，一个解锁操作一定要发生在时间上后发生的另一个锁定操作之前，也叫做管程锁定规则。
            - 前一个对volatile的写操作在后一个volatile的读操作之前，也叫volatile变量规则。
            - 一个线程内的任何操作必需在这个线程的start()调用之后，也叫作线程启动规则。
            - 一个线程的所有操作都会在线程终止之前，线程终止规则。
            - 一个对象的终结操作必需在这个对象构造完成之后，也叫对象终结规则。
            - 可传递性
	9. Java中的volatile 变量是什么
		- volatile是一个特殊的修饰符，只有成员变量才能使用它。在Java并发程序缺少同步类的情况下，多线程对成员变量的操作对其它线程是透明的。volatile变量可以保证下一个读取操作会在前一个写操作之后发生，就是上一题的volatile变量规则
	10. 什么是线程安全？Vector是一个线程安全类吗
		- 如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。一个线程安全的计数器类的同一个实例对象在被多个线程使用的情况下也不会出现计算失误。很显然你可以将集合类分成两组，线程安全和非线程安全的。Vector 是用同步方法来实现线程安全的, 而和它相似的ArrayList不是线程安全的。
	11. Java中什么是竞态条件
		- 竞态条件会导致程序在并发情况下出现一些bugs。多线程对一些资源的竞争的时候就会产生竞态条件，如果首先要执行的程序竞争失败排到后面执行了，那么整个程序就会出现一些不确定的bugs。这种bugs很难发现而且会重复出现，因为线程间的随机竞争。一个例子就是无序处理，
	12. Java中如何停止一个线程
		- Java提供了很丰富的API但没有为停止线程提供API。JDK 1.0本来有一些像stop(), suspend() 和 resume()的控制方法但是由于潜在的死锁威胁因此在后续的JDK版本中他们被弃用了，之后Java API的设计者就没有提供一个兼容且线程安全的方法来停止一个线程。当run() 或者 call() 方法执行完的时候线程会自动结束,如果要手动结束一个线程，你可以用volatile 布尔变量来退出run()方法的循环或者是取消任务来中断线程。
	13. 一个线程运行时发生异常会怎样
		- 如果异常没有被捕获该线程将会停止执行。Thread.UncaughtExceptionHandler是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候JVM会使用Thread.getUncaughtExceptionHandler()来查询线程的UncaughtExceptionHandler并将线程和异常作为参数传递给handler的uncaughtException()方法进行处理。
	14. 如何在两个线程间共享数据
		- 你可以通过共享对象来实现这个目的，或者是使用像阻塞队列这样并发的数据结构。
	15. Java中notify 和 notifyAll有什么区别
		- 这又是一个刁钻的问题，因为多线程可以等待单监控锁，Java API 的设计人员提供了一些方法当等待条件改变的时候通知它们，但是这些方法没有完全实现。notify()方法不能唤醒某个具体的线程，所以只有一个线程在等待的时候它才有用武之地。而notifyAll()唤醒所有线程并允许他们争夺锁确保了至少有一个线程能继续运行。
	16. 为什么wait, notify 和 notifyAll这些方法不在thread类里面
		- 这是个设计相关的问题，它考察的是面试者对现有系统和一些普遍存在但看起来不合理的事物的看法。回答这些问题的时候，你要说明为什么把这些方法放在Object类里是有意义的，还有不把它放在Thread类里的原因。一个很明显的原因是JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。如果wait()方法定义在Thread类中，线程正在等待的是哪个锁就不明显了。简单的说，由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象。
	17. 什么是ThreadLocal变量
		- ThreadLocal是Java里一种特殊的变量。每个线程都有一个ThreadLocal就是每个线程都拥有了自己独立的一个变量，竞争条件被彻底消除了。它是为创建代价高昂的对象获取线程安全的好方法，比如你可以用ThreadLocal让SimpleDateFormat变成线程安全的，因为那个类创建代价高昂且每次调用都需要创建不同的实例所以不值得在局部范围使用它，如果为每个线程提供一个自己独有的变量拷贝，将大大提高效率。首先，通过复用减少了代价高昂的对象的创建个数。其次，你在没有使用高代价的同步或者不变性的情况下获得了线程安全。线程局部变量的另一个不错的例子是ThreadLocalRandom类，它在多线程环境中减少了创建代价高昂的Random对象的个数。
	18. 什么是FutureTask
		- 在Java并发程序中FutureTask表示一个可以取消的异步运算。它有启动和取消运算、查询运算是否完成和取回运算结果等方法。只有当运算完成的时候结果才能取回，如果运算尚未完成get方法将会阻塞。一个FutureTask对象可以对调用了Callable和Runnable的对象进行包装，由于FutureTask也是调用了Runnable接口所以它可以提交给Executor来执行。
	19. Java中interrupted 和 isInterruptedd方法的区别
		- interrupted() 和 isInterrupted()的主要区别是前者会将中断状态清除而后者不会。Java多线程的中断机制是用内部标识来实现的，调用Thread.interrupt()来中断一个线程就会设置中断标识为true。当中断线程调用静态方法Thread.interrupted()来检查中断状态时，中断状态会被清零。而非静态方法isInterrupted()用来查询其它线程的中断状态且不会改变中断状态标识。简单的说就是任何抛出InterruptedException异常的方法都会将中断状态清零。无论如何，一个线程的中断状态有有可能被其它线程调用中断来改变。
	20. 为什么wait和notify方法要在同步块中调用
		- 主要是因为Java API强制要求这样做，如果你不这么做，你的代码会抛出IllegalMonitorStateException异常。还有一个原因是为了避免wait和notify之间产生竞态条件。
	21. 为什么你应该在循环中检查等待条件
		- 处于等待状态的线程可能会收到错误警报和伪唤醒，如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出。因此，当一个等待线程醒来时，不能认为它原来的等待状态仍然是有效的，在notify()方法调用之后和等待线程醒来之前这段时间它可能会改变。这就是在循环中使用wait()方法效果更好的原因
	22. Java中的同步集合与并发集合有什么区别
		- 同步集合与并发集合都为多线程和并发提供了合适的线程安全的集合，不过并发集合的可扩展性更高。在Java1.5之前程序员们只有同步集合来用且在多线程并发的时候会导致争用，阻碍了系统的扩展性。Java5介绍了并发集合像ConcurrentHashMap，不仅提供线程安全还用锁分离和内部分区等现代技术提高了可扩展性。
	23. Java中堆和栈有什么不同
		- 为什么把这个问题归类在多线程和并发面试题里？因为栈是一块和线程紧密相关的内存区域。每个线程都有自己的栈内存，用于存储本地变量，方法参数和栈调用，一个线程中存储的变量对其它线程是不可见的。而堆是所有线程共享的一片公用内存区域。对象都在堆里创建，为了提升效率线程会从堆中弄一个缓存到自己的栈，如果多个线程使用该变量就可能引发问题，这时volatile 变量就可以发挥作用了，它要求线程从主存中读取变量的值。
	24. 什么是线程池？ 为什么要使用它
		- 创建线程要花费昂贵的资源和时间，如果任务来了才创建线程那么响应时间会变长，而且一个进程能创建的线程数有限。为了避免这些问题，在程序启动的时候就创建若干线程来响应处理，它们被称为线程池，里面的线程叫工作线程。从JDK1.5开始，Java API提供了Executor框架让你可以创建不同的线程池。比如单线程池，每次处理一个任务；数目固定的线程池或者是缓存线程池（一个适合很多生存期短的任务的程序的可扩展线程池）
	25. 如何写代码来解决生产者消费者问题
		- 在现实中你解决的许多线程问题都属于生产者消费者模型，就是一个线程生产任务供其它线程进行消费，你必须知道怎么进行线程间通信来解决这个问题。比较低级的办法是用wait和notify来解决这个问题，比较赞的办法是用Semaphore 或者 BlockingQueue来实现生产者消费者模型，这篇教程有实现它。
	26. 如何避免死锁
		- Java多线程中的死锁
		- 死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。这是一个严重的问题，因为死锁会让你的程序挂起无法完成任务，死锁的发生必须满足以下四个条件：

        - 互斥条件：一个资源每次只能被一个进程使用。
        - 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
        - 不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。
        - 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。
        - 避免死锁最简单的方法就是阻止循环等待条件，将系统中所有的资源设置标志位、排序，规定所有的进程申请资源必须以一定的顺序（升序或降序）做操作来避免死锁。
	27. Java中活锁和死锁有什么区别
		- 这是上题的扩展，活锁和死锁类似，不同之处在于处于活锁的线程或进程的状态是不断改变的，活锁可以认为是一种特殊的饥饿。一个现实的活锁例子是两个人在狭小的走廊碰到，两个人都试着避让对方好让彼此通过，但是因为避让的方向都一样导致最后谁都不能通过走廊。简单的说就是，活锁和死锁的主要区别是前者进程的状态可以改变但是却不能继续执行。
	28. 怎么检测一个线程是否拥有锁
		- 我一直不知道我们竟然可以检测一个线程是否拥有锁，直到我参加了一次电话面试。在java.lang.Thread中有一个方法叫holdsLock()，它返回true如果当且仅当当前线程拥有某个具体对象的锁。
	29. 你如何在Java中获取线程堆栈
		- 对于不同的操作系统，有多种方法来获得Java进程的线程堆栈。当你获取线程堆栈时，JVM会把所有线程的状态存到日志文件或者输出到控制台。在Windows你可以使用Ctrl + Break组合键来获取线程堆栈，Linux下用kill -3命令。你也可以用jstack这个工具来获取，它对线程id进行操作，你可以用jps这个工具找到id。
	30. JVM中哪个参数是用来控制线程的栈堆栈小的
		- 这个问题很简单， -Xss参数用来控制线程的堆栈大小。
	31. Java中synchronized 和 ReentrantLock 有什么不同
		- Java在过去很长一段时间只能通过synchronized关键字来实现互斥，它有一些缺点。比如你不能扩展锁之外的方法或者块边界，尝试获取锁时不能中途取消等。Java 5 通过Lock接口提供了更复杂的控制来解决这些问题。 ReentrantLock 类实现了 Lock，它拥有与 synchronized 相同的并发性和内存语义且它还具有可扩展性。
	32. 有三个线程T1，T2，T3，怎么确保它们按顺序执行
		- 在多线程中有多种方法让线程按特定顺序执行，你可以用线程类的join()方法在一个线程中启动另一个线程，另外一个线程完成该线程继续执行。为了确保三个线程的顺序你应该先启动最后一个(T3调用T2，T2调用T1)，这样T1就会先完成而T3最后完成。
	33. Thread类中的yield方法有什么作用
		- Yield方法可以暂停当前正在执行的线程对象，让其它有相同优先级的线程执行。它是一个静态方法而且只保证当前线程放弃CPU占用而不能保证使其它线程一定能占用CPU，执行yield()的线程有可能在进入到暂停状态后马上又被执行。
	34. Java中ConcurrentHashMap的并发度是什么
		- ConcurrentHashMap把实际map划分成若干部分来实现它的可扩展性和线程安全。这种划分是使用并发度获得的，它是ConcurrentHashMap类构造函数的一个可选参数，默认值为16，这样在多线程情况下就能避免争用。
	35. Java中Semaphore是什么
		- Java中的Semaphore是一种新的同步类，它是一个计数信号。从概念上讲，从概念上讲，信号量维护了一个许可集合。如有必要，在许可可用前会阻塞每一个 acquire()，然后再获取该许可。每个 release()添加一个许可，从而可能释放一个正在阻塞的获取者。但是，不使用实际的许可对象，Semaphore只对可用许可的号码进行计数，并采取相应的行动。信号量常常用于多线程的代码中，比如数据库连接池。
	36. 如果你提交任务时，线程池队列已满。会时发会生什么
		- 这个问题问得很狡猾，许多程序员会认为该任务会阻塞直到线程池队列有空位。事实上如果一个任务不能被调度执行那么ThreadPoolExecutor’s submit()方法将会抛出一个RejectedExecutionException异常。
	37. Java线程池中submit() 和 execute()方法有什么区别
		- 两个方法都可以向线程池提交任务，execute()方法的返回类型是void，它定义在Executor接口中, 而submit()方法可以返回持有计算结果的Future对象，它定义在ExecutorService接口中，它扩展了Executor接口，其它线程池类像ThreadPoolExecutor和ScheduledThreadPoolExecutor都有这些方法。
	38. 什么是阻塞式方法
		- 阻塞式方法是指程序会一直等待该方法完成期间不做其他事情，ServerSocket的accept()方法就是一直等待客户端连接。这里的阻塞是指调用结果返回之前，当前线程会被挂起，直到得到结果之后才会返回。此外，还有异步和非阻塞式方法在任务完成前就返回。
	39. Swing是线程安全的吗？ 为什么？
		- 你可以很肯定的给出回答，Swing不是线程安全的，但是你应该解释这么回答的原因即便面试官没有问你为什么。当我们说swing不是线程安全的常常提到它的组件，这些组件不能在多线程中进行修改，所有对GUI组件的更新都要在AWT线程中完成，而Swing提供了同步和异步两种回调方法来进行更新。
	40. Java中invokeAndWait 和 invokeLater有什么区别
		- 这两个方法是Swing API 提供给Java开发者用来从当前线程而不是事件派发线程更新GUI组件用的。InvokeAndWait()同步更新GUI组件，比如一个进度条，一旦进度更新了，进度条也要做出相应改变。如果进度被多个线程跟踪，那么就调用invokeAndWait()方法请求事件派发线程对组件进行相应更新。而invokeLater()方法是异步调用更新组件的。
	41. Swing API中那些方法是线程安全的
		- 这个问题又提到了swing和线程安全，虽然组件不是线程安全的但是有一些方法是可以被多线程安全调用的，比如repaint(), revalidate()。 JTextComponent的setText()方法和JTextArea的insert() 和 append() 方法也是线程安全的。
	42. 如何在Java中创建Immutable对象
		- 这个问题看起来和多线程没什么关系， 但不变性有助于简化已经很复杂的并发程序。Immutable对象可以在没有同步的情况下共享，降低了对该对象进行并发访问时的同步化开销。可是Java没有@Immutable这个注解符，要创建不可变类，要实现下面几个步骤：通过构造方法初始化所有成员、对变量不要提供setter方法、将所有的成员声明为私有的，这样就不允许直接访问这些成员、在getter方法中，不要直接返回对象本身，而是克隆对象，并返回对象的拷贝。
	43. Java中的ReadWriteLock是什么
		- 一般而言，读写锁是用来提升并发程序性能的锁分离技术的成果。Java中的ReadWriteLock是Java 5 中新增的一个接口，一个ReadWriteLock维护一对关联的锁，一个用于只读操作一个用于写。在没有写线程的情况下一个读锁可能会同时被多个读线程持有。写锁是独占的，你可以使用JDK中的ReentrantReadWriteLock来实现这个规则，它最多支持65535个写锁和65535个读锁。
	44. 多线程中的忙循环是什么
		- 忙循环就是程序员用循环让一个线程等待，不像传统方法wait(), sleep() 或 yield() 它们都放弃了CPU控制，而忙循环不会放弃CPU，它就是在运行一个空循环。这么做的目的是为了保留CPU缓存，在多核系统中，一个等待线程醒来的时候可能会在另一个内核运行，这样会重建缓存。为了避免重建缓存和减少等待重建的时间就可以使用它了
	45. volatile 变量和 atomic 变量有什么不同
		- 这是个有趣的问题。首先，volatile 变量和 atomic 变量看起来很像，但功能却不一样。Volatile变量可以确保先行关系，即写操作会发生在后续的读操作之前, 但它并不能保证原子性。例如用volatile修饰count变量那么 count++ 操作就不是原子性的。而AtomicInteger类提供的atomic方法可以让这种操作具有原子性如getAndIncrement()方法会原子性的进行增量操作把当前值加一，其它数据类型和引用变量也可以进行相似操作。
	46. 如果同步块内的线程抛出异常会发生什么
		- 这个问题坑了很多Java程序员，若你能想到锁是否释放这条线索来回答还有点希望答对。无论你的同步块是正常还是异常退出的，里面的线程都会释放锁，所以对比锁接口我更喜欢同步块，因为它不用我花费精力去释放锁，该功能可以在finally block里释放锁实现。
	47. 单例模式的双检锁是什么
		- 这个问题在Java面试中经常被问到，但是面试官对回答此问题的满意度仅为50%。一半的人写不出双检锁还有一半的人说不出它的隐患和Java1.5是如何对它修正的。它其实是一个用来创建线程安全的单例的老方法，当单例实例第一次被创建时它试图用单个锁进行性能优化，但是由于太过于复杂在JDK1.4中它是失败的，我个人也不喜欢它。无论如何，即便你也不喜欢它但是还是要了解一下，因为它经常被问到。
	48. 如何在Java中创建线程安全的Singleton
		- 这是上面那个问题的后续，如果你不喜欢双检锁而面试官问了创建Singleton类的替代方法，你可以利用JVM的类加载和静态变量初始化特征来创建Singleton实例，或者是利用枚举类型来创建Singleton，我很喜欢用这种方法。
	49. 写出3条你遵循的多线程最佳实践
		- 这种问题我最喜欢了，我相信你在写并发代码来提升性能的时候也会遵循某些最佳实践。以下三条最佳实践我觉得大多数Java程序员都应该遵循：

        - 给你的线程起个有意义的名字。
        - 这样可以方便找bug或追踪。OrderProcessor, QuoteProcessor or TradeProcessor 这种名字比 Thread-1. Thread-2 and Thread-3 好多了，给线程起一个和它要完成的任务相关的名字，所有的主要框架甚至JDK都遵循这个最佳实践。
        - 避免锁定和缩小同步的范围
        - 锁花费的代价高昂且上下文切换更耗费时间空间，试试最低限度的使用同步和锁，缩小临界区。因此相对于同步方法我更喜欢同步块，它给我拥有对锁的绝对控制权。
        - 多用同步类少用wait 和 notify
        - 首先，CountDownLatch, Semaphore, CyclicBarrier 和 Exchanger 这些同步类简化了编码操作，而用wait和notify很难实现对复杂控制流的控制。其次，这些类是由最好的企业编写和维护在后续的JDK中它们还会不断优化和完善，使用这些更高等级的同步工具你的程序可以不费吹灰之力获得优化。
        - 多用并发集合少用同步集合
        - 这是另外一个容易遵循且受益巨大的最佳实践，并发集合比同步集合的可扩展性更好，所以在并发编程时使用并发集合效果更好。如果下一次你需要用到map，你应该首先想到用ConcurrentHashMap。
	50. 如何强制启动一个线程
		- 这个问题就像是如何强制进行Java垃圾回收，目前还没有觉得方法，虽然你可以使用System.gc()来进行垃圾回收，但是不保证能成功。在Java里面没有办法强制启动一个线程，它是被线程调度器控制着且Java没有公布相关的API。
	51. Java中的fork join框架是什么
		- fork join框架是JDK7中出现的一款高效的工具，Java开发人员可以通过它充分利用现代服务器上的多处理器。它是专门为了那些可以递归划分成许多子模块设计的，目的是将所有可用的处理能力用来提升程序的性能。fork join框架一个巨大的优势是它使用了工作窃取算法，可以完成更多任务的工作线程可以从其它线程中窃取任务来执行。
	52. Java多线程中调用wait() 和 sleep()方法有什么不同
		- Java程序中wait 和 sleep都会造成某种形式的暂停，它们可以满足不同的需要。wait()方法用于线程间通信，如果等待条件为真且其它线程被唤醒时它会释放锁，而sleep()方法仅仅释放CPU资源或者让当前线程停止执行一段时间，但不会释放锁。
4. 集合
	1. Java集合框架是什么？说出一些集合框架的优点？
		- 每种编程语言中都有集合，最初的Java版本包含几种集合类：Vector、Stack、HashTable和Array。随着集合的广泛使用，Java1.2提出了囊括所有集合接口、实现和算法的集合框架。在保证线程安全的情况下使用泛型和并发集合类，Java已经经历了很久。它还包括在Java并发包中，阻塞接口以及它们的实现。集合框架的部分优点如下：
            1. 使用核心集合类降低开发成本，而非实现我们自己的集合类。
            2. 随着使用经过严格测试的集合框架类，代码质量会得到提高。
            3. 通过使用JDK附带的集合类，可以降低代码维护成本。
            4. 复用性和可操作性。
	2. 集合框架中的泛型有什么优点？
		- Java1.5引入了泛型，所有的集合接口和实现都大量地使用它。泛型允许我们为集合提供一个可以容纳的对象类型，因此，如果你添加其它类型的任何元素，它会在编译时报错。这避免了在运行时出现ClassCastException，因为你将会在编译时得到报错信息。泛型也使得代码整洁，我们不需要使用显式转换和instanceOf操作符。它也给运行时带来好处，因为不会产生类型检查的字节码指令。
	3. Java集合框架的基础接口有哪些？
		- Collection为集合层级的根接口。一个集合代表一组对象，这些对象即为它的元素。Java平台不提供这个接口任何直接的实现。
        - Set是一个不能包含重复元素的集合。这个接口对数学集合抽象进行建模，被用来代表集合，就如一副牌。
        - List是一个有序集合，可以包含重复元素。你可以通过它的索引来访问任何元素。List更像长度动态变换的数组。
        - Map是一个将key映射到value的对象.一个Map不能包含重复的key：每个key最多只能映射一个value。
        - 一些其它的接口有Queue、Dequeue、SortedSet、SortedMap和ListIterator。
	4. 为何Collection不从Cloneable和Serializable接口继承？
		- Collection接口指定一组对象，对象即为它的元素。如何维护这些元素由Collection的具体实现决定。例如，一些如List的Collection实现允许重复的元素，而其它的如Set就不允许。很多Collection实现有一个公有的clone方法。然而，把它放到集合的所有实现中也是没有意义的。这是因为Collection是一个抽象表现。重要的是实现。
        - 当与具体实现打交道的时候，克隆或序列化的语义和含义才发挥作用。所以，具体实现应该决定如何对它进行克隆或序列化，或它是否可以被克隆或序列化。
        - 在所有的实现中授权克隆和序列化，最终导致更少的灵活性和更多的限制。特定的实现应该决定它是否可以被克隆和序列化。
	5. 为何Map接口不继承Collection接口？
		- 尽管Map接口和它的实现也是集合框架的一部分，但Map不是集合，集合也不是Map。因此，Map继承Collection毫无意义，反之亦然。
		- 如果Map继承Collection接口，那么元素去哪儿？Map包含key-value对，它提供抽取key或value列表集合的方法，但是它不适合“一组对象”规范。
	6. Iterator是什么？
		- Iterator接口提供遍历任何Collection的接口。我们可以从一个Collection中使用迭代器方法来获取迭代器实例。迭代器取代了Java集合框架中的Enumeration。迭代器允许调用者在迭代过程中移除元素。
	7. Enumeration和Iterator接口的区别？
		- Enumeration的速度是Iterator的两倍，也使用更少的内存。Enumeration是非常基础的，也满足了基础的需要。但是，与Enumeration相比，Iterator更加安全，因为当一个集合正在被遍历的时候，它会阻止其它线程去修改集合。
		- 迭代器取代了Java集合框架中的Enumeration。迭代器允许调用者从集合中移除元素，而Enumeration不能做到。为了使它的功能更加清晰，迭代器方法名已经经过改善。
	8. 为何没有像Iterator.add()这样的方法，向集合中添加元素？
		- 语义不明，已知的是，Iterator的协议不能确保迭代的次序。然而要注意，ListIterator没有提供一个add操作，它要确保迭代的顺序。
	9. 为何迭代器没有一个方法可以直接获取下一个元素，而不需要移动游标？
		- 它可以在当前Iterator的顶层实现，但是它用得很少，如果将它加到接口中，每个继承都要去实现它，这没有意义。
	10. Iterater和ListIterator之间有什么区别？
		1. 我们可以使用Iterator来遍历Set和List集合，而ListIterator只能遍历List。
		2. Iterator只可以向前遍历，而LIstIterator可以双向遍历。
		3. ListIterator从Iterator接口继承，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。
	11. 遍历一个List有哪些不同的方式？
		- 使用for-each循环
		- using iterator
		- 使用迭代器更加线程安全，因为它可以确保，在当前遍历的集合元素被更改的时候，它会抛出ConcurrentModificationException。
	12. 通过迭代器fail-fast属性，你明白了什么？
		- 每次我们尝试获取下一个元素的时候，Iterator fail-fast属性检查当前集合结构里的任何改动。如果发现任何改动，它抛出ConcurrentModificationException。Collection中所有Iterator的实现都是按fail-fast来设计的（ConcurrentHashMap和CopyOnWriteArrayList这类并发集合类除外）。
	13. fail-fast与fail-safe有什么区别？
		- Iterator的fail-fast属性与当前的集合共同起作用，因此它不会受到集合中任何改动的影响。Java.util包中的所有集合类都被设计为fail-fast的，而java.util.concurrent中的集合类都为fail-safe的。Fail-fast迭代器抛出ConcurrentModificationException，而fail-safe迭代器从不抛出ConcurrentModificationException。
	14. 在迭代一个集合的时候，如何避免ConcurrentModificationException？
		- 在遍历一个集合的时候，我们可以使用并发集合类来避免ConcurrentModificationException，比如使用CopyOnWriteArrayList，而不是ArrayList。
	15. 为何Iterator接口没有具体的实现？
		- Iterator接口定义了遍历集合的方法，但它的实现则是集合实现类的责任。每个能够返回用于遍历的Iterator的集合类都有它自己的Iterator实现内部类。
		- 这就允许集合类去选择迭代器是fail-fast还是fail-safe的。比如，ArrayList迭代器是fail-fast的，而CopyOnWriteArrayList迭代器是fail-safe的。
	16. UnsupportedOperationException是什么？
		- UnsupportedOperationException是用于表明操作不支持的异常。在JDK类中已被大量运用，在集合框架java.util.Collections.UnmodifiableCollection将会在所有add和remove操作中抛出这个异常。
	17. 在Java中，HashMap是如何工作的？
		- HashMap在Map.Entry静态内部类实现中存储key-value对。HashMap使用哈希算法，在put和get方法中，它使用hashCode()和equals()方法。当我们通过传递key-value对调用put方法的时候，HashMap使用Key hashCode()和哈希算法来找出存储key-value对的索引。Entry存储在LinkedList中，所以如果存在entry，它使用equals()方法来检查传递的key是否已经存在，如果存在，它会覆盖value，如果不存在，它会创建一个新的entry然后保存。当我们通过传递key调用get方法时，它再次使用hashCode()来找到数组中的索引，然后使用equals()方法找出正确的Entry，然后返回它的值。
		- 其它关于HashMap比较重要的问题是容量、负荷系数和阀值调整。HashMap默认的初始容量是32，负荷系数是0.75。阀值是为负荷系数乘以容量，无论何时我们尝试添加一个entry，如果map的大小比阀值大的时候，HashMap会对map的内容进行重新哈希，且使用更大的容量。容量总是2的幂，所以如果你知道你需要存储大量的key-value对，比如缓存从数据库里面拉取的数据，使用正确的容量和负荷系数对HashMap进行初始化是个不错的做法。
	18. hashCode()和equals()方法有何重要性？
		- HashMap使用Key对象的hashCode()和equals()方法去决定key-value对的索引。当我们试着从HashMap中获取值的时候，这些方法也会被用到。如果这些方法没有被正确地实现，在这种情况下，两个不同Key也许会产生相同的hashCode()和equals()输出，HashMap将会认为它们是相同的，然后覆盖它们，而非把它们存储到不同的地方。同样的，所有不允许存储重复数据的集合类都使用hashCode()和equals()去查找重复，所以正确实现它们非常重要。equals()和hashCode()的实现应该遵循以下规则：
			1. 如果o1.equals(o2)，那么o1.hashCode() == o2.hashCode()总是为true的。
			2. 如果o1.hashCode() == o2.hashCode()，并不意味着o1.equals(o2)会为true。
	19. 我们能否使用任何类作为Map的key？
		- 我们可以使用任何类作为Map的key，然而在使用它们之前，需要考虑以下几点：
			1. 如果类重写了equals()方法，它也应该重写hashCode()方法。
			2. 类的所有实例需要遵循与equals()和hashCode()相关的规则。请参考之前提到的这些规则。
			3. 如果一个类没有使用equals()，你不应该在hashCode()中使用它。
			4. 用户自定义key类的最佳实践是使之为不可变的，这样，hashCode()值可以被缓存起来，拥有更好的性能。不可变的类也可以确保hashCode()和equals()在未来不会改变，这样就会解决与可变相关的问题了。
	20. Map接口提供了哪些不同的集合视图？
		- Map接口提供三个集合视图：
			1. Set keyset()：返回map中包含的所有key的一个Set视图。集合是受map支持的，map的变化会在集合中反映出来，反之亦然。当一个迭代器正在遍历一个集合时，若map被修改了（除迭代器自身的移除操作以外），迭代器的结果会变为未定义。集合支持通过Iterator的Remove、Set.remove、removeAll、retainAll和clear操作进行元素移除，从map中移除对应的映射。它不支持add和addAll操作。
			2. Collection values()：返回一个map中包含的所有value的一个Collection视图。这个collection受map支持的，map的变化会在collection中反映出来，反之亦然。当一个迭代器正在遍历一个collection时，若map被修改了（除迭代器自身的移除操作以外），迭代器的结果会变为未定义。集合支持通过Iterator的Remove、Set.remove、removeAll、retainAll和clear操作进行元素移除，从map中移除对应的映射。它不支持add和addAll操作。
			3. Set<Map.Entry<K,V>> entrySet()：返回一个map钟包含的所有映射的一个集合视图。这个集合受map支持的，map的变化会在collection中反映出来，反之亦然。当一个迭代器正在遍历一个集合时，若map被修改了（除迭代器自身的移除操作，以及对迭代器返回的entry进行setValue外），迭代器的结果会变为未定义。集合支持通过Iterator的Remove、Set.remove、removeAll、retainAll和clear操作进行元素移除，从map中移除对应的映射。它不支持add和addAll操作。
	21. HashMap和HashTable有何不同？
		1. HashMap允许key和value为null，而HashTable不允许。
		2. HashTable是同步的，而HashMap不是。所以HashMap适合单线程环境，HashTable适合多线程环境。
		3. 在Java1.4中引入了LinkedHashMap，HashMap的一个子类，假如你想要遍历顺序，你很容易从HashMap转向LinkedHashMap，但是HashTable不是这样的，它的顺序是不可预知的。
		4. HashMap提供对key的Set进行遍历，因此它是fail-fast的，但HashTable提供对key的Enumeration进行遍历，它不支持fail-fast。
		5. HashTable被认为是个遗留的类，如果你寻求在迭代的时候修改Map，你应该使用CocurrentHashMap。
	22. 如何决定选用HashMap还是TreeMap？
		- 对于在Map中插入、删除和定位元素这类操作，HashMap是最好的选择。然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择。基于你的collection的大小，也许向HashMap中添加元素会更快，将map换为TreeMap进行有序key的遍历。
	23. ArrayList和Vector有何异同点？
		- ArrayList和Vector在很多时候都很类似。
			1. 两者都是基于索引的，内部由一个数组支持。
			2. 两者维护插入的顺序，我们可以根据插入顺序来获取元素。
			3. ArrayList和Vector的迭代器实现都是fail-fast的。
			4. ArrayList和Vector两者允许null值，也可以使用索引值对元素进行随机访问。

		- 以下是ArrayList和Vector的不同点。
			1. Vector是同步的，而ArrayList不是。然而，如果你寻求在迭代的时候对列表进行改变，你应该使用CopyOnWriteArrayList。
			2. ArrayList比Vector快，它因为有同步，不会过载。			 3. ArrayList更加通用，因为我们可以使用Collections工具类轻易地获取同步列表和只读列表。
	24. Array和ArrayList有何区别？什么时候更适合用Array？
		- Array可以容纳基本类型和对象，而ArrayList只能容纳对象。
		- Array是指定大小的，而ArrayList大小是固定的。
		- Array没有提供ArrayList那么多功能，比如addAll、removeAll和iterator等。尽管ArrayList明显是更好的选择，但也有些时候Array比较好用。
			1. 如果列表的大小已经指定，大部分情况下是存储和遍历它们。
			2. 对于遍历基本数据类型，尽管Collections使用自动装箱来减轻编码任务，在指定大小的基本类型的列表上工作也会变得很慢。
			3. 如果你要使用多维数组，使用[][]比List<List<>>更容易。
	25. ArrayList和LinkedList有何区别？
		- ArrayList和LinkedList两者都实现了List接口，但是它们之间有些不同。
			1. ArrayList是由Array所支持的基于一个索引的数据结构，所以它提供对元素的随机访问，复杂度为O(1)，但LinkedList存储一系列的节点数据，每个节点都与前一个和下一个节点相连接。所以，尽管有使用索引获取元素的方法，内部实现是从起始点开始遍历，遍历到索引的节点然后返回元素，时间复杂度为O(n)，比ArrayList要慢。
			2. 与ArrayList相比，在LinkedList中插入、添加和删除一个元素会更快，因为在一个元素被插入到中间的时候，不会涉及改变数组的大小，或更新索引。
			3. LinkedList比ArrayList消耗更多的内存，因为LinkedList中的每个节点存储了前后节点的引用。
	26. 哪些集合类提供对元素的随机访问？
		- ArrayList、HashMap、TreeMap和HashTable类提供对元素的随机访问。
	27. EnumSet是什么？
		- java.util.EnumSet是使用枚举类型的集合实现。当集合创建时，枚举集合中的所有元素必须来自单个指定的枚举类型，可以是显示的或隐示的。EnumSet是不同步的，不允许值为null的元素。它也提供了一些有用的方法，比如copyOf(Collection c)、of(E first,E…rest)和complementOf(EnumSet s)。
	28. 哪些集合类是线程安全的？
		- Vector、HashTable、Properties和Stack是同步类，所以它们是线程安全的，可以在多线程环境下使用。Java1.5并发API包括一些集合类，允许迭代时修改，因为它们都工作在集合的克隆上，所以它们在多线程环境中是安全的。
	29. 并发集合类是什么？
		- Java1.5并发包（java.util.concurrent）包含线程安全集合类，允许在迭代时修改集合。迭代器被设计为fail-fast的，会抛出ConcurrentModificationException。一部分类为：CopyOnWriteArrayList、 ConcurrentHashMap、CopyOnWriteArraySet。
	30. BlockingQueue是什么？
		- Java.util.concurrent.BlockingQueue是一个队列，在进行检索或移除一个元素的时候，它会等待队列变为非空；当在添加一个元素时，它会等待队列中的可用空间。BlockingQueue接口是Java集合框架的一部分，主要用于实现生产者-消费者模式。我们不需要担心等待生产者有可用的空间，或消费者有可用的对象，因为它都在BlockingQueue的实现类中被处理了。Java提供了集中BlockingQueue的实现，比如ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue,、SynchronousQueue等。
	31. 队列和栈是什么，列出它们的区别？
		- 栈和队列两者都被用来预存储数据。java.util.Queue是一个接口，它的实现类在Java并发包中。队列允许先进先出（FIFO）检索元素，但并非总是这样。Deque接口允许从两端检索元素。
		- 栈与队列很相似，但它允许对元素进行后进先出（LIFO）进行检索。
		- Stack是一个扩展自Vector的类，而Queue是一个接口。
	32. Collections类是什么？
		- Java.util.Collections是一个工具类仅包含静态方法，它们操作或返回集合。它包含操作集合的多态算法，返回一个由指定集合支持的新集合和其它一些内容。这个类包含集合框架算法的方法，比如折半搜索、排序、混编和逆序等。
	33. Comparable和Comparator接口是什么？
		- 如果我们想使用Array或Collection的排序方法时，需要在自定义类里实现Java提供Comparable接口。Comparable接口有compareTo(T OBJ)方法，它被排序方法所使用。我们应该重写这个方法，如果“this”对象比传递的对象参数更小、相等或更大时，它返回一个负整数、0或正整数。但是，在大多数实际情况下，我们想根据不同参数进行排序。比如，作为一个CEO，我想对雇员基于薪资进行排序，一个HR想基于年龄对他们进行排序。这就是我们需要使用Comparator接口的情景，因为Comparable.compareTo(Object o)方法实现只能基于一个字段进行排序，我们不能根据对象排序的需要选择字段。Comparator接口的compare(Object o1, Object o2)方法的实现需要传递两个对象参数，若第一个参数比第二个小，返回负整数；若第一个等于第二个，返回0；若第一个比第二个大，返回正整数。
	34. Comparable和Comparator接口有何区别？
		- Comparable和Comparator接口被用来对对象集合或者数组进行排序。Comparable接口被用来提供对象的自然排序，我们可以使用它来提供基于单个逻辑的排序。
		- Comparator接口被用来提供不同的排序算法，我们可以选择需要使用的Comparator来对给定的对象集合进行排序。
	35. 我们如何对一组对象进行排序？
		- 如果我们需要对一个对象数组进行排序，我们可以使用Arrays.sort()方法。如果我们需要排序一个对象列表，我们可以使用Collection.sort()方法。两个类都有用于自然排序（使用Comparable）或基于标准的排序（使用Comparator）的重载方法sort()。Collections内部使用数组排序方法，所有它们两者都有相同的性能，只是Collections需要花时间将列表转换为数组。
	36. 当一个集合被作为参数传递给一个函数时，如何才可以确保函数不能修改它？
		- 在作为参数传递之前，我们可以使用Collections.unmodifiableCollection(Collection c)方法创建一个只读集合，这将确保改变集合的任何操作都会抛出UnsupportedOperationException。
	37. 我们如何从给定集合那里创建一个synchronized的集合？
		- 我们可以使用Collections.synchronizedCollection(Collection c)根据指定集合来获取一个synchronized（线程安全的）集合。
	38. 集合框架里实现的通用算法有哪些？
		- Java集合框架提供常用的算法实现，比如排序和搜索。Collections类包含这些方法实现。大部分算法是操作List的，但一部分对所有类型的集合都是可用的。部分算法有排序、搜索、混编、最大最小值。
	39. 大写的O是什么？举几个例子？
		- 大写的O描述的是，就数据结构中的一系列元素而言，一个算法的性能。Collection类就是实际的数据结构，我们通常基于时间、内存和性能，使用大写的O来选择集合实现。比如：例子1：ArrayList的get(index i)是一个常量时间操作，它不依赖list中元素的数量。所以它的性能是O(1)。例子2：一个对于数组或列表的线性搜索的性能是O(n)，因为我们需要遍历所有的元素来查找需要的元素。
	40. 与Java集合框架相关的有哪些最好的实践？
		1. 根据需要选择正确的集合类型。比如，如果指定了大小，我们会选用Array而非ArrayList。如果我们想根据插入顺序遍历一个Map，我们需要使用TreeMap。如果我们不想重复，我们应该使用Set。
		2. 一些集合类允许指定初始容量，所以如果我们能够估计到存储元素的数量，我们可以使用它，就避免了重新哈希或大小调整。
		3. 基于接口编程，而非基于实现编程，它允许我们后来轻易地改变实现。
		4. 总是使用类型安全的泛型，避免在运行时出现ClassCastException。
		5. 使用JDK提供的不可变类作为Map的key，可以避免自己实现hashCode()和equals()。
		6. 尽可能使用Collections工具类，或者获取只读、同步或空的集合，而非编写自己的实现。它将会提供代码重用性，它有着更好的稳定性和可维护性。
5. 开源框架
	1. spring
		1. 什么是Spring？
			- Spring是一个开源的Java EE开发框架。Spring框架的核心功能可以应用在任何Java应用程序中，但对Java EE平台上的Web应用程序有更好的扩展性。Spring框架的目标是使得Java EE应用程序的开发更加简捷，通过使用POJO为基础的编程模型促进良好的编程风格。
		2. Spring有哪些优点？
			- 轻量级：Spring在大小和透明性方面绝对属于轻量级的，基础版本的Spring框架大约只有2MB。
			- 控制反转(IOC)：Spring使用控制反转技术实现了松耦合。依赖被注入到对象，而不是创建或寻找依赖对象。
			- 面向切面编程(AOP)： Spring支持面向切面编程，同时把应用的业务逻辑与系统的服务分离开来。
			- 容器：Spring包含并管理应用程序对象的配置及生命周期。
			- MVC框架：Spring的web框架是一个设计优良的web MVC框架，很好的取代了一些web框架。
			- 事务管理：Spring对下至本地业务上至全局业务(JAT)提供了统一的事务管理接口。
			- 异常处理：Spring提供一个方便的API将特定技术的异常(由JDBC, Hibernate, 或JDO抛出)转化为一致的、Unchecked异常。
		3. Spring框架有哪些模块？
			- Core module
			- Bean module
			- Context module
			- Expression Language module
			- JDBC module
			- ORM module
			- OXM module
			- Java Messaging Service(JMS) module
			- Transaction module
			- Web module
			- Web-Servlet module
			- Web-Struts module
			- Web-Portlet module
		4. 解释核心容器(应用上下文)模块
			- 这是Spring的基本模块，它提供了Spring框架的基本功能。BeanFactory 是所有Spring应用的核心。Spring框架是建立在这个模块之上的，这也使得Spring成为一个容器。
		5. BeanFactory – BeanFactory 实例
			- BeanFactory是工厂模式的一种实现，它使用控制反转将应用的配置和依赖与实际的应用代码分离开来。
			- 最常用的BeanFactory实现是XmlBeanFactory类。
		6. XmlBeanFactory
			- 最常用的就是org.springframework.beans.factory.xml.XmlBeanFactory，它根据XML文件中定义的内容加载beans。该容器从XML文件中读取配置元数据，并用它来创建一个完备的系统或应用。
		7. 解释AOP模块
			- AOP模块用来开发Spring应用程序中具有切面性质的部分。该模块的大部分服务由AOP Aliance提供，这就保证了Spring框架和其他AOP框架之间的互操作性。另外，该模块将元数据编程引入到了Spring。
		8. 解释抽象JDBC和DAO模块
			- 通过使用抽象JDBC和DAO模块保证了与数据库连接代码的整洁与简单，同时避免了由于未能关闭数据库资源引起的问题。它在多种数据库服务器的错误信息之上提供了一个很重要的异常层。它还利用Spring的AOP模块为Spring应用程序中的对象提供事务管理服务。
		9. 解释对象/关系映射集成模块
			- Spring通过提供ORM模块在JDBC的基础上支持对象关系映射工具。这样的支持使得Spring可以集成主流的ORM框架，包括Hibernate, JDO, 及iBATIS SQL Maps。Spring的事务管理可以同时支持以上某种框架和JDBC。
		10. 解释web模块
			- Spring的web模块建立在应用上下文(application context)模块之上，提供了一个适合基于web应用程序的上下文环境。该模块还支持了几个面向web的任务，如透明的处理多文件上传请求及将请求参数同业务对象绑定起来。
		11. 解释Spring MVC模块
			- Spring提供MVC框架构建web应用程序。Spring可以很轻松的同其他MVC框架结合，但Spring的MVC是个更好的选择，因为它通过控制反转将控制逻辑和业务对象完全分离开来。
		12. Spring的配置文件
			- Spring的配置文件是一个XML文件，文件包含了类信息并描述了这些类是如何配置和互相调用的。
		13. Spring IoC容器是什么？
			- Spring IOC负责创建对象、管理对象(通过依赖注入)、整合对象、配置对象以及管理这些对象的生命周期。
		14. IOC有什么优点？
			- IOC或依赖注入减少了应用程序的代码量。它使得应用程序的测试很简单，因为在单元测试中不再需要单例或JNDI查找机制。简单的实现以及较少的干扰机制使得松耦合得以实现。IOC容器支持勤性单例及延迟加载服务。
		15. 应用上下文是如何实现的？
			- FileSystemXmlApplicationContext 容器加载XML文件中beans的定义。XML Bean配置文件的完整路径必须传递给构造器。
			- FileSystemXmlApplicationContext 容器也加载XML文件中beans的定义。注意，你需要正确的设置CLASSPATH，因为该容器会在CLASSPATH中查看bean的XML配置文件。
			- WebXmlApplicationContext：该容器加载xml文件，这些文件定义了web应用中所有的beans。
		16. Bean Factory和ApplicationContext有什么区别？
			- ApplicationContext提供了一种解决文档信息的方法，一种加载文件资源的方式(如图片)，他们可以向监听他们的beans发送消息。另外，容器或者容器中beans的操作，这些必须以bean工厂的编程方式处理的操作可以在应用上下文中以声明的方式处理。应用上下文实现了MessageSource，该接口用于获取本地消息，实际的实现是可选的。
		17. Spring应用程序看起来像什么？
			- 一个定义功能的接口
			- 实现包括属性，setter和getter方法，功能等
			- Spring AOP
			- Spring的XML配置文件
			- 使用该功能的客户端编程
		18. Spring中的依赖注入是什么？
			- 依赖注入作为控制反转(IOC)的一个层面，可以有多种解释方式。在这个概念中，你不用创建对象而只需要描述如何创建它们。你不必通过代码直接的将组件和服务连接在一起，而是通过配置文件说明哪些组件需要什么服务。之后IOC容器负责衔接。
		19. 有哪些不同类型的IOC(依赖注入)？
			- 构造器依赖注入：构造器依赖注入在容器触发构造器的时候完成，该构造器有一系列的参数，每个参数代表注入的对象。
			- Setter方法依赖注入：首先容器会触发一个无参构造函数或无参静态工厂方法实例化对象，之后容器调用bean中的setter方法完成Setter方法依赖注入。
		20. 你推荐哪种依赖注入？构造器依赖注入还是Setter方法依赖注入？
			- 你可以同时使用两种方式的依赖注入，最好的选择是使用构造器参数实现强制依赖注入，使用setter方法实现可选的依赖关系。
		21. 什么是Spring Beans？
			- Spring Beans是构成Spring应用核心的Java对象。这些对象由Spring IOC容器实例化、组装、管理。这些对象通过容器中配置的元数据创建，例如，使用XML文件中定义的创建。
			- 在Spring中创建的beans都是单例的beans。在bean标签中有一个属性为”singleton”,如果设为true，该bean是单例的，如果设为false，该bean是原型bean。Singleton属性默认设置为true。因此，spring框架中所有的bean都默认为单例bean。
		22. Spring Bean中定义了什么内容？
			- Spring Bean中定义了所有的配置元数据，这些配置信息告知容器如何创建它，它的生命周期是什么以及它的依赖关系。
		23. 如何向Spring 容器提供配置元数据？
			- 有三种方式向Spring 容器提供元数据:
				1. XML配置文件
				2. 基于注解配置
				3. 基于Java的配置
		24. 你如何定义bean的作用域？
			- 在Spring中创建一个bean的时候，我们可以声明它的作用域。只需要在bean定义的时候通过’scope’属性定义即可。例如，当Spring需要产生每次一个新的bean实例时，应该声明bean的scope属性为prototype。如果每次你希望Spring返回一个实例，应该声明bean的scope属性为singleton。
		25. 说一下Spring中支持的bean作用域
			- Spring框架支持如下五种不同的作用域：
				- singleton：在Spring IOC容器中仅存在一个Bean实例，Bean以单实例的方式存在。
				- prototype：一个bean可以定义多个实例。
				- request：每次HTTP请求都会创建一个新的Bean。该作用域仅适用于WebApplicationContext环境。
				- session：一个HTTP Session定义一个Bean。该作用域仅适用于WebApplicationContext环境.
				- globalSession：同一个全局HTTP Session定义一个Bean。该作用域同样仅适用于WebApplicationContext环境.
				- bean默认的scope属性是’singleton‘。
		26. Spring框架中单例beans是线程安全的吗？
			- 不是，Spring框架中的单例beans不是线程安全的。
		27. 解释Spring框架中bean的生命周期
			1. Spring容器读取XML文件中bean的定义并实例化bean。
			2. Spring根据bean的定义设置属性值。
			3. 如果该Bean实现了BeanNameAware接口，Spring将bean的id传递给setBeanName()方法。
			4. 如果该Bean实现了BeanFactoryAware接口，Spring将beanfactory传递给setBeanFactory()方法。
			5. 如果任何bean BeanPostProcessors 和该bean相关，Spring调用postProcessBeforeInitialization()方法。
			6. 如果该Bean实现了InitializingBean接口，调用Bean中的afterPropertiesSet方法。如果bean有初始化函数声明，调用相应的初始化方法。
			7. 如果任何bean BeanPostProcessors 和该bean相关，调用postProcessAfterInitialization()方法。
			8. 如果该bean实现了DisposableBean，调用destroy()方法。
		28. 哪些是最重要的bean生命周期方法？能重写它们吗？
			- 有两个重要的bean生命周期方法。第一个是setup方法，该方法在容器加载bean的时候被调用。第二个是teardown方法，该方法在bean从容器中移除的时候调用。
			- bean标签有两个重要的属性(init-method 和 destroy-method)，你可以通过这两个属性定义自己的初始化方法和析构方法。Spring也有相应的注解：@PostConstruct 和 @PreDestroy。
		29. 什么是Spring的内部bean？
			- 当一个bean被用作另一个bean的属性时，这个bean可以被声明为内部bean。在基于XML的配置元数据中，可以通过把元素定义在 或元素内部实现定义内部bean。内部bean总是匿名的并且它们的scope总是prototype。
		30. 如何在Spring中注入Java集合类？
			- Spring提供如下几种类型的集合配置元素：
				- list元素用来注入一系列的值，允许有相同的值。
				- set元素用来注入一些列的值，不允许有相同的值。
				- map用来注入一组”键-值”对，键、值可以是任何类型的。
				- props也可以用来注入一组”键-值”对，这里的键、值都字符串类型。
		31. 什么是bean wiring？
			- Wiring，或者说bean Wiring是指beans在Spring容器中结合在一起的情况。当装配bean的时候，Spring容器需要知道需要哪些beans以及如何使用依赖注入将它们结合起来。
		32. 什么是bean自动装配？
			- Spring容器可以自动配置相互协作beans之间的关联关系。这意味着Spring可以自动配置一个bean和其他协作bean之间的关系，通过检查BeanFactory 的内容里没有使用和< property>元素。
		33. 解释自动装配的各种模式？
			- 自动装配提供五种不同的模式供Spring容器用来自动装配beans之间的依赖注入:
				- no：默认的方式是不进行自动装配，通过手工设置ref 属性来进行装配bean。
				- byName：通过参数名自动装配，Spring容器查找beans的属性，这些beans在XML配置文件中被设置为byName。之后容器试图匹配、装配和该bean的属性具有相同名字的bean。
				- byType：通过参数的数据类型自动自动装配，Spring容器查找beans的属性，这些beans在XML配置文件中被设置为byType。之后容器试图匹配和装配和该bean的属性类型一样的bean。如果有多个bean符合条件，则抛出错误。
				- constructor：这个同byType类似，不过是应用于构造函数的参数。如果在BeanFactory中不是恰好有一个bean与构造函数参数相同类型，则抛出一个严重的错误。
				- autodetect：如果有默认的构造方法，通过 construct的方式自动装配，否则使用 byType的方式自动装配。
		34. 自动装配有哪些局限性？
			- 自动装配有如下局限性：
				- 重写：你仍然需要使用 和< property>设置指明依赖，这意味着总要重写自动装配。
				- 原生数据类型:你不能自动装配简单的属性，如原生类型、字符串和类。
				- 模糊特性：自动装配总是没有自定义装配精确，因此，如果可能尽量使用自定义装配。
		35. 你可以在Spring中注入null或空字符串吗?
			- 完全可以。
		36. 什么是Spring基于Java的配置？给出一些注解的例子
			- 基于Java的配置允许你使用Java的注解进行Spring的大部分配置而非通过传统的XML文件配置。
			- 以注解@Configuration为例，它用来标记类，说明作为beans的定义，可以被Spring IOC容器使用。另一个例子是@Bean注解，它表示该方法定义的Bean要被注册进Spring应用上下文中。
		37. 什么是基于注解的容器配置?
			- 另外一种替代XML配置的方式为基于注解的配置，这种方式通过字节元数据装配组件而非使用尖括号声明。开发人员将直接在类中进行配置，通过注解标记相关的类、方法或字段声明，而不再使用XML描述bean之间的连线关系。
		38. 如何开启注解装配？
			- 注解装配默认情况下在Spring容器中是不开启的。如果想要开启基于注解的装配只需在Spring配置文件中配置元素即可。
		39. @Required 注解
			- @Required表明bean的属性必须在配置时设置，可以在bean的定义中明确指定也可通过自动装配设置。如果bean的属性未设置，则抛出BeanInitializationException异常。
		40. @Autowired 注解
			- @Autowired 注解提供更加精细的控制，包括自动装配在何处完成以及如何完成。它可以像@Required一样自动装配setter方法、构造器、属性或者具有任意名称和/或多个参数的PN方法。
		41. @Qualifier 注解
			- 当有多个相同类型的bean而只有其中的一个需要自动装配时，将@Qualifier 注解和@Autowire 注解结合使用消除这种混淆，指明需要装配的bean。
		42. 在Spring框架中如何更有效的使用JDBC？
			- 使用Spring JDBC框架，资源管理以及错误处理的代价都会减轻。开发人员只需通过statements和queries语句从数据库中存取数据。Spring框架中通过使用模板类能更有效的使用JDBC，也就是所谓的JdbcTemplate(例子)。
		43. JdbcTemplate
			- JdbcTemplate类提供了许多方法，为我们与数据库的交互提供了便利。例如，它可以将数据库的数据转化为原生类型或对象，执行写好的或可调用的数据库操作语句，提供自定义的数据库错误处理功能。
		44. Spring对DAO的支持
			- Spring对数据访问对象(DAO)的支持旨在使它可以与数据访问技术(如 JDBC, Hibernate 及JDO)方便的结合起来工作。这使得我们可以很容易在的不同的持久层技术间切换，编码时也无需担心会抛出特定技术的异常。
		45. 使用Spring可以通过什么方式访问Hibernate？
			- 使用Spring有两种方式访问Hibernate：
				1. 使用Hibernate Template的反转控制以及回调方法
				2. 继承HibernateDAOSupport，并申请一个AOP拦截器节点
		46. Spring支持的ORM
			- Hibernate
            - iBatis
            - JPA (Java -Persistence API)
            - TopLink
            - JDO (Java Data Objects)
            - OJB
		47. 如何通过HibernateDaoSupport将Spring和Hibernate结合起来？
			- 使用Spring的SessionFactory 调用LocalSessionFactory。结合过程分为以配置Hibernate SessionFactory下三步：
				1. 配置Hibernate SessionFactory
				2. 继承HibernateDaoSupport实现一个DAO
				3. 使用AOP装载事务支持
		48. Spring支持的事务管理类型
			- Spring支持如下两种方式的事务管理：
				- 编程式事务管理：这意味着你可以通过编程的方式管理事务，这种方式带来了很大的灵活性，但很难维护。
				- 声明式事务管理：这种方式意味着你可以将事务管理和业务代码分离。你只需要通过注解或者XML配置管理事务。
		49. Spring框架的事务管理有哪些优点？
			- 它为不同的事务API(如JTA, JDBC, Hibernate, JPA, 和JDO)提供了统一的编程模型。
			- 它为编程式事务管理提供了一个简单的API而非一系列复杂的事务API(如JTA).
			- 它支持声明式事务管理。
			- 它可以和Spring 的多种数据访问技术很好的融合。
		50. 你更推荐那种类型的事务管理？
			- 许多Spring框架的用户选择声明式事务管理，因为这种方式和应用程序的关联较少，因此更加符合轻量级容器的概念。声明式事务管理要优于编程式事务管理，尽管在灵活性方面它弱于编程式事务管理(这种方式允许你通过代码控制业务)。
		51. 解释AOP
			- 面向切面编程,或AOP允许程序员模块化横向业务逻辑，或定义核心部分的功能，例如日志管理和事务管理。
		52. 切面(Aspect)
			- AOP的核心就是切面，它将多个类的通用行为封装为可重用的模块。该模块含有一组API提供 cross-cutting功能。例如,日志模块称为日志的AOP切面。根据需求的不同，一个应用程序可以有若干切面。在Spring AOP中，切面通过带有@Aspect注解的类实现。
		53. 在Spring AOP中concern和 cross-cutting concern的区别是什么？
			- Concern(核心逻辑)：表示在应用程序中一个模块的行为。Concern可以定义为我们想要实现的功能。
			- Cross-cutting concern(横向的通用逻辑)：指的是整个应用程序都会用到的功能，它影响整个应用程序。例如，日志管理（Logging）、安全管理（Security）以及数据交互是应用程序的每个模块都要涉及到的，因此这些都属于Cross-cutting concern。
		54. 连接点(Join point)
			- 连接点代表应用程序中插入AOP切面的地点。它实际上是Spring AOP框架在应用程序中执行动作的地点。
		55. 通知(Advice)
			- 通知表示在方法执行前后需要执行的动作。实际上它是Spring AOP框架在程序执行过程中触发的一些代码。
			- Spring切面可以执行一下五种类型的通知:
				- before(前置通知)：在一个方法之前执行的通知。
				- after(最终通知)：当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）。
				- after-returning(后置通知)：在某连接点正常完成后执行的通知。
				- after-throwing(异常通知)：在方法抛出异常退出时执行的通知。
				- around(环绕通知)：在方法调用前后触发的通知。
		56. 切入点(Pointcut)
			- 切入点是一个或一组连接点，通知将在这些位置执行。可以通过表达式或匹配的方式指明切入点。
		57. 什么是引入？
			- 引入允许我们在已有的类上添加新的方法或属性。
		58. 什么是目标对象？
			- 被一个或者多个切面所通知的对象。它通常是一个代理对象。也被称做被通知（advised）对象。
		59. 什么是代理？
			- 代理是将通知应用到目标对象后创建的对象。从客户端的角度看，代理对象和目标对象是一样的。
		60. 有几种不同类型的自动代理？
			- BeanNameAutoProxyCreator：bean名称自动代理创建器
			- DefaultAdvisorAutoProxyCreator：默认通知者自动代理创建器
			- Metadata autoproxying：元数据自动代理
		61. 什么是织入？什么是织入应用的不同点？
			- 织入是将切面和其他应用类型或对象连接起来创建一个通知对象的过程。织入可以在编译、加载或运行时完成。
		62. 解释基于XML Schema方式的切面实现
			- 在这种情况下，切面由使用XML文件配置的类实现
		63. 解释基于注解方式(基于@AspectJ)的切面实现
			- 在这种情况下(基于@AspectJ的实现)，指的是切面的对应的类使用Java 5注解的声明方式。
		64. 什么是Spring的MVC框架？
			- Spring提供了一个功能齐全的MVC框架用于构建Web应用程序。Spring框架可以很容易的和其他的MVC框架融合(如Struts)，该框架使用控制反转(IOC)将控制器逻辑和业务对象分离开来。它也允许以声明的方式绑定请求参数到业务对象上。
		65. DispatcherServlet
			- Spring的MVC框架围绕DispatcherServlet来设计的，它用来处理所有的HTTP请求和响应。
		66. WebApplicationContext
			- WebApplicationContext继承了ApplicationContext，并添加了一些web应用程序需要的功能。和普通的ApplicationContext 不同，WebApplicationContext可以用来处理主题样式，它也知道如何找到相应的servlet。
		67. 什么是Spring MVC框架的控制器？
			- 控制器提供对应用程序行为的访问，通常通过服务接口实现。控制器解析用户的输入，并将其转换为一个由视图呈现给用户的模型。Spring 通过一种极其抽象的方式实现控制器，它允许用户创建多种类型的控制器。
		68. @Controller annotation
			- @Controller注解表示该类扮演控制器的角色。Spring不需要继承任何控制器基类或应用Servlet API。
		69. @RequestMapping annotation
			- @RequestMapping注解用于将URL映射到任何一个类或者一个特定的处理方法上。
	2. ibatis
		1. #{}和${}的区别是什么？
			- ${}是Properties文件中的变量占位符，它可以用于标签属性值和sql内部，属于静态文本替换，比如${driver}会被静态替换为com.mysql.jdbc.Driver。#{}是sql的参数占位符，Mybatis会将sql中的#{}替换为?号，在sql执行前会使用PreparedStatement的参数设置方法，按序给sql的?号占位符设置参数值，比如ps.setInt(0, parameterValue)，#{item.name}的取值方式为使用反射从参数对象中获取item对象的name属性值，相当于param.getItem().getName()。
		2. Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？
			- 还有很多其他的标签，resultMap>、parameterMap>、sql>、include>、selectKey>，加上动态sql的9个标签，trim|where|set|foreach|if|choose|when|otherwise|bind等，其中sql>为sql片段标签，通过include>标签引入sql片段，selectKey>为不支持自增的主键生成策略标签。
		3. 最佳实践中，通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？
			- Dao接口，就是人们常说的Mapper接口，接口的全限名，就是映射文件中的namespace的值，接口的方法名，就是映射文件中MappedStatement的id值，接口方法内的参数，就是传递给sql的参数。Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为key值，可唯一定位一个MappedStatement，举例：com.mybatis3.mappers.StudentDao.findStudentById，可以唯一找到namespace为com.mybatis3.mappers.StudentDao下面id = findStudentById的MappedStatement。在Mybatis中，每一个select>、insert>、update>、delete>标签，都会被解析为一个MappedStatement对象。
			- Dao接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。
			- Dao接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Dao接口生成代理proxy对象，代理对象proxy会拦截接口方法，转而执行MappedStatement所代表的sql，然后将sql执行结果返回。
		4. Mybatis是如何进行分页的？分页插件的原理是什么？
			- Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页，可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。
			- 分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。
		5. 简述Mybatis的插件运行原理，以及如何编写一个插件。
			- Mybatis仅可以编写针对ParameterHandler、ResultSetHandler、StatementHandler、Executor这4种接口的插件，Mybatis使用JDK的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这4种接口对象的方法时，就会进入拦截方法，具体就是InvocationHandler的invoke()方法，当然，只会拦截那些你指定需要拦截的方法。
			- 实现Mybatis的Interceptor接口并复写intercept()方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。
		6. Mybatis执行批量插入，能返回数据库主键列表吗？
			- 能，JDBC都能，Mybatis当然也能。
		7. Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？
			- Mybatis动态sql可以让我们在Xml映射文件内，以标签的形式编写动态sql，完成逻辑判断和动态拼接sql的功能，Mybatis提供了9种动态sql标签trim|where|set|foreach|if|choose|when|otherwise|bind。
			- 其执行原理为，使用OGNL从sql参数对象中计算表达式的值，根据表达式的值动态拼接sql，以此来完成动态sql的功能。
		8. Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？
			- 第一种是使用resultMap>标签，逐一定义列名和对象属性名之间的映射关系。第二种是使用sql列的别名功能，将列别名书写为对象属性名，比如T_NAME AS NAME，对象属性名一般是name，小写，但是列名不区分大小写，Mybatis会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成T_NAME AS NaMe，Mybatis一样可以正常工作。
			- 有了列名与属性名的映射关系后，Mybatis通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。
		9. Mybatis能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别。
			- 能，Mybatis不仅可以执行一对一、一对多的关联查询，还可以执行多对一，多对多的关联查询，多对一查询，其实就是一对一查询，只需要把selectOne()修改为selectList()即可；多对多查询，其实就是一对多查询，只需要把selectOne()修改为selectList()即可。
			- 关联对象查询，有两种实现方式，一种是单独发送一个sql去查询关联对象，赋给主对象，然后返回主对象。另一种是使用嵌套查询，嵌套查询的含义为使用join查询，一部分列是A对象的属性值，另外一部分列是关联对象B的属性值，好处是只发一个sql查询，就可以把主对象和其关联对象查出来。
			- 那么问题来了，join查询出来100条记录，如何确定主对象是5个，而不是100个？其去重复的原理是resultMap>标签内的id>子标签，指定了唯一确定一条记录的id列，Mybatis根据id>列值来完成100条记录的去重复功能，id>可以有多个，代表了联合主键的语意。
			- 同样主对象的关联对象，也是根据这个原理去重复的，尽管一般情况下，只有主对象会有重复记录，关联对象一般不会重复。
		10. Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？
			- Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false。
			- 它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。
			- 当然了，不光是Mybatis，几乎所有的包括Hibernate，支持延迟加载的原理都是一样的。
		11. Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？
			- 不同的Xml映射文件，如果配置了namespace，那么id可以重复；如果没有配置namespace，那么id不能重复；毕竟namespace不是必须的，只是最佳实践而已。
			- 原因就是namespace+id是作为Map，String, MappedStatement>的key使用的，如果没有namespace，就剩下id，那么，id重复会导致数据互相覆盖。有了namespace，自然id就可以重复，namespace不同，namespace+id自然也就不同。
		12. Mybatis中如何执行批处理？
			- 使用BatchExecutor完成批处理。
		13. Mybatis都有哪些Executor执行器？它们之间的区别是什么？
			- Mybatis有三种基本的Executor执行器，SimpleExecutor、ReuseExecutor、BatchExecutor。
			- SimpleExecutor：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。
			- ReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map，String, Statement>内，供下一次使用。简言之，就是重复使用Statement对象。
			- BatchExecutor：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。
			- 作用范围：Executor的这些特点，都严格限制在SqlSession生命周期范围内。
		14. Mybatis中如何指定使用哪一种Executor执行器？
			- 在Mybatis配置文件中，可以指定默认的ExecutorType执行器类型，也可以手动给DefaultSqlSessionFactory的创建SqlSession的方法传递ExecutorType类型参数。
		15. Mybatis是否可以映射Enum枚举类？
			- Mybatis可以映射枚举类，不单可以映射枚举类，Mybatis可以映射任何对象到表的一列上。映射方式为自定义一个TypeHandler，实现TypeHandler的setParameter()和getResult()接口方法。TypeHandler有两个作用，一是完成从javaType至jdbcType的转换，二是完成jdbcType至javaType的转换，体现为setParameter()和getResult()两个方法，分别代表设置sql问号占位符参数和获取列查询结果。
		16. Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？
			- 虽然Mybatis解析Xml映射文件是按照顺序解析的，但是，被引用的B标签依然可以定义在任何地方，Mybatis都可以正确识别。
			- 原理是，Mybatis解析A标签，发现A标签引用了B标签，但是B标签尚未解析到，尚不存在，此时，Mybatis会将A标签标记为未解析状态，然后继续解析余下的标签，包含B标签，待所有标签解析完毕，Mybatis会重新解析那些被标记为未解析的标签，此时再解析A标签时，B标签已经存在，A标签也就可以正常解析完成了。
		17. 简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？
			- Mybatis将所有Xml配置信息都封装到All-In-One重量级对象Configuration内部。在Xml映射文件中，parameterMap>标签会被解析为ParameterMap对象，其每个子元素会被解析为ParameterMapping对象。resultMap>标签会被解析为ResultMap对象，其每个子元素会被解析为ResultMapping对象。每一个select>、insert>、update>、delete>标签均会被解析为MappedStatement对象，标签内的sql会被解析为BoundSql对象。
		18. 为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？
			- Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半自动ORM映射工具。
	3. hibernate
		1. Hibernate中get和load有什么不同之处?
			- 把get和load放到一起进行对比是Hibernate面试时最常问到的问题，这是因为只有正确理解get()和load()这二者后才有可能高效地使用Hibernate。get和load的最大区别是，如果在缓存中没有找到相应的对象，get将会直接访问数据库并返回一个完全初始化好的对象，而这个过程有可能会涉及到多个数据库调用；而load方法在缓存中没有发现对象的情况下，只会返回一个代理对象，只有在对象getId()之外的其它方法被调用时才会真正去访问数据库，这样就能在某些情况下大幅度提高性能。
		2. Hibernate中save、persist和saveOrUpdate这三个方法的不同之处？
			- 除了get和load，这又是另外一个经常出现的Hibernate面试问题。 所有这三个方法，也就是save()、saveOrUpdate()和persist()都是用于将对象保存到数据库中的方法，但其中有些细微的差别。例如，save()只能INSERT记录，但是saveOrUpdate()可以进行 记录的INSERT和UPDATE。还有，save()的返回值是一个Serializable对象，而persist()方法返回值为void。你还可以访问 save、persist以及saveOrUpdate，找到它们所有的不同之处。
		3. Hibernate中的命名SQL查询指的是什么?
			- Hibernate的这个面试问题同Hibernate提供的查询功能相关。命名查询指的是用sql-query>标签在影射文档中定义的SQL查询，可以通过使用Session.getNamedQuery()方法对它进行调用。命名查询使你可以使用你所指定的一个名字拿到某个特定的查询。 Hibernate中的命名查询可以使用注解来定义，也可以使用我前面提到的xml影射问句来定义。在Hibernate中，@NameQuery用来定义单个的命名查询，@NameQueries用来定义多个命名查询。
		4. Hibernate中的SessionFactory有什么作用? SessionFactory是线程安全的吗？
			- 这也是Hibernate框架的常见面试问题。顾名思义，SessionFactory就是一个用于创建Hibernate的Session对象的工厂。SessionFactory通常是在应用启动时创建好的，应用程序中的代码用它来获得Session对象。作为一个单个的数据存储，它也是 线程安全的，所以多个线程可同时使用同一个SessionFactory。Java JEE应用一般只有一个SessionFactory，服务于客户请求的各线程都通过这个工厂来获得Hibernate的Session实例，这也是为什么SessionFactory接口的实现必须是线程安全的原因。还有，SessionFactory的内部状态包含着同对象关系影射有关的所有元数据，它是 不可变的，一旦创建好后就不能对其进行修改了。
		5. Hibernate中的Session指的是什么? 可否将单个的Session在多个线程间进行共享？
			- 前面的问题问完之后，通常就会接着再问这两个问题。问完SessionFactory的问题后就该轮到Session了。Session代表着Hibernate所做的一小部分工作，它负责维护者同数据库的链接而且 不是线程安全的，也就是说，Hibernage中的Session不能在多个线程间进行共享。虽然Session会以主动滞后的方式获得数据库连接，但是Session最好还是在用完之后立即将其关闭。
		6. hibernate中sorted collection和ordered collection有什么不同?
			- T这个是你会碰到的所有Hibernate面试问题中比较容易的问题。sorted collection是通过使用 Java的Comparator在内存中进行排序的，ordered collection中的排序用的是数据库的order by子句。对于比较大的数据集，为了避免在内存中对它们进行排序而出现 Java中的OutOfMemoryError，最好使用ordered collection。
		7. Hibernate中transient、persistent、detached对象三者之间有什么区别？
			- 在Hibernate中，对象具有三种状态：transient、persistent和detached。同Hibernate的session有关联的对象是persistent对象。对这种对象进行的所有修改都会按照事先设定的刷新策略，反映到数据库之中，也即，可以在对象的任何一个属性发生改变时自动刷新，也可以通过调用Session.flush()方法显式地进行刷新。如果一个对象原来同Session有关联关系，但当下却没有关联关系了，这样的对象就是detached的对象。你可以通过调用任意一个session的update()或者saveOrUpdate()方法，重新将该detached对象同相应的seesion建立关联关系。Transient对象指的是新建的持久化类的实例，它还从未同Hibernate的任何Session有过关联关系。同样的，你可以调用persist()或者save()方法，将transient对象变成persistent对象。可要记住，这里所说的transient指的可不是 Java中的transient关键字，二者风马牛不相及。
		8. Hibernate中Session的lock()方法有什么作用?
			- 这是一个比较棘手的Hibernate面试问题，因为Session的lock()方法重建了关联关系却并没有同数据库进行同步和更新。因此，你在使用lock()方法时一定要多加小心。顺便说一下，在进行关联关系重建时，你可以随时使用Session的update()方法同数据库进行同步。有时这个问题也可以这么来问：Session的lock()方法和update()方法之间有什么区别？。这个小节中的关键点也可以拿来回答这个问题。
		9. Hibernate中二级缓存指的是什么？
			- 这是同Hibernate的缓存机制相关的第一个面试问题，不出意外后面还会有更多这方面的问题。二级缓存是在SessionFactory这个级别维护的缓存，它能够通过节省几番数据库调用往返来提高性能。还有一点值得注意，二级缓存是针对整个应用而不是某个特定的session的。
		10. Hibernate中的查询缓存指的是什么？
			- 这个问题有时是作为上个Hibernate面试问题的后继问题提出的。查询缓存实际上保存的是sql查询的结果，这样再进行相同的sql查询就可以之间从缓存中拿到结果了。为了改善性能，查询缓存可以同二级缓存一起来使用。Hibernate支持用多种不同的开源缓存方案，比如EhCache，来实现查询缓存。
		11. 为什么在Hibernate的实体类中要提供一个无参数的构造器这一点非常重要？
			- 每个Hibernate实体类必须包含一个 无参数的构造器, 这是因为Hibernate框架要使用Reflection API，通过调用Class.newInstance()来创建这些实体类的实例。如果在实体类中找不到无参数的构造器，这个方法就会抛出一个InstantiationException异常。
		12. 可不可以将Hibernate的实体类定义为final类?
			- 是的，你可以将Hibernate的实体类定义为final类，但这种做法并不好。因为Hibernate会使用代理模式在延迟关联的情况下提高性能，如果你把实体类定义成final类之后，因为 Java不允许对final类进行扩展，所以Hibernate就无法再使用代理了，如此一来就限制了使用可以提升性能的手段。不过，如果你的持久化类实现了一个接口而且在该接口中声明了所有定义于实体类中的所有public的方法轮到话，你就能够避免出现前面所说的不利后果。
	4. strtus
		1. struts2工作流程
			1. Struts 2框架本身大致可以分为3个部分：核心控制器FilterDispatcher、业务控制器Action和用户实现的企业业务逻辑组件。
				1. 核心控制器FilterDispatcher是Struts 2框架的基础，包含了框架内部的控制流程和处理机制。
				2. 业务控制器Action和业务逻辑组件是需要用户来自己实现的。用户在开发Action和业务逻辑组件的同时，还需要编写相关的配置文件，供核心控制器FilterDispatcher来使用。Struts 2的工作流程相对于Struts 1要简单，与WebWork框架基本相同，所以说Struts2WebWork的升级版本。
			2. 基本简要流程如下：
				1. 客户端初始化一个指向Servlet容器的请求；
				2. 这个请求经过一系列的过滤器（Filter）
					- 这些过滤器中有一个叫做ActionContextCleanUp的可选过滤器，这个过滤器对于Struts2和其他框架的集成很有帮助，例如：SiteMesh Plugin
				3. 接着FilterDispatcher被调用,FilterDispatcher询问ActionMapper来决定这个请是否需要调用某个Action
				4. 如果ActionMapper决定需要调用某个Action，FilterDispatcher把请求的处理交给ActionProxy
				5. ActionProxy通过Configuration Manager询问框架的配置文件，找到需要调用的Action类
				6. ActionProxy创建一个ActionInvocation的实例。
				7. ActionInvocation实例使用命名模式来调用，在调用Action的过程前后，涉及到相关拦截器（Intercepter）的调用。
				8. 一旦Action执行完毕，ActionInvocation负责根据struts.xml中的配置找到对应的返回结果。返回结果通常是（但不总是，也可 能是另外的一个Action链）一个需要被表示的JSP或者FreeMarker的模版。在表示的过程中可以使用Struts2 框架中继承的标签。在这个过程中需要涉及到ActionMapper
				9. 响应的返回是通过我们在web.xml中配置的过滤器
				10. 如果ActionContextCleanUp是当前使用的，则FilterDispatecher将不会清理sreadlocal ActionContext;如果ActionContextCleanUp不使用，则将会去清理sreadlocals。
		2. 说下Struts的设计模式
			- MVC模式:
				1. web应用程序启动时就会加载并初始化ActionServler。
				2. 用户提交表单时，一个配置好的ActionForm对象被创建，并被填入表单相应的数据，ActionServler根据Struts-config.xml文件配置好的设置决定是否需要表单验证，如果需要就调用ActionForm的Validate（）验证后选择将请求发送到哪个Action，如果Action不存在，ActionServlet会先创建这个对象，然后调用Action的execute（）方法.
				3. Execute（）从ActionForm对象中获取数据，完成业务逻辑，返回一个ActionForward对象，ActionServlet再把客户请求转发给ActionForward对象指定的jsp组件，ActionForward对象指定的jsp生成动态的网页，返回给客户。
		3. 拦截器和过滤器的区别
			1. 拦截器是基于java反射机制的，而过滤器是基于函数回调的。
			2. 过滤器依赖于servlet容器，而拦截器不依赖于servlet容器。
			3. 拦截器只能对Action请求起作用，而过滤器则可以对几乎所有请求起作用。
			4. 拦截器可以访问Action上下文、值栈里的对象，而过滤器不能。
			5. 在Action的生命周期中，拦截器可以多次调用，而过滤器只能在容器初始化时被调用一次。
		4. struts1于struts2的比较
			1. Action类:
				- Struts1要求Action类继承一个抽象基类。Struts1的一个普遍问题是使用抽象类编程而不是接口。
				- Struts2Action类可以实现一个Action接口，也可实现其他接口，使可选和定制的服务成为可能。Struts2提供一个ActionSupport基类去 实现常用的接口。Action接口不是必须的，任何有execute标识的POJO对象都可以用作Struts2的Action对象。
			2. 线程模式:
    			- Struts1Action是单例模式并且必须是线程安全的，因为仅有Action的一个实例来处理所有的请求。单例策略限制了Struts1   Action能作的事，并且要在开发时特别小心。Action资源必须是线程安全的或同步的。
				- Struts2Action对象为每一个请求产生一个实例，因此没有线程安全问题。（实际上，servlet容器给每个请求产生许多可丢弃的对象，并且不会导致性能和垃圾回收问题）
			3. Servlet依赖:
				- Struts1Action依赖于ServletAPI,因为当一个Action被调用时HttpServletRequest和HttpServletResponse被传递给execute方法。
				- Struts2Action不依赖于容器，允许Action脱离容器单独被测试。如果需要，Struts2Action仍然可以访问初始的request和response。但是，其他的元素减少或者消除了直接访问HttpServetRequest和HttpServletResponse的必要性。
			4. 可测性:
				- 测试Struts1Action的一个主要问题是execute方法暴露了servletAPI（这使得测试要依赖于容器）。一个第三方扩展－－StrutsTestCase－－提供了一套Struts1的模拟对象（来进行测试）。
				- Struts2Action可以通过初始化、设置属性、调用方法来测试，“依赖注入”支持也使测试更容易。
			5. 捕获输入:
				- Struts1使用ActionForm对象捕获输入。所有的ActionForm必须继承一个基类。因为其他JavaBean不能用作ActionForm，开发者经 常创建多余的类捕获输入。动态Bean（DynaBeans）可以作为创建传统ActionForm的选择，但是，开发者可能是在重新描述(创建)已经存 在的JavaBean（仍然会导致有冗余的javabean）。
				- Struts2直接使用Action属性作为输入属性，消除了对第二个输入对象的需求。输入属性可能是有自己(子)属性的rich对象类型。Action属性能够通过web页面上的taglibs访问。Struts2也支持ActionForm模式。rich对象类型，包括业务对象，能够用作输入/输出对象。这种ModelDriven特性简化了taglib对POJO输入对象的引用。
			6. 表达式语言：
				- Struts1整合了JSTL，因此使用JSTLEL。这种EL有基本对象图遍历，但是对集合和索引属性的支持很弱。
				- Struts2可以使用JSTL，但是也支持一个更强大和灵活的表达式语言－－ "Object Graph Notation Language "   (OGNL).
			7. 绑定值到页面（view）:
   				- Struts1使用标准JSP机制把对象绑定到页面中来访问。
				- Struts2使用"ValueStack "技术，使taglib能够访问值而不需要把你的页面（view）和对象绑定起来。ValueStack策略允许通过一系列名称相同但类型不同的属性重用页面（view）。
			8. 类型转换：
   				- Struts1ActionForm属性通常都是String类型。Struts1使用Commons-Beanutils进行类型转换。每个类一个转换器，对每一个实例来说是不可配置的。
				- Struts2使用OGNL进行类型转换。提供基本和常用对象的转换器。
			9. 校验：
				- Struts1支持在ActionForm的validate方法中手动校验，或者通过CommonsValidator的扩展来校验。同一个类可以有不同的校验内容，但不能校验子对象。
				- Struts2支持通过validate方法和XWork校验框架来进行校验。XWork校验框架使用为属性类类型定义的校验和内容校验，来支持chain校验子属性
			10. Action执行的控制：
				- Struts1支持每一个模块有单独的RequestProcessors（生命周期），但是模块中的所有Action必须共享相同的生命周期。
				- Struts2支持通过拦截器堆栈（Interceptor   Stacks）为每一个Action创建不同的生命周期。堆栈能够根据需要和不同的Action一起使用。
		5. 为什么要使用Struts2
			- Struts2 是一个相当强大的Java Web开源框架，是一个基于POJO的Action的MVC Web框架。它基于当年的Webwork和XWork框架，继承其优点，同时做了相当的改进。
			- 原因
				1. Struts2基于MVC架构
					- 框架结构清晰，开发流程一目了然，开发人员可以很好的掌控开发的过程。
				2. 使用OGNL进行参数传递
					- OGNL提供了在Struts2里访问各种作用域中的数据的简单方式，你可以方便的获取Request，Attribute，Application，Session，Parameters中的数据。大大简化了开发人员在获取这些数据时的代码量。
				3. 强大的拦截器
					- Struts2 的拦截器是一个Action级别的AOP，Struts2中的许多特性都是通过拦截器来实现的，例如异常处理，文件上传，验证等。拦截器是可配置与重用的，可以将一些通用的功能如：登录验证，权限验证等置于拦截器中以完成一些Java Web项目中比较通用的功能。在我实现的的一Web项目中，就是使用Struts2的拦截器来完成了系统中的权限验证功能。
				4. 易于测试
					- Struts2的Action都是简单的POJO，这样可以方便的对Struts2的Action编写测试用例，大大方便了5Java Web项目的测试。
					- 易于扩展的插件机制在Struts2添加扩展是一件愉快而轻松的事情，只需要将所需要的Jar包放到WEB-INF/lib文件夹中，在struts.xml中作一些简单的设置就可以实现扩展。
				5. 模块化管理
					- Struts2已经把模块化作为了体系架构中的基本思想，可以通过三种方法来将应用程序模块化：将配置信息拆分成多个文件把自包含的应用模块创建为插件创建新的框架特性，即将与特定应用无关的新功能组织成插件，以添加到多个应用中去。
				6. 全局结果与声明式异常
					- 为应用程序添加全局的Result，和在配置文件中对异常进行处理，这样当处理过程中出现指定异常时，可以跳转到特定页面。
			- 他的如此之多的优点，是很多人比较的青睐，与spring ,Hibernate进行结合，组成了现在比较流行的ssh框架，当然每个公司都要自己的框架，也是ssh变异的产品。
		6. struts2有哪些优点？
			1. 在软件设计上Struts2的应用可以不依赖于Servlet API和struts API。 Struts2的这种设计属于无侵入式设计；
			2. 拦截器，实现如参数拦截注入等功能；
			3. 类型转换器，可以把特殊的请求参数转换成需要的类型；
			4. 多种表现层技术，如：JSP、freeMarker、Velocity等；
			5. Struts2的输入校验可以对指定某个方法进行校验；
			6. 提供了全局范围、包范围和Action范围的国际化资源文件管理实现
		7. struts2是如何启动的？
			1. struts2框架是通过Filter启动的，即StrutsPrepareAndExecuteFilter，此过滤器为struts2的核心过滤器； 
			2. StrutsPrepareAndExecuteFilter的init()方法中将会读取类路径下默认的配置文件struts.xml完成初始化操作。struts2读取到struts.xml的内容后，是将内容封装进javabean对象然后存放在内存中，以后用户的每次请求处理将使用内存中的数据，而不是每次请求都读取struts.xml文件。
		8. struts2框架的核心控制器是什么？它有什么作用？
			- Struts2框架的核心控制器是StrutsPrepareAndExecuteFilter。
			- 作用：
				- 负责拦截由<url-pattern>/*</url-pattern>指定的所有用户请求，当用户请求到达时，该Filter会过滤用户的请求。默认情况下，如果用户请求的路径 不带后缀或者后缀以.action结尾，这时请求将被转入struts2框架处理，否则struts2框架将略过该请求的处理。 可以通过常量"struts.action.extension"修改action的后缀，如： constant name="struts.action.extension" value="do"/> 如果用户需要指定多个请求后缀，则多个后缀之间以英文逗号（,）隔开。constant name="struts.action.extension" value="do,go"/>
		9. struts2配置文件的加载顺序？
			- struts.xml ——> struts.properties
			- 常量可以在struts.xml或struts.properties中配置，如果在多个文件中配置了同一个常量，则后一个文件中配置的常量值会覆盖前面文件中配置的常量值.
			- struts.xml文件的作用：通知Struts2框架加载对应的Action资源
		10. struts2常量的修改方式？
			- 常量可以在struts.xml或struts.properties中配置，两种配置方式如下：
				1. 在struts.xml文件中配置常量constant name="struts.action.extension" value="do"/>
				2. 在struts.properties中配置常量（struts.properties文件放置在src下）：struts.action.extension=dostruts2如何访问HttpServletRequest、HttpSession、ServletContext三个域对象
					- 方案一
						- HttpServletRequest request =ServletActionContext.getRequest();
						- HttpServletResponse response =ServletActionContext.getResponse();
						- HttpSession  session=   request.getSession();
						- ServletContext servletContext=ServletActionContext.getServletContext();
					- 方案二：
						- 类 implements ServletRequestAware,ServletResponseAware，SessionAware，ServletContextAware
					- 注意：框架自动传入对应的域对象
		11. struts2是如何管理action的？这种管理方式有什么好处？
			- struts2框架中使用包来管理Action，包的作用和java中的类包是非常类似的。主要用于管理一组业务功能相关的action。在实际应用中，我们应该把一组业务功能相关的Action放在同一个包下。
			- struts2中的默认包struts-default有什么作用？ 
				1. struts-default包是由struts内置的，它定义了struts2内部的众多拦截器和Result类型，而Struts2很多核心的功能都是通过这些内置的拦截器实现，如：从请求中把请求参数封装到action、文件上传和数据验证等等都是通过拦截器实现的。当包继承了struts-default包才能使用struts2为我们提供的这些功能。
				2. struts-default包是在struts-default.xml中定义，struts-default.xml也是Struts2默认配置文件。 Struts2每次都会自动加载 struts-default.xml文件。
				3. 通常每个包都应该继承struts-default包。
		12. struts2如何对指定的方法进行验证？
			1. validate()方法会校验action中所有与execute方法签名相同的方法；
			2. 要校验指定的方法通过重写validateXxx()方法实现， validateXxx()只会校验action中方法名为Xxx的方法。其中Xxx的第一个字母要大写；
			3. 当某个数据校验失败时，调用addFieldError()方法往系统的fieldErrors添加校验失败信息（为了使用addFieldError()方法，action可以继承ActionSupport）， 如果系统 的fieldErrors包含失败信息，struts2会将请求转发到名为input的result；
			4. 在input视图中可以通过<s:fielderror/>显示失败信息。
			5. 先执行validateXxxx()->validate()->如果出错了，会转发<result name="input"/>所指定的页面，如果不出错，会直接进行Action::execute()方法 
		13. struts2默认能解决get和post提交方式的乱码问题吗？
			 - 不能。struts.i18n.encoding=UTF-8属性值只能解析POST提交下的乱码问题。
		14. 请你写出struts2中至少5个的默认拦截器？
			- fileUpload
				- 提供文件上传功能
			- i18n
				- 记录用户选择的locale
			- cookies
            	- 使用配置的name,value来是指cookies
            - checkbox
            	- 添加了checkbox自动处理代码，将没有选中的checkbox的内容设定为false，而html默认情况下不提交没有选中的checkbox。
            - chain
            	- 让前一个Action的属性可以被后一个Action访问，现在和chain类型的result（）结合使用。
            - alias
            	- 在不同请求之间将请求参数在不同名字件转换，请求内容不变
		15. 值栈ValueStack的原理与生命周期？
			1. ValueStack贯穿整个 Action 的生命周期，保存在request域中，所以ValueStack和request的生命周期一样。当Struts2接受一个请求时，会迅速创建ActionContext，ValueStack，action。然后把action存放进ValueStack，所以action的实例变量可以被OGNL访问。 请求来的时候，action、ValueStack的生命开始，请求结束，action、    ValueStack的生命结束；
			2. action是多例的，和Servlet不一样，Servelt是单例的；
			3. 每个action的都有一个对应的值栈，值栈存放的数据类型是该action的实例，以及该action中的实例变量，Action对象默认保存在栈顶；
			4. ValueStack本质上就是一个ArrayList；
			5. 关于ContextMap，Struts 会把下面这些映射压入 ContextMap 中：parameters:该Map中包含当前请求的请求参数 request:该 Map 中包含当前 request 对象中的所有属性session :该 Map 中包含当前 session 对象中的所有属性application :该 Map 中包含当前 application 对象中的所有属性attr:该 Map 按如下顺序来检索某个属性: request, session, application
			6. 使用OGNL访问值栈的内容时，不需要#号，而访问request、session、application、attr时，需要加#号；
			7. 注意： Struts2中，OGNL表达式需要配合Struts标签才可以使用。如：s:property value="name"/>
			8. 在struts2配置文件中引用ognl表达式 ,引用值栈的值 ，此时使用的"$"，而不是#或者%;
		16. ActionContext、ServletContext、pageContext的区别？
			1. ActionContext是当前的Action的上下文环境，通过ActionContext可以获取到request、session、ServletContext等与Action有关的对象的引用；
			2. ServletContext是域对象，一个web应用中只有一个ServletContext，生命周期伴随整个web应用；
			3. pageContext是JSP中的最重要的一个内置对象，可以通过pageContext获取其他域对象的应用，同时它是一个域对象，作用范围只针对当前页面，当前页面结束时，pageContext销毁，生命周期是JSP四个域对象中最小的。
		17. result的type属性中有哪几种结果类型？
			- 一共10种
				- dispatcher是struts默认的结果类型，把控制权转发给应用程序里的某个资源不能把控制权转发给一个外部资源，若需要把控制权重定向到一个外部资源, 应该使用redirect结果类型redirect把响应重定向到另一个资源（包括一个外部资源）redirectAction把响应重定向到另一个Action freemarker、velocity、chain、httpheader、xslt、plainText、stream
		18. 拦截器的生命周期与工作过程？
			1. 每个拦截器都是实现了Interceptor接口的 Java 类； 
			2. init(): 该方法将在拦截器被创建后立即被调用, 它在拦截器的生命周期内只被调用一次. 可以在该方法中对相关资源进行必要的初始化；
			3. intercept(ActionInvocation invocation): 每拦截一个动作请求, 该方法就会被调用一次；
			4. destroy: 该方法将在拦截器被销毁之前被调用, 它在拦截器的生命周期内也只被调用一次；
			5. struts2中有内置了18个拦截器。
		19. struts2如何完成文件的上传？
			1. JSP页面
				1. JSP页面的上传文件的组件：<s: file name=”upload” />，如果需要一次上传多个文件, 就必须使用多个 file 标签, 但它们的名字必须是相同的，即name=“xxx”的值必须一样；
				2. 必须把表单的enctype属性设置为：multipart/form-data；
				3. 表单的方法必须为post，因为post提交的数据在消息体中，而无大小限制。
			2. 对应的action
				1. 在Action中新添加3个和文件上传相关的属性；
				2. 如果是上传单个文件, uploadImage属性的类型就是 java.io.File, 它代表被上传的文件, 第二个和第三个属性的类型是 String, 它们分别代表上传文件的文件名和文件类型，定义方式是分别是：jsp页面file组件的名称+ContentType,  jsp页面file组件的名称+FileName
				3. 如果上上传多个文件, 可以使用数组或List
		20. struts的工作原理
			1. 初始化，读取struts-config.xml、web.xml等配置文件（所有配置文件的初始化）
			2. 发送HTTP请求,客户端发送以.do结尾的请求
			3. 填充FormBean（实例化、复位、填充数据、校验、保存）
			4. 将请求转发到Action（调用Action的execute（）方法）
			5. 处理业务（可以调用后台类，返回ActionForward对象）
			6. 返回目标响应对象（从Action返回到ActionServlet）
			7. 转换Http请求到目标响应对象（查找响应，根据返回的Forward keyword）
			8. Http响应，返回到Jsp页面
		21. 用自己的话简要阐述struts2的执行流程。
			- Struts 2框架本身大致可以分为3个部分：核心控制器FilterDispatcher、业务控制器Action和用户实现的企业业务逻辑组件。
			- 核心控制器FilterDispatcher是Struts 2框架的基础，包含了框架内部的控制流程和处理机制。
			- 业务控制器Action和业务逻辑组件是需要用户来自己实现的。用户在开发Action和业务逻辑组件的同时，还需要编写相关的配置文件，供核心控制器FilterDispatcher来使用。
			- Struts 2的工作流程相对于Struts 1要简单，与WebWork框架基本相同，所以说Struts 2是WebWork的升级版本。基本简要流程如下：
				1. 客户端浏览器发出HTTP请求。
				2. 根据web.xml配置，该请求被FilterDispatcher接收。
				3. 根据struts.xml配置，找到需要调用的Action类和方法， 并通过IoC方式，将值注入给Aciton。
				4. Action调用业务逻辑组件处理业务逻辑，这一步包含表单验证。
				5. Action执行完毕，根据struts.xml中的配置找到对应的返回结果result，并跳转到相应页面。
				6. 返回HTTP响应到客户端浏览器。
				7. 它是以Webwork的设计思想为核心，吸收struts1的优点，可以说 struts2是struts1和Webwork结合的产物。
			- struts2 的工作原理图： 一个请求在Struts2框架中的处理分为以下几个步骤：
			1. 客户端发出一个指向servlet容器的请求(tomcat)；
			2. 这个请求会经过图中的几个过滤器，最后会到达FilterDispatcher过滤器。
			3. 过滤器FilterDispatcher是struts2框架的心脏，在处理用户请求时，它和请求一起相互配合访问struts2 的底层框架结构。在web容器启动时，struts2框架会自动加载配置文件里相关参数，并转换成相应的类。 如：ConfigurationManager、ActionMapper和ObjectFactory。ConfigurationManager 存有配置文件的一 些基本信息，ActionMapper存有action的配置信息。在请求过程中所有的对象（Action，Results， Interceptors，等）都是通过ObjectFactory来创建的。过滤器会通过询问ActionMapper类来查找请求中 需要用到的Action。
			4. 如果找到需要调用的Action，过滤器会把请求的处理交给ActionProxy。ActionProxy为Action的代理对象 。ActionProxy通过ConfigurationManager询问框架的配置文件，找到需要调用的Action。
			5. ActionProxy创建一个ActionInvocation的实例。ActionInvocation在ActionProxy层之下，它表示了 Action的执行状态,或者说它控制的Action的执行步骤。它持有Action实例和所有的Interceptor。
			6. ActionInvocation实例使用命名模式来调用，
				1. ActionInvocation初始化时，根据配置，加载Action相 关的所有Interceptor。
				2. 通过ActionInvocation.invoke方法调用Action实现时，执行Interceptor。在 调用Action的过程前后，涉及到相关拦截器(intercepetor)的调用。
			7. 一旦Action执行完毕，ActionInvocation负责根据struts.xml中的配置找到对应的返回结果。返回结果 通常是（但不总是，也可能是另外的一个Action链）一个需要被表示的JSP或者FreeMarker的模版。在表 示的过程中可以使用Struts2 框架中继承的标签。
6. 熟悉分布式系统的设计和应用
7. 熟悉分布式
8. 缓存
9. 消息等机制
10. 能对分布式常用技术进行合理应用，解决问题
11. 掌握多线程
12. 高性能的设计
13. 编码及性能调优
14. 有高并发应用开发经验
15. 掌握Linux 操作系统
16. 大型数据库（Oracle、MySql）
17. 对sql优化有丰富的经验
18. 学习能力强，适应能力好，有强烈的责任心，具备耐心/细心的品质；


































